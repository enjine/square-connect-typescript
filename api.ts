/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * OpenAPI spec version: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://connect.squareup.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Defines request parameters for the AcceptDispute endpoint.
*/
export class AcceptDisputeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AcceptDisputeRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a AcceptDispute response.
*/
export class AcceptDisputeResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * Details about the accepted dispute.
    */
    'dispute'?: Dispute;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "dispute",
            "baseName": "dispute",
            "type": "Dispute"
        }    ];

    static getAttributeTypeMap() {
        return AcceptDisputeResponse.attributeTypeMap;
    }
}

/**
* A request to accumulate points for a purchase.
*/
export class AccumulateLoyaltyPointsRequest {
    /**
    * The points to add to the account.  If you are using the Orders API to manage orders, you   specify the order ID. Otherwise, specify the  points to add.
    */
    'accumulatePoints': LoyaltyEventAccumulatePoints;
    /**
    * A unique string that identifies the `AccumulateLoyaltyPoints` request.  Keys can be any valid string but must be unique for every request.
    */
    'idempotencyKey': string;
    /**
    * The `location` where the purchase was made.
    */
    'locationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accumulatePoints",
            "baseName": "accumulate_points",
            "type": "LoyaltyEventAccumulatePoints"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccumulateLoyaltyPointsRequest.attributeTypeMap;
    }
}

/**
* A response containing the resulting loyalty event.
*/
export class AccumulateLoyaltyPointsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The resulting loyalty event.
    */
    'event'?: LoyaltyEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "LoyaltyEvent"
        }    ];

    static getAttributeTypeMap() {
        return AccumulateLoyaltyPointsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ActionCancelReason {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ActionCancelReason.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the request body of a request to the [AddGroupToCustomer](#endpoint-addgrouptocustomer) endpoint.
*/
export class AddGroupToCustomerRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AddGroupToCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [AddGroupToCustomer](#endpoint-addgrouptocustomer) endpoint.
*/
export class AddGroupToCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return AddGroupToCustomerResponse.attributeTypeMap;
    }
}

/**
* Represents an additional recipient (other than the merchant) receiving a portion of this tender.
*/
export class AdditionalRecipient {
    /**
    * The location ID for a recipient (other than the merchant) receiving a portion of this tender.
    */
    'locationId': string;
    /**
    * The description of the additional recipient.
    */
    'description': string;
    /**
    * The amount of money distributed to the recipient.
    */
    'amountMoney': Money;
    /**
    * The unique ID for this `AdditionalRecipientReceivable`, assigned by the server.
    */
    'receivableId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "receivableId",
            "baseName": "receivable_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdditionalRecipient.attributeTypeMap;
    }
}

/**
* Represents a physical address.
*/
export class Address {
    /**
    * The first line of the address.  Fields that start with `address_line` provide the address's most specific details, like street number, street name, and building name. They do *not* provide less specific details like city, state/province, or country (these details are provided in other fields).
    */
    'addressLine1'?: string;
    /**
    * The second line of the address, if any.
    */
    'addressLine2'?: string;
    /**
    * The third line of the address, if any.
    */
    'addressLine3'?: string;
    /**
    * The city or town of the address.
    */
    'locality'?: string;
    /**
    * A civil region within the address's `locality`, if any.
    */
    'sublocality'?: string;
    /**
    * A civil region within the address's `sublocality`, if any.
    */
    'sublocality2'?: string;
    /**
    * A civil region within the address's `sublocality_2`, if any.
    */
    'sublocality3'?: string;
    /**
    * A civil entity within the address's country. In the US, this is the state.
    */
    'administrativeDistrictLevel1'?: string;
    /**
    * A civil entity within the address's `administrative_district_level_1`. In the US, this is the county.
    */
    'administrativeDistrictLevel2'?: string;
    /**
    * A civil entity within the address's `administrative_district_level_2`, if any.
    */
    'administrativeDistrictLevel3'?: string;
    /**
    * The address's postal code.
    */
    'postalCode'?: string;
    /**
    * The address's country, in ISO 3166-1-alpha-2 format. See [Country](#type-country) for possible values
    */
    'country'?: string;
    /**
    * Optional first name when it's representing recipient.
    */
    'firstName'?: string;
    /**
    * Optional last name when it's representing recipient.
    */
    'lastName'?: string;
    /**
    * Optional organization name when it's representing recipient.
    */
    'organization'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addressLine1",
            "baseName": "address_line_1",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "address_line_2",
            "type": "string"
        },
        {
            "name": "addressLine3",
            "baseName": "address_line_3",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "sublocality",
            "baseName": "sublocality",
            "type": "string"
        },
        {
            "name": "sublocality2",
            "baseName": "sublocality_2",
            "type": "string"
        },
        {
            "name": "sublocality3",
            "baseName": "sublocality_3",
            "type": "string"
        },
        {
            "name": "administrativeDistrictLevel1",
            "baseName": "administrative_district_level_1",
            "type": "string"
        },
        {
            "name": "administrativeDistrictLevel2",
            "baseName": "administrative_district_level_2",
            "type": "string"
        },
        {
            "name": "administrativeDistrictLevel3",
            "baseName": "administrative_district_level_3",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Address.attributeTypeMap;
    }
}

/**
* A request to adjust (add or subtract) points manually.
*/
export class AdjustLoyaltyPointsRequest {
    /**
    * A unique string that identifies this `AdjustLoyaltyPoints` request.  Keys can be any valid string, but must be unique for every request.
    */
    'idempotencyKey': string;
    /**
    * The points to adjust (add or subtract) and the reason for the adjustment.
    */
    'adjustPoints': LoyaltyEventAdjustPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "adjustPoints",
            "baseName": "adjust_points",
            "type": "LoyaltyEventAdjustPoints"
        }    ];

    static getAttributeTypeMap() {
        return AdjustLoyaltyPointsRequest.attributeTypeMap;
    }
}

/**
* A response that includes the loyalty event that  resulted from the successful API call.
*/
export class AdjustLoyaltyPointsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The resulting event data for adjusting points.
    */
    'event'?: LoyaltyEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "LoyaltyEvent"
        }    ];

    static getAttributeTypeMap() {
        return AdjustLoyaltyPointsResponse.attributeTypeMap;
    }
}

/**
* Reflects the current status of a balance payment.
*/
export class BalancePaymentDetails {
    /**
    * ID for the account used to fund the payment.
    */
    'accountId'?: string;
    /**
    * The balance paymentâ€™s current state. Can be `COMPLETED` or `FAILED`.
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalancePaymentDetails.attributeTypeMap;
    }
}

/**
* Represents a bank account. For more information about  linking a bank account to a Square account, see  [Bank Accounts API](/docs/bank-accounts-api).
*/
export class BankAccount {
    /**
    * The unique, Square-issued identifier for the bank account.
    */
    'id': string;
    /**
    * The last few digits of the account number.
    */
    'accountNumberSuffix': string;
    /**
    * The ISO 3166 Alpha-2 country code where the bank account is based. See [Country](#type-country) for possible values
    */
    'country': string;
    /**
    * The 3-character ISO 4217 currency code indicating the operating currency of the bank account. For example, the currency code for US dollars is `USD`. See [Currency](#type-currency) for possible values
    */
    'currency': string;
    /**
    * The financial purpose of the associated bank account. See [BankAccountType](#type-bankaccounttype) for possible values
    */
    'accountType': string;
    /**
    * Name of the account holder. This name must match the name  on the targeted bank account record.
    */
    'holderName': string;
    /**
    * Primary identifier for the bank. For more information, see  [Bank Accounts API](https://developer.squareup.com/docs/docs/bank-accounts-api).
    */
    'primaryBankIdentificationNumber': string;
    /**
    * Secondary identifier for the bank. For more information, see  [Bank Accounts API](https://developer.squareup.com/docs/docs/bank-accounts-api).
    */
    'secondaryBankIdentificationNumber'?: string;
    /**
    * Reference identifier that will be displayed to UK bank account owners when collecting direct debit authorization. Only required for UK bank accounts.
    */
    'debitMandateReferenceId'?: string;
    /**
    * Client-provided identifier for linking the banking account to an entity in a third-party system (for example, a bank account number or a user identifier).
    */
    'referenceId'?: string;
    /**
    * The location to which the bank account belongs.
    */
    'locationId'?: string;
    /**
    * Read-only. The current verification status of this BankAccount object. See [BankAccountStatus](#type-bankaccountstatus) for possible values
    */
    'status': string;
    /**
    * Indicates whether it is possible for Square to send money to this bank account.
    */
    'creditable': boolean;
    /**
    * Indicates whether it is possible for Square to take money from this  bank account.
    */
    'debitable': boolean;
    /**
    * A Square-assigned, unique identifier for the bank account based on the account information. The account fingerprint can be used to compare account entries and determine if the they represent the same real-world bank account.
    */
    'fingerprint'?: string;
    /**
    * The current version of the `BankAccount`.
    */
    'version'?: number;
    /**
    * Read only. Name of actual financial institution.  For example \"Bank of America\".
    */
    'bankName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "accountNumberSuffix",
            "baseName": "account_number_suffix",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "holderName",
            "baseName": "holder_name",
            "type": "string"
        },
        {
            "name": "primaryBankIdentificationNumber",
            "baseName": "primary_bank_identification_number",
            "type": "string"
        },
        {
            "name": "secondaryBankIdentificationNumber",
            "baseName": "secondary_bank_identification_number",
            "type": "string"
        },
        {
            "name": "debitMandateReferenceId",
            "baseName": "debit_mandate_reference_id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "creditable",
            "baseName": "creditable",
            "type": "boolean"
        },
        {
            "name": "debitable",
            "baseName": "debitable",
            "type": "boolean"
        },
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccount.attributeTypeMap;
    }
}

/**
* Indicates the current verification status of a `BankAccount` object.
*/
export class BankAccountStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BankAccountStatus.attributeTypeMap;
    }
}

/**
* Indicates the financial purpose of the bank account.
*/
export class BankAccountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BankAccountType.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchChangeInventoryRequest {
    /**
    * A client-supplied, universally unique identifier (UUID) for the request.  See [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) in the [API Development 101](https://developer.squareup.com/docs/basics/api101/overview) section for more information.
    */
    'idempotencyKey'?: string;
    /**
    * The set of physical counts and inventory adjustments to be made. Changes are applied based on the client-supplied timestamp and may be sent out of order.
    */
    'changes'?: Array<InventoryChange>;
    /**
    * Indicates whether the current physical count should be ignored if the quantity is unchanged since the last physical count. Default: `true`.
    */
    'ignoreUnchangedCounts'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "changes",
            "baseName": "changes",
            "type": "Array<InventoryChange>"
        },
        {
            "name": "ignoreUnchangedCounts",
            "baseName": "ignore_unchanged_counts",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return BatchChangeInventoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchChangeInventoryResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The current counts for all objects referenced in the request.
    */
    'counts'?: Array<InventoryCount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "counts",
            "baseName": "counts",
            "type": "Array<InventoryCount>"
        }    ];

    static getAttributeTypeMap() {
        return BatchChangeInventoryResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchDeleteCatalogObjectsRequest {
    /**
    * The IDs of the CatalogObjects to be deleted. When an object is deleted, other objects in the graph that depend on that object will be deleted as well (for example, deleting a CatalogItem will delete its CatalogItemVariation.
    */
    'objectIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "objectIds",
            "baseName": "object_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BatchDeleteCatalogObjectsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchDeleteCatalogObjectsResponse {
    /**
    * The set of Errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The IDs of all CatalogObjects deleted by this request.
    */
    'deletedObjectIds'?: Array<string>;
    /**
    * The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this deletion in RFC 3339 format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'deletedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "deletedObjectIds",
            "baseName": "deleted_object_ids",
            "type": "Array<string>"
        },
        {
            "name": "deletedAt",
            "baseName": "deleted_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchDeleteCatalogObjectsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveCatalogObjectsRequest {
    /**
    * The IDs of the CatalogObjects to be retrieved.
    */
    'objectIds': Array<string>;
    /**
    * If `true`, the response will include additional objects that are related to the requested objects, as follows:  If the `objects` field of the response contains a CatalogItem, its associated CatalogCategory objects, CatalogTax objects, CatalogImage objects and CatalogModifierLists will be returned in the `related_objects` field of the response. If the `objects` field of the response contains a CatalogItemVariation, its parent CatalogItem will be returned in the `related_objects` field of the response.
    */
    'includeRelatedObjects'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "objectIds",
            "baseName": "object_ids",
            "type": "Array<string>"
        },
        {
            "name": "includeRelatedObjects",
            "baseName": "include_related_objects",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveCatalogObjectsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveCatalogObjectsResponse {
    /**
    * The set of `Error`s encountered.
    */
    'errors'?: Array<Error>;
    /**
    * A list of `CatalogObject`s returned.
    */
    'objects'?: Array<CatalogObject>;
    /**
    * A list of `CatalogObject`s referenced by the object in the `objects` field.
    */
    'relatedObjects'?: Array<CatalogObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "objects",
            "baseName": "objects",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "relatedObjects",
            "baseName": "related_objects",
            "type": "Array<CatalogObject>"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveCatalogObjectsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveInventoryChangesRequest {
    /**
    * The filter to return results by `CatalogObject` ID. The filter is only applicable when set. The default value is null.
    */
    'catalogObjectIds'?: Array<string>;
    /**
    * The filter to return results by `Location` ID.  The filter is only applicable when set. The default value is null.
    */
    'locationIds'?: Array<string>;
    /**
    * The filter to return results by `InventoryChangeType` values other than `TRANSFER`. The default value is `[PHYSICAL_COUNT, ADJUSTMENT]`. See [InventoryChangeType](#type-inventorychangetype) for possible values
    */
    'types'?: Array<string>;
    /**
    * The filter to return `ADJUSTMENT` query results by `InventoryState`. This filter is only applied when set. The default value is null. See [InventoryState](#type-inventorystate) for possible values
    */
    'states'?: Array<string>;
    /**
    * The filter to return results with their `calculated_at` value   after the given time as specified in an RFC 3339 timestamp.  The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
    */
    'updatedAfter'?: string;
    /**
    * The filter to return results with their `created_at` or `calculated_at` value   strictly before the given time as specified in an RFC 3339 timestamp.  The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
    */
    'updatedBefore'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "catalogObjectIds",
            "baseName": "catalog_object_ids",
            "type": "Array<string>"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<string>"
        },
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<string>"
        },
        {
            "name": "updatedAfter",
            "baseName": "updated_after",
            "type": "string"
        },
        {
            "name": "updatedBefore",
            "baseName": "updated_before",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveInventoryChangesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveInventoryChangesResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The current calculated inventory changes for the requested objects and locations.
    */
    'changes'?: Array<InventoryChange>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response. See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "changes",
            "baseName": "changes",
            "type": "Array<InventoryChange>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveInventoryChangesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveInventoryCountsRequest {
    /**
    * The filter to return results by `CatalogObject` ID. The filter is applicable only when set.  The default is null.
    */
    'catalogObjectIds'?: Array<string>;
    /**
    * The filter to return results by `Location` ID.  This filter is applicable only when set. The default is null.
    */
    'locationIds'?: Array<string>;
    /**
    * The filter to return results with their `calculated_at` value  after the given time as specified in an RFC 3339 timestamp.  The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
    */
    'updatedAfter'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;
    /**
    * The filter to return results by `InventoryState`. The filter is only applicable when set. Ignored are untracked states of `NONE`, `SOLD`, and `UNLINKED_RETURN`. The default is null. See [InventoryState](#type-inventorystate) for possible values
    */
    'states'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "catalogObjectIds",
            "baseName": "catalog_object_ids",
            "type": "Array<string>"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "updatedAfter",
            "baseName": "updated_after",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveInventoryCountsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchRetrieveInventoryCountsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The current calculated inventory counts for the requested objects and locations.
    */
    'counts'?: Array<InventoryCount>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "counts",
            "baseName": "counts",
            "type": "Array<InventoryCount>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveInventoryCountsResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the BatchRetrieveOrders endpoint.
*/
export class BatchRetrieveOrdersRequest {
    /**
    * The ID of the location for these orders. This field is optional: omit it to retrieve orders within the scope of the current authorization's merchant ID.
    */
    'locationId'?: string;
    /**
    * The IDs of the orders to retrieve. A maximum of 100 orders can be retrieved per request.
    */
    'orderIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "orderIds",
            "baseName": "order_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveOrdersRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the BatchRetrieveOrders endpoint.
*/
export class BatchRetrieveOrdersResponse {
    /**
    * The requested orders. This will omit any requested orders that do not exist.
    */
    'orders'?: Array<Order>;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orders",
            "baseName": "orders",
            "type": "Array<Order>"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return BatchRetrieveOrdersResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchUpsertCatalogObjectsRequest {
    /**
    * A value you specify that uniquely identifies this request among all your requests. A common way to create a valid idempotency key is to use a Universally unique identifier (UUID).  If you're unsure whether a particular request was successful, you can reattempt it with the same idempotency key without worrying about creating duplicate objects.  See [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * A batch of CatalogObjects to be inserted/updated atomically. The objects within a batch will be inserted in an all-or-nothing fashion, i.e., if an error occurs attempting to insert or update an object within a batch, the entire batch will be rejected. However, an error in one batch will not affect other batches within the same request.  For each object, its `updated_at` field is ignored and replaced with a current [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), and its `is_deleted` field must not be set to `true`.  To modify an existing object, supply its ID. To create a new object, use an ID starting with `#`. These IDs may be used to create relationships between an object and attributes of other objects that reference it. For example, you can create a CatalogItem with ID `#ABC` and a CatalogItemVariation with its `item_id` attribute set to `#ABC` in order to associate the CatalogItemVariation with its parent CatalogItem.  Any `#`-prefixed IDs are valid only within a single atomic batch, and will be replaced by server-generated IDs.  Each batch may contain up to 1,000 objects. The total number of objects across all batches for a single request may not exceed 10,000. If either of these limits is violated, an error will be returned and no objects will be inserted or updated.
    */
    'batches': Array<CatalogObjectBatch>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "batches",
            "baseName": "batches",
            "type": "Array<CatalogObjectBatch>"
        }    ];

    static getAttributeTypeMap() {
        return BatchUpsertCatalogObjectsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class BatchUpsertCatalogObjectsResponse {
    /**
    * Information on any errors that encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The created successfully created CatalogObjects.
    */
    'objects'?: Array<CatalogObject>;
    /**
    * The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this update in RFC 3339 format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'updatedAt'?: string;
    /**
    * The mapping between client and server IDs for this upsert.
    */
    'idMappings'?: Array<CatalogIdMapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "objects",
            "baseName": "objects",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "idMappings",
            "baseName": "id_mappings",
            "type": "Array<CatalogIdMapping>"
        }    ];

    static getAttributeTypeMap() {
        return BatchUpsertCatalogObjectsResponse.attributeTypeMap;
    }
}

/**
* A defined break template that sets an expectation for possible `Break` instances on a `Shift`.
*/
export class BreakType {
    /**
    * UUID for this object.
    */
    'id'?: string;
    /**
    * The ID of the business location this type of break applies to.
    */
    'locationId': string;
    /**
    * A human-readable name for this type of break. Will be displayed to employees in Square products.
    */
    'breakName': string;
    /**
    * Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of this break. Precision below minutes is truncated.
    */
    'expectedDuration': string;
    /**
    * Whether this break counts towards time worked for compensation purposes.
    */
    'isPaid': boolean;
    /**
    * Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If a value is not provided, Square's servers execute a \"blind\" write; potentially overwriting another writer's data.
    */
    'version'?: number;
    /**
    * A read-only timestamp in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "breakName",
            "baseName": "break_name",
            "type": "string"
        },
        {
            "name": "expectedDuration",
            "baseName": "expected_duration",
            "type": "string"
        },
        {
            "name": "isPaid",
            "baseName": "is_paid",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreakType.attributeTypeMap;
    }
}

/**
* Represents a bulk create request for `TeamMember` objects.
*/
export class BulkCreateTeamMembersRequest {
    /**
    * The data which will be used to create the `TeamMember` objects. Each key is the `idempotency_key` that maps to the `CreateTeamMemberRequest`.
    */
    'teamMembers': { [key: string]: CreateTeamMemberRequest; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMembers",
            "baseName": "team_members",
            "type": "{ [key: string]: CreateTeamMemberRequest; }"
        }    ];

    static getAttributeTypeMap() {
        return BulkCreateTeamMembersRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a bulk create request, containing the created `TeamMember` objects or error messages.
*/
export class BulkCreateTeamMembersResponse {
    /**
    * The successfully created `TeamMember` objects. Each key is the `idempotency_key` that maps to the `CreateTeamMemberRequest`.
    */
    'teamMembers'?: { [key: string]: CreateTeamMemberResponse; };
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMembers",
            "baseName": "team_members",
            "type": "{ [key: string]: CreateTeamMemberResponse; }"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return BulkCreateTeamMembersResponse.attributeTypeMap;
    }
}

/**
* Represents a bulk update request for `TeamMember` objects.
*/
export class BulkUpdateTeamMembersRequest {
    /**
    * The data which will be used to update the `TeamMember` objects. Each key is the `team_member_id` that maps to the `UpdateTeamMemberRequest`.
    */
    'teamMembers': { [key: string]: UpdateTeamMemberRequest; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMembers",
            "baseName": "team_members",
            "type": "{ [key: string]: UpdateTeamMemberRequest; }"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateTeamMembersRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a bulk update request, containing the updated `TeamMember` objects or error messages.
*/
export class BulkUpdateTeamMembersResponse {
    /**
    * The successfully updated `TeamMember` objects. Each key is the `team_member_id` that maps to the `UpdateTeamMemberRequest`.
    */
    'teamMembers'?: { [key: string]: UpdateTeamMemberResponse; };
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMembers",
            "baseName": "team_members",
            "type": "{ [key: string]: UpdateTeamMemberResponse; }"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateTeamMembersResponse.attributeTypeMap;
    }
}

/**
* Represents the hours of operation for a business location.
*/
export class BusinessHours {
    /**
    * The list of time periods during which the business is open. There may be at most 10 periods per day.
    */
    'periods'?: Array<BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "periods",
            "baseName": "periods",
            "type": "Array<BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHours.attributeTypeMap;
    }
}

/**
* Represents a period of time during which a business location is open.
*/
export class BusinessHoursPeriod {
    /**
    * The day of week for this time period. See [DayOfWeek](#type-dayofweek) for possible values
    */
    'dayOfWeek'?: string;
    /**
    * The start time of a business hours period, specified in local time using partial-time RFC3339 format.
    */
    'startLocalTime'?: string;
    /**
    * The end time of a business hours period, specified in local time using partial-time RFC3339 format.
    */
    'endLocalTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dayOfWeek",
            "baseName": "day_of_week",
            "type": "string"
        },
        {
            "name": "startLocalTime",
            "baseName": "start_local_time",
            "type": "string"
        },
        {
            "name": "endLocalTime",
            "baseName": "end_local_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* A request to calculate the points that a buyer can earn from  a specified purchase.
*/
export class CalculateLoyaltyPointsRequest {
    /**
    * The `order` ID for which to calculate the points. Specify this field if your application uses the Orders API to process orders. Otherwise, specify the `transaction_amount`.
    */
    'orderId'?: string;
    /**
    * The purchase amount for which to calculate the points.  Specify this field if your application does not use the Orders API to process orders. Otherwise, specify the `order_id`.
    */
    'transactionAmountMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "transactionAmountMoney",
            "baseName": "transaction_amount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return CalculateLoyaltyPointsRequest.attributeTypeMap;
    }
}

/**
* A response that includes the points that the buyer can earn from  a specified purchase.
*/
export class CalculateLoyaltyPointsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The points that the buyer can earn from a specified purchase.
    */
    'points'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CalculateLoyaltyPointsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CalculateOrderRequest {
    /**
    * The order to be calculated. Expects the entire order, not a sparse update.
    */
    'order': Order;
    /**
    * Identifies one or more loyalty reward tiers to apply during order calculation. The discounts defined by the reward tiers are added to the order only to preview the effect of applying the specified reward(s). The reward(s) do not correspond to actual redemptions, that is, no `reward`s are created. Therefore, the reward `id`s are random strings used only to reference the reward tier.
    */
    'proposedRewards'?: Array<OrderReward>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "proposedRewards",
            "baseName": "proposed_rewards",
            "type": "Array<OrderReward>"
        }    ];

    static getAttributeTypeMap() {
        return CalculateOrderRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CalculateOrderResponse {
    /**
    * The calculated version of the order provided in the request.
    */
    'order'?: Order;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CalculateOrderResponse.attributeTypeMap;
    }
}

/**
* Describes a `CancelInvoice` request.
*/
export class CancelInvoiceRequest {
    /**
    * The version of the `invoice` to cancel. If you do not know the version, you can call  `GetInvoice](#endpoint-Invoices-GetInvoice) or [ListInvoices`.
    */
    'version': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CancelInvoiceRequest.attributeTypeMap;
    }
}

/**
* The response returned by the `CancelInvoice` request.
*/
export class CancelInvoiceResponse {
    /**
    * The canceled invoice.
    */
    'invoice'?: Invoice;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CancelInvoiceResponse.attributeTypeMap;
    }
}

/**
* Specifies idempotency key of a payment to cancel.
*/
export class CancelPaymentByIdempotencyKeyRequest {
    /**
    * `idempotency_key` identifying the payment to be canceled.
    */
    'idempotencyKey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CancelPaymentByIdempotencyKeyRequest.attributeTypeMap;
    }
}

/**
* Return value from the [CancelPaymentByIdempotencyKey](#endpoint-payments-cancelpaymentbyidempotencykey) endpoint. On success, `errors` will be empty.
*/
export class CancelPaymentByIdempotencyKeyResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CancelPaymentByIdempotencyKeyResponse.attributeTypeMap;
    }
}

/**
* Cancels (voids) a payment before it has been completed. Note: only payments created with `autocomplete` set to false can be canceled.
*/
export class CancelPaymentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CancelPaymentRequest.attributeTypeMap;
    }
}

/**
* Return value from the [CancelPayment](#endpoint-payments-cancelpayment) endpoint.
*/
export class CancelPaymentResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The successfully canceled `Payment` object.
    */
    'payment'?: Payment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }    ];

    static getAttributeTypeMap() {
        return CancelPaymentResponse.attributeTypeMap;
    }
}

/**
* Defines parameters in a  [CancelSubscription](#endpoint-subscriptions-cancelsubscription) endpoint request.
*/
export class CancelSubscriptionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CancelSubscriptionRequest.attributeTypeMap;
    }
}

/**
* Defines fields that are included in a  [CancelSubscription](#endpoint-subscriptions-cancelsubscription) response.
*/
export class CancelSubscriptionResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The canceled subscription.
    */
    'subscription'?: Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return CancelSubscriptionResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CancelTerminalCheckoutRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CancelTerminalCheckoutRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CancelTerminalCheckoutResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The updated `TerminalCheckout`
    */
    'checkout'?: TerminalCheckout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "TerminalCheckout"
        }    ];

    static getAttributeTypeMap() {
        return CancelTerminalCheckoutResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CaptureTransactionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CaptureTransactionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [CaptureTransaction](#endpoint-capturetransaction) endpoint.
*/
export class CaptureTransactionResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CaptureTransactionResponse.attributeTypeMap;
    }
}

/**
* Represents the payment details of a card to be used for payments. These details are determined by the `card_nonce` generated by `SqPaymentForm`.
*/
export class Card {
    /**
    * Unique ID for this card. Generated by Square.
    */
    'id'?: string;
    /**
    * The card's brand. See [CardBrand](#type-cardbrand) for possible values
    */
    'cardBrand'?: string;
    /**
    * The last 4 digits of the card number.
    */
    'last4'?: string;
    /**
    * The expiration month of the associated card as an integer between 1 and 12.
    */
    'expMonth'?: number;
    /**
    * The four-digit year of the card's expiration date.
    */
    'expYear'?: number;
    /**
    * The name of the cardholder.
    */
    'cardholderName'?: string;
    /**
    * The billing address for this card.
    */
    'billingAddress'?: Address;
    /**
    * __Not currently set.__ Intended as a Square-assigned identifier, based on the card number, to identify the card across multiple locations within a single application.
    */
    'fingerprint'?: string;
    /**
    * The type of the card. The Card object includes this field only in response to Payments API calls. See [CardType](#type-cardtype) for possible values
    */
    'cardType'?: string;
    /**
    * Indicates whether the Card is prepaid or not. The Card object includes this field only in response to Payments API calls. See [CardPrepaidType](#type-cardprepaidtype) for possible values
    */
    'prepaidType'?: string;
    /**
    * The first six digits of the card number, known as the Bank Identification Number (BIN). Only the Payments API returns this field.
    */
    'bin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "cardBrand",
            "baseName": "card_brand",
            "type": "string"
        },
        {
            "name": "last4",
            "baseName": "last_4",
            "type": "string"
        },
        {
            "name": "expMonth",
            "baseName": "exp_month",
            "type": "number"
        },
        {
            "name": "expYear",
            "baseName": "exp_year",
            "type": "number"
        },
        {
            "name": "cardholderName",
            "baseName": "cardholder_name",
            "type": "string"
        },
        {
            "name": "billingAddress",
            "baseName": "billing_address",
            "type": "Address"
        },
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "string"
        },
        {
            "name": "prepaidType",
            "baseName": "prepaid_type",
            "type": "string"
        },
        {
            "name": "bin",
            "baseName": "bin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Card.attributeTypeMap;
    }
}

/**
* Indicates a card's brand, such as `VISA` or `MASTERCARD`.
*/
export class CardBrand {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CardBrand.attributeTypeMap;
    }
}

/**
* Reflects the current status of a card payment.
*/
export class CardPaymentDetails {
    /**
    * The card payment's current state. It can be one of: `AUTHORIZED`, `CAPTURED`, `VOIDED`, `FAILED`.
    */
    'status'?: string;
    /**
    * The credit card's non-confidential details.
    */
    'card'?: Card;
    /**
    * The method used to enter the card's details for the payment.  Can be `KEYED`, `SWIPED`, `EMV`, `ON_FILE`, or `CONTACTLESS`.
    */
    'entryMethod'?: string;
    /**
    * Status code returned from the Card Verification Value (CVV) check. Can be `CVV_ACCEPTED`, `CVV_REJECTED`, `CVV_NOT_CHECKED`.
    */
    'cvvStatus'?: string;
    /**
    * Status code returned from the Address Verification System (AVS) check. Can be `AVS_ACCEPTED`, `AVS_REJECTED`, `AVS_NOT_CHECKED`.
    */
    'avsStatus'?: string;
    /**
    * Status code returned by the card issuer that describes the payment's authorization status.
    */
    'authResultCode'?: string;
    /**
    * For EMV payments, identifies the EMV application used for the payment.
    */
    'applicationIdentifier'?: string;
    /**
    * For EMV payments, the human-readable name of the EMV application used for the payment.
    */
    'applicationName'?: string;
    /**
    * For EMV payments, the cryptogram generated for the payment.
    */
    'applicationCryptogram'?: string;
    /**
    * For EMV payments, method used to verify the cardholder's identity.  Can be one of `PIN`, `SIGNATURE`, `PIN_AND_SIGNATURE`, `ON_DEVICE`, or `NONE`.
    */
    'verificationMethod'?: string;
    /**
    * For EMV payments, the results of the cardholder verification.  Can be one of `SUCCESS`, `FAILURE`, or `UNKNOWN`.
    */
    'verificationResults'?: string;
    /**
    * The statement description sent to the card networks.  Note: The actual statement description will vary and is likely to be truncated and appended with additional information on a per issuer basis.
    */
    'statementDescription'?: string;
    /**
    * Details about the device that took the payment.
    */
    'deviceDetails'?: DeviceDetails;
    /**
    * Whether or not the card is required to be physically present in order for the payment to be refunded.  If true, the card is required to be present.
    */
    'refundRequiresCardPresence'?: boolean;
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "entryMethod",
            "baseName": "entry_method",
            "type": "string"
        },
        {
            "name": "cvvStatus",
            "baseName": "cvv_status",
            "type": "string"
        },
        {
            "name": "avsStatus",
            "baseName": "avs_status",
            "type": "string"
        },
        {
            "name": "authResultCode",
            "baseName": "auth_result_code",
            "type": "string"
        },
        {
            "name": "applicationIdentifier",
            "baseName": "application_identifier",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "application_name",
            "type": "string"
        },
        {
            "name": "applicationCryptogram",
            "baseName": "application_cryptogram",
            "type": "string"
        },
        {
            "name": "verificationMethod",
            "baseName": "verification_method",
            "type": "string"
        },
        {
            "name": "verificationResults",
            "baseName": "verification_results",
            "type": "string"
        },
        {
            "name": "statementDescription",
            "baseName": "statement_description",
            "type": "string"
        },
        {
            "name": "deviceDetails",
            "baseName": "device_details",
            "type": "DeviceDetails"
        },
        {
            "name": "refundRequiresCardPresence",
            "baseName": "refund_requires_card_presence",
            "type": "boolean"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CardPaymentDetails.attributeTypeMap;
    }
}

/**
* Indicates a card's prepaid type, such as `NOT_PREPAID` or `PREPAID`.
*/
export class CardPrepaidType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CardPrepaidType.attributeTypeMap;
    }
}

/**
* 
*/
export class CardSquareProduct {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CardSquareProduct.attributeTypeMap;
    }
}

/**
* Indicates a card's type, such as `CREDIT` or `DEBIT`.
*/
export class CardType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CardType.attributeTypeMap;
    }
}

/**
* 
*/
export class CashDrawerDevice {
    /**
    * The device Square-issued ID
    */
    'id'?: string;
    /**
    * The device merchant-specified name.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CashDrawerDevice.attributeTypeMap;
    }
}

/**
* The types of events on a CashDrawerShift. Each event type represents an employee action on the actual cash drawer represented by a CashDrawerShift.
*/
export class CashDrawerEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CashDrawerEventType.attributeTypeMap;
    }
}

/**
* This model gives the details of a cash drawer shift. The cash_payment_money, cash_refund_money, cash_paid_in_money, and cash_paid_out_money fields are all computed by summing their respective event types.
*/
export class CashDrawerShift {
    /**
    * The shift unique ID.
    */
    'id'?: string;
    /**
    * The shift current state. See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
    */
    'state'?: string;
    /**
    * The time when the shift began, in ISO 8601 format.
    */
    'openedAt'?: string;
    /**
    * The time when the shift ended, in ISO 8601 format.
    */
    'endedAt'?: string;
    /**
    * The time when the shift was closed, in ISO 8601 format.
    */
    'closedAt'?: string;
    /**
    * The IDs of all employees that were logged into Square Point of Sale at any point while the cash drawer shift was open.
    */
    'employeeIds'?: Array<string>;
    /**
    * The ID of the employee that started the cash drawer shift.
    */
    'openingEmployeeId'?: string;
    /**
    * The ID of the employee that ended the cash drawer shift.
    */
    'endingEmployeeId'?: string;
    /**
    * The ID of the employee that closed the cash drawer shift by auditing the cash drawer contents.
    */
    'closingEmployeeId'?: string;
    /**
    * The free-form text description of a cash drawer by an employee.
    */
    'description'?: string;
    /**
    * The amount of money in the cash drawer at the start of the shift. The amount must be greater than or equal to zero.
    */
    'openedCashMoney'?: Money;
    /**
    * The amount of money added to the cash drawer from cash payments. This is computed by summing all events with the types CASH_TENDER_PAYMENT and CASH_TENDER_CANCELED_PAYMENT. The amount is always greater than or equal to zero.
    */
    'cashPaymentMoney'?: Money;
    /**
    * The amount of money removed from the cash drawer from cash refunds. It is computed by summing the events of type CASH_TENDER_REFUND. The amount is always greater than or equal to zero.
    */
    'cashRefundsMoney'?: Money;
    /**
    * The amount of money added to the cash drawer for reasons other than cash payments. It is computed by summing the events of type PAID_IN. The amount is always greater than or equal to zero.
    */
    'cashPaidInMoney'?: Money;
    /**
    * The amount of money removed from the cash drawer for reasons other than cash refunds. It is computed by summing the events of type PAID_OUT. The amount is always greater than or equal to zero.
    */
    'cashPaidOutMoney'?: Money;
    /**
    * The amount of money that should be in the cash drawer at the end of the shift, based on the shift's other money amounts. This can be negative if employees have not correctly recorded all the events on the cash drawer. cash_paid_out_money is a summation of amounts from cash_payment_money (zero or positive), cash_refunds_money (zero or negative), cash_paid_in_money (zero or positive), and cash_paid_out_money (zero or negative) event types.
    */
    'expectedCashMoney'?: Money;
    /**
    * The amount of money found in the cash drawer at the end of the shift by an auditing employee. The amount should be positive.
    */
    'closedCashMoney'?: Money;
    /**
    * The device running Square Point of Sale that was connected to the cash drawer.
    */
    'device'?: CashDrawerDevice;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "openedAt",
            "baseName": "opened_at",
            "type": "string"
        },
        {
            "name": "endedAt",
            "baseName": "ended_at",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "employeeIds",
            "baseName": "employee_ids",
            "type": "Array<string>"
        },
        {
            "name": "openingEmployeeId",
            "baseName": "opening_employee_id",
            "type": "string"
        },
        {
            "name": "endingEmployeeId",
            "baseName": "ending_employee_id",
            "type": "string"
        },
        {
            "name": "closingEmployeeId",
            "baseName": "closing_employee_id",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "openedCashMoney",
            "baseName": "opened_cash_money",
            "type": "Money"
        },
        {
            "name": "cashPaymentMoney",
            "baseName": "cash_payment_money",
            "type": "Money"
        },
        {
            "name": "cashRefundsMoney",
            "baseName": "cash_refunds_money",
            "type": "Money"
        },
        {
            "name": "cashPaidInMoney",
            "baseName": "cash_paid_in_money",
            "type": "Money"
        },
        {
            "name": "cashPaidOutMoney",
            "baseName": "cash_paid_out_money",
            "type": "Money"
        },
        {
            "name": "expectedCashMoney",
            "baseName": "expected_cash_money",
            "type": "Money"
        },
        {
            "name": "closedCashMoney",
            "baseName": "closed_cash_money",
            "type": "Money"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "CashDrawerDevice"
        }    ];

    static getAttributeTypeMap() {
        return CashDrawerShift.attributeTypeMap;
    }
}

/**
* 
*/
export class CashDrawerShiftEvent {
    /**
    * The unique ID of the event.
    */
    'id'?: string;
    /**
    * The ID of the employee that created the event.
    */
    'employeeId'?: string;
    /**
    * The type of cash drawer shift event. See [CashDrawerEventType](#type-cashdrawereventtype) for possible values
    */
    'eventType'?: string;
    /**
    * The amount of money that was added to or removed from the cash drawer in the event. The amount can be positive (for added money), negative (for removed money), or zero (for other tender type payments).
    */
    'eventMoney'?: Money;
    /**
    * The event time in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * An optional description of the event, entered by the employee that created the event.
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "eventType",
            "baseName": "event_type",
            "type": "string"
        },
        {
            "name": "eventMoney",
            "baseName": "event_money",
            "type": "Money"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CashDrawerShiftEvent.attributeTypeMap;
    }
}

/**
* The current state of a cash drawer shift.
*/
export class CashDrawerShiftState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CashDrawerShiftState.attributeTypeMap;
    }
}

/**
* The summary of a closed cash drawer shift. This model contains only the money counted to start a cash drawer shift, counted at the end of the shift, and the amount that should be in the drawer at shift end based on summing all cash drawer shift events.
*/
export class CashDrawerShiftSummary {
    /**
    * The shift unique ID.
    */
    'id'?: string;
    /**
    * The shift current state. See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
    */
    'state'?: string;
    /**
    * The shift start time in ISO 8601 format.
    */
    'openedAt'?: string;
    /**
    * The shift end time in ISO 8601 format.
    */
    'endedAt'?: string;
    /**
    * The shift close time in ISO 8601 format.
    */
    'closedAt'?: string;
    /**
    * An employee free-text description of a cash drawer shift.
    */
    'description'?: string;
    /**
    * The amount of money in the cash drawer at the start of the shift. This must be a positive amount.
    */
    'openedCashMoney'?: Money;
    /**
    * The amount of money that should be in the cash drawer at the end of the shift, based on the cash drawer events on the shift. The amount is correct if all shift employees accurately recorded their cash drawer shift events. Unrecorded events and events with the wrong amount result in an incorrect expected_cash_money amount that can be negative.
    */
    'expectedCashMoney'?: Money;
    /**
    * The amount of money found in the cash drawer at the end of the shift by an auditing employee. The amount must be greater than or equal to zero.
    */
    'closedCashMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "openedAt",
            "baseName": "opened_at",
            "type": "string"
        },
        {
            "name": "endedAt",
            "baseName": "ended_at",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "openedCashMoney",
            "baseName": "opened_cash_money",
            "type": "Money"
        },
        {
            "name": "expectedCashMoney",
            "baseName": "expected_cash_money",
            "type": "Money"
        },
        {
            "name": "closedCashMoney",
            "baseName": "closed_cash_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return CashDrawerShiftSummary.attributeTypeMap;
    }
}

/**
* A category to which a `CatalogItem` instance belongs.
*/
export class CatalogCategory {
    /**
    * The category name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCategory.attributeTypeMap;
    }
}

/**
* Contains information defining a custom attribute. Custom attributes are intended to store additional information about a catalog object or to associate a catalog object with an entity in another system. Do not use custom attributes to store any sensitive information (personally identifiable information, card details, etc.). [Read more about custom attributes](/catalog-api/add-custom-attributes)
*/
export class CatalogCustomAttributeDefinition {
    /**
    * The type of this custom attribute. Cannot be modified after creation. Required. See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
    */
    'type': string;
    /**
    *  The name of this definition for API and seller-facing UI purposes. The name must be unique within the (merchant, application_id) pair. Required. May not be empty and may not exceed 255 characters. Can be modified after creation.
    */
    'name': string;
    /**
    * Seller-oriented description of the meaning of this Custom Attribute, any constraints that the seller should observe, etc. May be displayed as a tooltip in Square UIs.
    */
    'description'?: string;
    /**
    * __Read only.__ Contains information about the application that created this custom attribute definition.
    */
    'sourceApplication'?: SourceApplication;
    /**
    * The set of Catalog Object Types that this Custom Attribute may be applied to. Currently, only `ITEM` and `ITEM_VARIATION` are allowed. At least one type must be included. See [CatalogObjectType](#type-catalogobjecttype) for possible values
    */
    'allowedObjectTypes': Array<string>;
    /**
    * The visibility of a custom attribute in seller-facing UIs (including Square Point of Sale applications and Square Dashboard). May be modified. See [CatalogCustomAttributeDefinitionSellerVisibility](#type-catalogcustomattributedefinitionsellervisibility) for possible values
    */
    'sellerVisibility'?: string;
    /**
    * The visibility of a custom attribute to applications other than the application that created the attribute. See [CatalogCustomAttributeDefinitionAppVisibility](#type-catalogcustomattributedefinitionappvisibility) for possible values
    */
    'appVisibility'?: string;
    /**
    * Optionally, populated when `type` = `STRING`, unset otherwise.
    */
    'stringConfig'?: CatalogCustomAttributeDefinitionStringConfig;
    /**
    * 
    */
    'numberConfig'?: CatalogCustomAttributeDefinitionNumberConfig;
    /**
    * Populated when `type` is set to `SELECTION`, unset otherwise.
    */
    'selectionConfig'?: CatalogCustomAttributeDefinitionSelectionConfig;
    /**
    * __Read-only.__ The number of custom attributes that reference this custom attribute definition. Set by the server in response to a ListCatalog request with `include_counts` set to `true`.  If the actual count is greater than 100, `custom_attribute_usage_count` will be set to `100`.
    */
    'customAttributeUsageCount'?: number;
    /**
    * The name of the desired custom attribute key that can be used to access the custom attribute value on catalog objects. Cannot be modified after the custom attribute definition has been created. Must be between 1 and 60 characters, and may only contain the characters [a-zA-Z0-9_-].
    */
    'key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sourceApplication",
            "baseName": "source_application",
            "type": "SourceApplication"
        },
        {
            "name": "allowedObjectTypes",
            "baseName": "allowed_object_types",
            "type": "Array<string>"
        },
        {
            "name": "sellerVisibility",
            "baseName": "seller_visibility",
            "type": "string"
        },
        {
            "name": "appVisibility",
            "baseName": "app_visibility",
            "type": "string"
        },
        {
            "name": "stringConfig",
            "baseName": "string_config",
            "type": "CatalogCustomAttributeDefinitionStringConfig"
        },
        {
            "name": "numberConfig",
            "baseName": "number_config",
            "type": "CatalogCustomAttributeDefinitionNumberConfig"
        },
        {
            "name": "selectionConfig",
            "baseName": "selection_config",
            "type": "CatalogCustomAttributeDefinitionSelectionConfig"
        },
        {
            "name": "customAttributeUsageCount",
            "baseName": "custom_attribute_usage_count",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinition.attributeTypeMap;
    }
}

/**
* Defines the visibility of a custom attribute to applications other than their creating application.
*/
export class CatalogCustomAttributeDefinitionAppVisibility {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionAppVisibility.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogCustomAttributeDefinitionNumberConfig {
    /**
    * An integer between 0 and 5 that represents the maximum number of positions allowed after the decimal in number custom attribute values For example:  - if the precision is 0, the quantity can be 1, 2, 3, etc. - if the precision is 1, the quantity can be 0.1, 0.2, etc. - if the precision is 2, the quantity can be 0.01, 0.12, etc.  Default: 5
    */
    'precision'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "precision",
            "baseName": "precision",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionNumberConfig.attributeTypeMap;
    }
}

/**
* Configuration associated with `SELECTION`-type custom attribute definitions.
*/
export class CatalogCustomAttributeDefinitionSelectionConfig {
    /**
    * The maximum number of selections that can be set. The maximum value for this attribute is 100. The default value is 1. The value can be modified, but changing the value will not affect existing custom attribute values on objects. Clients need to handle custom attributes with more selected values than allowed by this limit.
    */
    'maxAllowedSelections'?: number;
    /**
    * The set of valid `CatalogCustomAttributeSelections`. Up to a maximum of 100 selections can be defined. Can be modified.
    */
    'allowedSelections'?: Array<CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxAllowedSelections",
            "baseName": "max_allowed_selections",
            "type": "number"
        },
        {
            "name": "allowedSelections",
            "baseName": "allowed_selections",
            "type": "Array<CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionSelectionConfig.attributeTypeMap;
    }
}

/**
* A named selection for this `SELECTION`-type custom attribute definition.
*/
export class CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection {
    /**
    * Unique ID set by Square.
    */
    'uid'?: string;
    /**
    * Selection name, unique within `allowed_selections`.
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection.attributeTypeMap;
    }
}

/**
* Defines the visibility of a custom attribute to sellers in Square client applications, Square APIs or in Square UIs (including Square Point of Sale applications and Square Dashboard).
*/
export class CatalogCustomAttributeDefinitionSellerVisibility {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionSellerVisibility.attributeTypeMap;
    }
}

/**
* Configuration associated with Custom Attribute Definitions of type `STRING`.
*/
export class CatalogCustomAttributeDefinitionStringConfig {
    /**
    * If true, each Custom Attribute instance associated with this Custom Attribute Definition must have a unique value within the seller's catalog. For example, this may be used for a value like a SKU that should not be duplicated within a seller's catalog. May not be modified after the definition has been created.
    */
    'enforceUniqueness'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enforceUniqueness",
            "baseName": "enforce_uniqueness",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionStringConfig.attributeTypeMap;
    }
}

/**
* Defines the possible types for a custom attribute.
*/
export class CatalogCustomAttributeDefinitionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeDefinitionType.attributeTypeMap;
    }
}

/**
* An instance of a custom attribute. Custom attributes can be defined and added to `ITEM` and `ITEM_VARIATION` type catalog objects. [Read more about custom attributes](/catalog-api/add-custom-attributes).
*/
export class CatalogCustomAttributeValue {
    /**
    * The name of the custom attribute.
    */
    'name'?: string;
    /**
    * The string value of the custom attribute.  Populated if `type` = `STRING`.
    */
    'stringValue'?: string;
    /**
    * __Read-only.__ The id of the `CatalogCustomAttributeDefinition` this value belongs to.
    */
    'customAttributeDefinitionId'?: string;
    /**
    * __Read-only.__ A copy of type from the associated `CatalogCustomAttributeDefinition`. See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
    */
    'type'?: string;
    /**
    * Populated if `type` = `NUMBER`. Contains a string representation of a decimal number, using a `.` as the decimal separator.
    */
    'numberValue'?: string;
    /**
    * A `true` or `false` value. Populated if `type` = `BOOLEAN`.
    */
    'booleanValue'?: boolean;
    /**
    * One or more choices from `allowed_selections`. Populated if `type` = `SELECTION`.
    */
    'selectionUidValues'?: Array<string>;
    /**
    * __Read-only.__ A copy of key from the associated `CatalogCustomAttributeDefinition`.
    */
    'key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "stringValue",
            "baseName": "string_value",
            "type": "string"
        },
        {
            "name": "customAttributeDefinitionId",
            "baseName": "custom_attribute_definition_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "numberValue",
            "baseName": "number_value",
            "type": "string"
        },
        {
            "name": "booleanValue",
            "baseName": "boolean_value",
            "type": "boolean"
        },
        {
            "name": "selectionUidValues",
            "baseName": "selection_uid_values",
            "type": "Array<string>"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogCustomAttributeValue.attributeTypeMap;
    }
}

/**
* A discount applicable to items.
*/
export class CatalogDiscount {
    /**
    * The discount name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;
    /**
    * Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale. See [CatalogDiscountType](#type-catalogdiscounttype) for possible values
    */
    'discountType'?: string;
    /**
    * The percentage of the discount as a string representation of a decimal number, using a `.` as the decimal separator and without a `%` sign. A value of `7.5` corresponds to `7.5%`. Specify a percentage of `0` if `discount_type` is `VARIABLE_PERCENTAGE`.  Do not use this field for amount-based or variable discounts.
    */
    'percentage'?: string;
    /**
    * The amount of the discount. Specify an amount of `0` if `discount_type` is `VARIABLE_AMOUNT`.  Do not use this field for percentage-based or variable discounts.
    */
    'amountMoney'?: Money;
    /**
    * Indicates whether a mobile staff member needs to enter their PIN to apply the discount to a payment in the Square Point of Sale app.
    */
    'pinRequired'?: boolean;
    /**
    * The color of the discount display label in the Square Point of Sale app. This must be a valid hex color code.
    */
    'labelColor'?: string;
    /**
    * Indicates whether this discount should reduce the price used to calculate tax.  Most discounts should use `MODIFY_TAX_BASIS`. However, in some circumstances taxes must be calculated based on an item's price, ignoring a particular discount. For example, in many US jurisdictions, a manufacturer coupon or instant rebate reduces the price a customer pays but does not reduce the sale price used to calculate how much sales tax is due. In this case, the discount representing that manufacturer coupon should have `DO_NOT_MODIFY_TAX_BASIS` for this field.  If you are unsure whether you need to use this field, consult your tax professional. See [CatalogDiscountModifyTaxBasis](#type-catalogdiscountmodifytaxbasis) for possible values
    */
    'modifyTaxBasis'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "pinRequired",
            "baseName": "pin_required",
            "type": "boolean"
        },
        {
            "name": "labelColor",
            "baseName": "label_color",
            "type": "string"
        },
        {
            "name": "modifyTaxBasis",
            "baseName": "modify_tax_basis",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogDiscount.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogDiscountModifyTaxBasis {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogDiscountModifyTaxBasis.attributeTypeMap;
    }
}

/**
* How to apply a CatalogDiscount to a CatalogItem.
*/
export class CatalogDiscountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogDiscountType.attributeTypeMap;
    }
}

/**
* A mapping between a temporary client-supplied ID and a permanent server-generated ID.   When calling [UpsertCatalogObject](#endpoint-Catalog-UpsertCatalogObject) or  [BatchUpsertCatalogObjects](#endpoint-Catalog-BatchUpsertCatalogObjects) to   create a [CatalogObject](#type-CatalogObject) instance, you can supply  a temporary ID for the to-be-created object, especially when the object is to be referenced  elsewhere in the same request body. This temporary ID can be any string unique within  the call, but must be prefixed by \"#\".   After the request is sumbitted and the object created, a permanent server-generated ID is assigned  to the new object. The permanent ID is unique across the Square catalog.
*/
export class CatalogIdMapping {
    /**
    * The client-supplied temporary `#`-prefixed ID for a new `CatalogObject`.
    */
    'clientObjectId'?: string;
    /**
    * The permanent ID for the CatalogObject created by the server.
    */
    'objectId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientObjectId",
            "baseName": "client_object_id",
            "type": "string"
        },
        {
            "name": "objectId",
            "baseName": "object_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogIdMapping.attributeTypeMap;
    }
}

/**
* An image file to use in Square catalogs. It can be associated with catalog items, item variations, and categories.
*/
export class CatalogImage {
    /**
    * The internal name to identify this image in calls to the Square API.
    */
    'name'?: string;
    /**
    * The URL of this image, generated by Square after an image is uploaded using the `CreateCatalogImage` endpoint.
    */
    'url'?: string;
    /**
    * A caption that describes what is shown in the image. Displayed in the Square Online Store. This is a searchable attribute for use in applicable query filters.
    */
    'caption'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "caption",
            "baseName": "caption",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogImage.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogInfoRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogInfoRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogInfoResponse {
    /**
    * The set of errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * 
    */
    'limits'?: CatalogInfoResponseLimits;
    /**
    * Names and abbreviations for standard units.
    */
    'standardUnitDescriptionGroup'?: StandardUnitDescriptionGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "limits",
            "baseName": "limits",
            "type": "CatalogInfoResponseLimits"
        },
        {
            "name": "standardUnitDescriptionGroup",
            "baseName": "standard_unit_description_group",
            "type": "StandardUnitDescriptionGroup"
        }    ];

    static getAttributeTypeMap() {
        return CatalogInfoResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogInfoResponseLimits {
    /**
    * The maximum number of objects that may appear within a single batch in a `/v2/catalog/batch-upsert` request.
    */
    'batchUpsertMaxObjectsPerBatch'?: number;
    /**
    * The maximum number of objects that may appear across all batches in a `/v2/catalog/batch-upsert` request.
    */
    'batchUpsertMaxTotalObjects'?: number;
    /**
    * The maximum number of object IDs that may appear in a `/v2/catalog/batch-retrieve` request.
    */
    'batchRetrieveMaxObjectIds'?: number;
    /**
    * The maximum number of results that may be returned in a page of a `/v2/catalog/search` response.
    */
    'searchMaxPageLimit'?: number;
    /**
    * The maximum number of object IDs that may be included in a single `/v2/catalog/batch-delete` request.
    */
    'batchDeleteMaxObjectIds'?: number;
    /**
    * The maximum number of item IDs that may be included in a single `/v2/catalog/update-item-taxes` request.
    */
    'updateItemTaxesMaxItemIds'?: number;
    /**
    * The maximum number of tax IDs to be enabled that may be included in a single `/v2/catalog/update-item-taxes` request.
    */
    'updateItemTaxesMaxTaxesToEnable'?: number;
    /**
    * The maximum number of tax IDs to be disabled that may be included in a single `/v2/catalog/update-item-taxes` request.
    */
    'updateItemTaxesMaxTaxesToDisable'?: number;
    /**
    * The maximum number of item IDs that may be included in a single `/v2/catalog/update-item-modifier-lists` request.
    */
    'updateItemModifierListsMaxItemIds'?: number;
    /**
    * The maximum number of modifier list IDs to be enabled that may be included in a single `/v2/catalog/update-item-modifier-lists` request.
    */
    'updateItemModifierListsMaxModifierListsToEnable'?: number;
    /**
    * The maximum number of modifier list IDs to be disabled that may be included in a single `/v2/catalog/update-item-modifier-lists` request.
    */
    'updateItemModifierListsMaxModifierListsToDisable'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batchUpsertMaxObjectsPerBatch",
            "baseName": "batch_upsert_max_objects_per_batch",
            "type": "number"
        },
        {
            "name": "batchUpsertMaxTotalObjects",
            "baseName": "batch_upsert_max_total_objects",
            "type": "number"
        },
        {
            "name": "batchRetrieveMaxObjectIds",
            "baseName": "batch_retrieve_max_object_ids",
            "type": "number"
        },
        {
            "name": "searchMaxPageLimit",
            "baseName": "search_max_page_limit",
            "type": "number"
        },
        {
            "name": "batchDeleteMaxObjectIds",
            "baseName": "batch_delete_max_object_ids",
            "type": "number"
        },
        {
            "name": "updateItemTaxesMaxItemIds",
            "baseName": "update_item_taxes_max_item_ids",
            "type": "number"
        },
        {
            "name": "updateItemTaxesMaxTaxesToEnable",
            "baseName": "update_item_taxes_max_taxes_to_enable",
            "type": "number"
        },
        {
            "name": "updateItemTaxesMaxTaxesToDisable",
            "baseName": "update_item_taxes_max_taxes_to_disable",
            "type": "number"
        },
        {
            "name": "updateItemModifierListsMaxItemIds",
            "baseName": "update_item_modifier_lists_max_item_ids",
            "type": "number"
        },
        {
            "name": "updateItemModifierListsMaxModifierListsToEnable",
            "baseName": "update_item_modifier_lists_max_modifier_lists_to_enable",
            "type": "number"
        },
        {
            "name": "updateItemModifierListsMaxModifierListsToDisable",
            "baseName": "update_item_modifier_lists_max_modifier_lists_to_disable",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogInfoResponseLimits.attributeTypeMap;
    }
}

/**
* An [CatalogObject](#type-CatalogObject) instance of the `ITEM` type, also referred to as an item, in the catalog.
*/
export class CatalogItem {
    /**
    * The item's name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
    */
    'name'?: string;
    /**
    * The item's description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'description'?: string;
    /**
    * The text of the item's display label in the Square Point of Sale app. Only up to the first five characters of the string are used. This attribute is searchable, and its value length is of Unicode code points.
    */
    'abbreviation'?: string;
    /**
    * The color of the item's display label in the Square Point of Sale app. This must be a valid hex color code.
    */
    'labelColor'?: string;
    /**
    * If `true`, the item can be added to shipping orders from the merchant's online store.
    */
    'availableOnline'?: boolean;
    /**
    * If `true`, the item can be added to pickup orders from the merchant's online store.
    */
    'availableForPickup'?: boolean;
    /**
    * If `true`, the item can be added to electronically fulfilled orders from the merchant's online store.
    */
    'availableElectronically'?: boolean;
    /**
    * The ID of the item's category, if any.
    */
    'categoryId'?: string;
    /**
    * A set of IDs indicating the taxes enabled for this item. When updating an item, any taxes listed here will be added to the item. Taxes may also be added to or deleted from an item using `UpdateItemTaxes`.
    */
    'taxIds'?: Array<string>;
    /**
    * A set of `CatalogItemModifierListInfo` objects representing the modifier lists that apply to this item, along with the overrides and min and max limits that are specific to this item. Modifier lists may also be added to or deleted from an item using `UpdateItemModifierLists`.
    */
    'modifierListInfo'?: Array<CatalogItemModifierListInfo>;
    /**
    * A list of CatalogObjects containing the `CatalogItemVariation`s for this item.
    */
    'variations'?: Array<CatalogObject>;
    /**
    * The product type of the item. May not be changed once an item has been created.  Only items of product type `REGULAR` or `APPOINTMENTS_SERVICE` may be created by this API; items with other product types are read-only. See [CatalogItemProductType](#type-catalogitemproducttype) for possible values
    */
    'productType'?: string;
    /**
    * If `false`, the Square Point of Sale app will present the `CatalogItem`'s details screen immediately, allowing the merchant to choose `CatalogModifier`s before adding the item to the cart.  This is the default behavior.  If `true`, the Square Point of Sale app will immediately add the item to the cart with the pre-selected modifiers, and merchants can edit modifiers by drilling down onto the item's details.  Third-party clients are encouraged to implement similar behaviors.
    */
    'skipModifierScreen'?: boolean;
    /**
    * List of item options IDs for this item. Used to manage and group item variations in a specified order.  Maximum: 6 item options.
    */
    'itemOptions'?: Array<CatalogItemOptionForItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "abbreviation",
            "baseName": "abbreviation",
            "type": "string"
        },
        {
            "name": "labelColor",
            "baseName": "label_color",
            "type": "string"
        },
        {
            "name": "availableOnline",
            "baseName": "available_online",
            "type": "boolean"
        },
        {
            "name": "availableForPickup",
            "baseName": "available_for_pickup",
            "type": "boolean"
        },
        {
            "name": "availableElectronically",
            "baseName": "available_electronically",
            "type": "boolean"
        },
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "string"
        },
        {
            "name": "taxIds",
            "baseName": "tax_ids",
            "type": "Array<string>"
        },
        {
            "name": "modifierListInfo",
            "baseName": "modifier_list_info",
            "type": "Array<CatalogItemModifierListInfo>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "productType",
            "baseName": "product_type",
            "type": "string"
        },
        {
            "name": "skipModifierScreen",
            "baseName": "skip_modifier_screen",
            "type": "boolean"
        },
        {
            "name": "itemOptions",
            "baseName": "item_options",
            "type": "Array<CatalogItemOptionForItem>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItem.attributeTypeMap;
    }
}

/**
* Options to control the properties of a `CatalogModifierList` applied to a `CatalogItem` instance.
*/
export class CatalogItemModifierListInfo {
    /**
    * The ID of the `CatalogModifierList` controlled by this `CatalogModifierListInfo`.
    */
    'modifierListId': string;
    /**
    * A set of `CatalogModifierOverride` objects that override whether a given `CatalogModifier` is enabled by default.
    */
    'modifierOverrides'?: Array<CatalogModifierOverride>;
    /**
    * If 0 or larger, the smallest number of `CatalogModifier`s that must be selected from this `CatalogModifierList`.
    */
    'minSelectedModifiers'?: number;
    /**
    * If 0 or larger, the largest number of `CatalogModifier`s that can be selected from this `CatalogModifierList`.
    */
    'maxSelectedModifiers'?: number;
    /**
    * If `true`, enable this `CatalogModifierList`. The default value is `true`.
    */
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "modifierListId",
            "baseName": "modifier_list_id",
            "type": "string"
        },
        {
            "name": "modifierOverrides",
            "baseName": "modifier_overrides",
            "type": "Array<CatalogModifierOverride>"
        },
        {
            "name": "minSelectedModifiers",
            "baseName": "min_selected_modifiers",
            "type": "number"
        },
        {
            "name": "maxSelectedModifiers",
            "baseName": "max_selected_modifiers",
            "type": "number"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemModifierListInfo.attributeTypeMap;
    }
}

/**
* A group of variations for a `CatalogItem`.
*/
export class CatalogItemOption {
    /**
    * The item option's display name for the seller. Must be unique across all item options. This is a searchable attribute for use in applicable query filters.
    */
    'name'?: string;
    /**
    * The item option's display name for the customer. This is a searchable attribute for use in applicable query filters.
    */
    'displayName'?: string;
    /**
    * The item option's human-readable description. Displayed in the Square Point of Sale app for the seller and in the Online Store or on receipts for the buyer. This is a searchable attribute for use in applicable query filters.
    */
    'description'?: string;
    /**
    * If true, display colors for entries in `values` when present.
    */
    'showColors'?: boolean;
    /**
    * A list of CatalogObjects containing the `CatalogItemOptionValue`s for this item.
    */
    'values'?: Array<CatalogObject>;
    /**
    * The number of `CatalogItem`s currently associated with this item option. Present only if the `include_counts` was specified in the request. Any count over 100 will be returned as `100`.
    */
    'itemCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "showColors",
            "baseName": "show_colors",
            "type": "boolean"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "itemCount",
            "baseName": "item_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemOption.attributeTypeMap;
    }
}

/**
*  An option that can be assigned to an item. For example, a t-shirt item may offer a color option or a size option.
*/
export class CatalogItemOptionForItem {
    /**
    * The unique id of the item option, used to form the dimensions of the item option matrix in a specified order.
    */
    'itemOptionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemOptionId",
            "baseName": "item_option_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemOptionForItem.attributeTypeMap;
    }
}

/**
* An enumerated value that can link a `CatalogItemVariation` to an item option as one of its item option values.
*/
export class CatalogItemOptionValue {
    /**
    * Unique ID of the associated item option.
    */
    'itemOptionId'?: string;
    /**
    * Name of this item option value. This is a searchable attribute for use in applicable query filters.
    */
    'name'?: string;
    /**
    * A human-readable description for the option value. This is a searchable attribute for use in applicable query filters.
    */
    'description'?: string;
    /**
    * The HTML-supported hex color for the item option (e.g., \"#ff8d4e85\"). Only displayed if `show_colors` is enabled on the parent `ItemOption`. When left unset, `color` defaults to white (\"#ffffff\") when `show_colors` is enabled on the parent `ItemOption`.
    */
    'color'?: string;
    /**
    * Determines where this option value appears in a list of option values.
    */
    'ordinal'?: number;
    /**
    * The number of `CatalogItemVariation`s that currently use this item option value. Present only if `retrieve_counts` was specified on the request used to retrieve the parent item option of this value.
    */
    'itemVariationCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemOptionId",
            "baseName": "item_option_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "itemVariationCount",
            "baseName": "item_variation_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemOptionValue.attributeTypeMap;
    }
}

/**
* A `CatalogItemOptionValue` links an item variation to an item option as an item option value. For example, a t-shirt item may offer a color option and a size option. An item option value would represent each variation of t-shirt: For example, \"Color:Red, Size:Small\" or \"Color:Blue, Size:Medium\".
*/
export class CatalogItemOptionValueForItemVariation {
    /**
    * The unique id of an item option.
    */
    'itemOptionId'?: string;
    /**
    * The unique id of the selected value for the item option.
    */
    'itemOptionValueId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemOptionId",
            "baseName": "item_option_id",
            "type": "string"
        },
        {
            "name": "itemOptionValueId",
            "baseName": "item_option_value_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemOptionValueForItemVariation.attributeTypeMap;
    }
}

/**
* The type of a CatalogItem. Connect V2 only allows the creation of `REGULAR` or `APPOINTMENTS_SERVICE` items.
*/
export class CatalogItemProductType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogItemProductType.attributeTypeMap;
    }
}

/**
* An item variation (i.e., product) in the Catalog object model. Each item may have a maximum of 250 item variations.
*/
export class CatalogItemVariation {
    /**
    * The ID of the `CatalogItem` associated with this item variation.
    */
    'itemId'?: string;
    /**
    * The item variation's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;
    /**
    * The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
    */
    'sku'?: string;
    /**
    * The item variation's UPC, if any. This is a searchable attribute for use in applicable query filters. It is only accessible through the Square API, and not exposed in the Square Seller Dashboard, Square Point of Sale or Retail Point of Sale apps.
    */
    'upc'?: string;
    /**
    * The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal for each item variation within a parent `CatalogItem` is set according to the item variations's position. On reads, the value is not guaranteed to be sequential or unique.
    */
    'ordinal'?: number;
    /**
    * Indicates whether the item variation's price is fixed or determined at the time of sale. See [CatalogPricingType](#type-catalogpricingtype) for possible values
    */
    'pricingType'?: string;
    /**
    * The item variation's price, if fixed pricing is used.
    */
    'priceMoney'?: Money;
    /**
    * Per-location price and inventory overrides.
    */
    'locationOverrides'?: Array<ItemVariationLocationOverrides>;
    /**
    * If `true`, inventory tracking is active for the variation.
    */
    'trackInventory'?: boolean;
    /**
    * Indicates whether the item variation displays an alert when its inventory quantity is less than or equal to its `inventory_alert_threshold`. See [InventoryAlertType](#type-inventoryalerttype) for possible values
    */
    'inventoryAlertType'?: string;
    /**
    * If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type` is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.  This value is always an integer.
    */
    'inventoryAlertThreshold'?: number;
    /**
    * Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
    */
    'userData'?: string;
    /**
    * If the `CatalogItem` that owns this item variation is of type `APPOINTMENTS_SERVICE`, then this is the duration of the service in milliseconds. For example, a 30 minute appointment would have the value `1800000`, which is equal to 30 (minutes) * 60 (seconds per minute) * 1000 (milliseconds per second).
    */
    'serviceDuration'?: number;
    /**
    * List of item option values associated with this item variation. Listed in the same order as the item options of the parent item.
    */
    'itemOptionValues'?: Array<CatalogItemOptionValueForItemVariation>;
    /**
    * ID of the â€˜CatalogMeasurementUnitâ€™ that is used to measure the quantity sold of this item variation. If left unset, the item will be sold in whole quantities.
    */
    'measurementUnitId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "upc",
            "baseName": "upc",
            "type": "string"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "pricingType",
            "baseName": "pricing_type",
            "type": "string"
        },
        {
            "name": "priceMoney",
            "baseName": "price_money",
            "type": "Money"
        },
        {
            "name": "locationOverrides",
            "baseName": "location_overrides",
            "type": "Array<ItemVariationLocationOverrides>"
        },
        {
            "name": "trackInventory",
            "baseName": "track_inventory",
            "type": "boolean"
        },
        {
            "name": "inventoryAlertType",
            "baseName": "inventory_alert_type",
            "type": "string"
        },
        {
            "name": "inventoryAlertThreshold",
            "baseName": "inventory_alert_threshold",
            "type": "number"
        },
        {
            "name": "userData",
            "baseName": "user_data",
            "type": "string"
        },
        {
            "name": "serviceDuration",
            "baseName": "service_duration",
            "type": "number"
        },
        {
            "name": "itemOptionValues",
            "baseName": "item_option_values",
            "type": "Array<CatalogItemOptionValueForItemVariation>"
        },
        {
            "name": "measurementUnitId",
            "baseName": "measurement_unit_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemVariation.attributeTypeMap;
    }
}

/**
* Represents the unit used to measure a `CatalogItemVariation` and specifies the precision for decimal quantities.
*/
export class CatalogMeasurementUnit {
    /**
    * Indicates the unit used to measure the quantity of a catalog item variation.
    */
    'measurementUnit'?: MeasurementUnit;
    /**
    * An integer between 0 and 5 that represents the maximum number of positions allowed after the decimal in quantities measured with this unit. For example:  - if the precision is 0, the quantity can be 1, 2, 3, etc. - if the precision is 1, the quantity can be 0.1, 0.2, etc. - if the precision is 2, the quantity can be 0.01, 0.12, etc.  Default: 3
    */
    'precision'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "measurementUnit",
            "baseName": "measurement_unit",
            "type": "MeasurementUnit"
        },
        {
            "name": "precision",
            "baseName": "precision",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogMeasurementUnit.attributeTypeMap;
    }
}

/**
* A modifier applicable to items at the time of sale.
*/
export class CatalogModifier {
    /**
    * The modifier name.  This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;
    /**
    * The modifier price.
    */
    'priceMoney'?: Money;
    /**
    * Determines where this `CatalogModifier` appears in the `CatalogModifierList`.
    */
    'ordinal'?: number;
    /**
    * The ID of the `CatalogModifierList` associated with this modifier.
    */
    'modifierListId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priceMoney",
            "baseName": "price_money",
            "type": "Money"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "modifierListId",
            "baseName": "modifier_list_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogModifier.attributeTypeMap;
    }
}

/**
* A list of modifiers applicable to items at the time of sale.  For example, a \"Condiments\" modifier list applicable to a \"Hot Dog\" item may contain \"Ketchup\", \"Mustard\", and \"Relish\" modifiers. Use the `selection_type` field to specify whether or not multiple selections from the modifier list are allowed.
*/
export class CatalogModifierList {
    /**
    * The name for the `CatalogModifierList` instance. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;
    /**
    * Determines where this modifier list appears in a list of `CatalogModifierList` values.
    */
    'ordinal'?: number;
    /**
    * Indicates whether multiple options from the modifier list can be applied to a single `CatalogItem`. See [CatalogModifierListSelectionType](#type-catalogmodifierlistselectiontype) for possible values
    */
    'selectionType'?: string;
    /**
    * The options included in the `CatalogModifierList`. You must include at least one `CatalogModifier`. Each CatalogObject must have type `MODIFIER` and contain `CatalogModifier` data.
    */
    'modifiers'?: Array<CatalogObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "selectionType",
            "baseName": "selection_type",
            "type": "string"
        },
        {
            "name": "modifiers",
            "baseName": "modifiers",
            "type": "Array<CatalogObject>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogModifierList.attributeTypeMap;
    }
}

/**
* Indicates whether a CatalogModifierList supports multiple selections.
*/
export class CatalogModifierListSelectionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogModifierListSelectionType.attributeTypeMap;
    }
}

/**
* Options to control how to override the default behavior of the specified modifier.
*/
export class CatalogModifierOverride {
    /**
    * The ID of the `CatalogModifier` whose default behavior is being overridden.
    */
    'modifierId': string;
    /**
    * If `true`, this `CatalogModifier` should be selected by default for this `CatalogItem`.
    */
    'onByDefault'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "modifierId",
            "baseName": "modifier_id",
            "type": "string"
        },
        {
            "name": "onByDefault",
            "baseName": "on_by_default",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogModifierOverride.attributeTypeMap;
    }
}

/**
* The wrapper object for the Catalog entries of a given object type.   The type of a particular `CatalogObject` is determined by the value of the `type` attribute and only the corresponding data attribute can be set on the `CatalogObject` instance. For example, the following list shows some instances of `CatalogObject` of a given `type` and their corresponding data atrribute that can be set: - For a `CatalogObject` of the `ITEM` type, set the `item_data` attribute to yield the `CatalogItem` object.  - For a `CatalogObject` of the `ITEM_VARIATION` type, set the `item_variation_data` attribute to yield the `CatalogItemVariation` object. - For a `CatalogObject` of the `MODIFIER` type, set the `modifier_data` attribute to yield the `CatalogModifier` object. - For a `CatalogObject` of the `MODIFIER_LIST` type, set the `modifier_list_data` attribute to yield the `CatalogModifierList` object. - For a `CatalogObject` of the `CATEGORY` type, set the `category_data` attribute to yield the `CatalogCategory` object. - For a `CatalogObject` of the `DISCOUNT` type, set the `discount_data` attribute to yield the `CatalogDiscount` object. - For a `CatalogObject` of the `TAX` type, set the `tax_data` attribute to yield the `CatalogTax` object. - For a `CatalogObject` of the `IMAGE` type, set the `image_data` attribute to yield the `CatalogImageData`  object. - For a `CatalogObject` of the `QUICK_AMOUNTS_SETTINGS` type, set the `quick_amounts_settings_data` attribute to yield the `CatalogQuickAmountsSettings` object. - For a `CatalogObject` of the `PRICING_RULE` type, set the `pricing_rule_data` attribute to yield the `CatalogPricingRule` object. - For a `CatalogObject` of the `TIME_PERIOD` type, set the `time_period_data` attribute to yield the `CatalogTimePeriod` object. - For a `CatalogObject` of the `PRODUCT_SET` type, set the `product_set_data` attribute to yield the `CatalogProductSet`  object. - For a `CatalogObject` of the `SUBSCRIPTION_PLAN` type, set the `subscription_plan_data` attribute to yield the `CatalogSubscriptionPlan` object.   For a more detailed discussion of the Catalog data model, please see the [Design a Catalog](/catalog-api/design-a-catalog) guide.
*/
export class CatalogObject {
    /**
    * The type of this object. Each object type has expected properties expressed in a structured format within its corresponding `*_data` field below. See [CatalogObjectType](#type-catalogobjecttype) for possible values
    */
    'type': string;
    /**
    * An identifier to reference this object in the catalog. When a new `CatalogObject` is inserted, the client should set the id to a temporary identifier starting with a \"`#`\" character. Other objects being inserted or updated within the same request may use this identifier to refer to the new object.  When the server receives the new object, it will supply a unique identifier that replaces the temporary identifier for all future references.
    */
    'id': string;
    /**
    * Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `\"2016-08-15T23:59:33.123Z\"` would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
    */
    'updatedAt'?: string;
    /**
    * The version of the object. When updating an object, the version supplied must match the version in the database, otherwise the write will be rejected as conflicting.
    */
    'version'?: number;
    /**
    * If `true`, the object has been deleted from the database. Must be `false` for new objects being inserted. When deleted, the `updated_at` field will equal the deletion time.
    */
    'isDeleted'?: boolean;
    /**
    * A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair  is a `CatalogCustomAttributeValue` object. The key is the `key` attribute  value defined in the associated `CatalogCustomAttributeDefinition`  object defined by the application making the request.   If the `CatalogCustomAttributeDefinition` object is  defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by  the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of  \"cocoa_brand\" and the defining application ID is \"abcd1234\", the key in the map is \"abcd1234:cocoa_brand\" if the application making the request is different from the application defining the custom attribute definition.  Otherwise, the key used in the map is simply \"cocoa-brand\".  Application-defined custom attributes that are set at a global (location-independent) level. Custom attribute values are intended to store additional information about a catalog object or associations with an entity in another system. Do not use custom attributes to store any sensitive information (personally identifiable information, card details, etc.).
    */
    'customAttributeValues'?: { [key: string]: CatalogCustomAttributeValue; };
    /**
    * The Connect v1 IDs for this object at each location where it is present, where they differ from the object's Connect V2 ID. The field will only be present for objects that have been created or modified by legacy APIs.
    */
    'catalogV1Ids'?: Array<CatalogV1Id>;
    /**
    * If `true`, this object is present at all locations (including future locations), except where specified in the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations), except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
    */
    'presentAtAllLocations'?: boolean;
    /**
    * A list of locations where the object is present, even if `present_at_all_locations` is `false`.
    */
    'presentAtLocationIds'?: Array<string>;
    /**
    * A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
    */
    'absentAtLocationIds'?: Array<string>;
    /**
    * Identifies the `CatalogImage` attached to this `CatalogObject`.
    */
    'imageId'?: string;
    /**
    * Structured data for a `CatalogItem`, set for CatalogObjects of type `ITEM`.
    */
    'itemData'?: CatalogItem;
    /**
    * Structured data for a `CatalogCategory`, set for CatalogObjects of type `CATEGORY`.
    */
    'categoryData'?: CatalogCategory;
    /**
    * Structured data for a `CatalogItemVariation`, set for CatalogObjects of type `ITEM_VARIATION`.
    */
    'itemVariationData'?: CatalogItemVariation;
    /**
    * Structured data for a `CatalogTax`, set for CatalogObjects of type `TAX`.
    */
    'taxData'?: CatalogTax;
    /**
    * Structured data for a `CatalogDiscount`, set for CatalogObjects of type `DISCOUNT`.
    */
    'discountData'?: CatalogDiscount;
    /**
    * Structured data for a `CatalogModifierList`, set for CatalogObjects of type `MODIFIER_LIST`.
    */
    'modifierListData'?: CatalogModifierList;
    /**
    * Structured data for a `CatalogModifier`, set for CatalogObjects of type `MODIFIER`.
    */
    'modifierData'?: CatalogModifier;
    /**
    * Structured data for a `CatalogTimePeriod`, set for CatalogObjects of type `TIME_PERIOD`.
    */
    'timePeriodData'?: CatalogTimePeriod;
    /**
    * Structured data for a `CatalogProductSet`, set for CatalogObjects of type `PRODUCT_SET`.
    */
    'productSetData'?: CatalogProductSet;
    /**
    * Structured data for a `CatalogPricingRule`, set for CatalogObjects of type `PRICING_RULE`. A `CatalogPricingRule` object often works with a `CatalogProductSet` object or a `CatalogTimePeriod` object.
    */
    'pricingRuleData'?: CatalogPricingRule;
    /**
    * Structured data for a `CatalogImage`, set for CatalogObjects of type `IMAGE`.
    */
    'imageData'?: CatalogImage;
    /**
    * Structured data for a `CatalogMeasurementUnit`, set for CatalogObjects of type `MEASUREMENT_UNIT`.
    */
    'measurementUnitData'?: CatalogMeasurementUnit;
    /**
    * Structured data for a `CatalogSubscriptionPlan`, set for CatalogObjects of type `SUBSCRIPTION_PLAN`.
    */
    'subscriptionPlanData'?: CatalogSubscriptionPlan;
    /**
    * Structured data for a `CatalogItemOption`, set for CatalogObjects of type `ITEM_OPTION`.
    */
    'itemOptionData'?: CatalogItemOption;
    /**
    * Structured data for a `CatalogItemOptionValue`, set for CatalogObjects of type `ITEM_OPTION_VAL`.
    */
    'itemOptionValueData'?: CatalogItemOptionValue;
    /**
    * Structured data for a `CatalogCustomAttributeDefinition`, set for CatalogObjects of type `CUSTOM_ATTRIBUTE_DEFINITION`.
    */
    'customAttributeDefinitionData'?: CatalogCustomAttributeDefinition;
    /**
    * Structured data for a `CatalogQuickAmountsSettings`, set for CatalogObjects of type `QUICK_AMOUNTS_SETTINGS`.
    */
    'quickAmountsSettingsData'?: CatalogQuickAmountsSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "isDeleted",
            "baseName": "is_deleted",
            "type": "boolean"
        },
        {
            "name": "customAttributeValues",
            "baseName": "custom_attribute_values",
            "type": "{ [key: string]: CatalogCustomAttributeValue; }"
        },
        {
            "name": "catalogV1Ids",
            "baseName": "catalog_v1_ids",
            "type": "Array<CatalogV1Id>"
        },
        {
            "name": "presentAtAllLocations",
            "baseName": "present_at_all_locations",
            "type": "boolean"
        },
        {
            "name": "presentAtLocationIds",
            "baseName": "present_at_location_ids",
            "type": "Array<string>"
        },
        {
            "name": "absentAtLocationIds",
            "baseName": "absent_at_location_ids",
            "type": "Array<string>"
        },
        {
            "name": "imageId",
            "baseName": "image_id",
            "type": "string"
        },
        {
            "name": "itemData",
            "baseName": "item_data",
            "type": "CatalogItem"
        },
        {
            "name": "categoryData",
            "baseName": "category_data",
            "type": "CatalogCategory"
        },
        {
            "name": "itemVariationData",
            "baseName": "item_variation_data",
            "type": "CatalogItemVariation"
        },
        {
            "name": "taxData",
            "baseName": "tax_data",
            "type": "CatalogTax"
        },
        {
            "name": "discountData",
            "baseName": "discount_data",
            "type": "CatalogDiscount"
        },
        {
            "name": "modifierListData",
            "baseName": "modifier_list_data",
            "type": "CatalogModifierList"
        },
        {
            "name": "modifierData",
            "baseName": "modifier_data",
            "type": "CatalogModifier"
        },
        {
            "name": "timePeriodData",
            "baseName": "time_period_data",
            "type": "CatalogTimePeriod"
        },
        {
            "name": "productSetData",
            "baseName": "product_set_data",
            "type": "CatalogProductSet"
        },
        {
            "name": "pricingRuleData",
            "baseName": "pricing_rule_data",
            "type": "CatalogPricingRule"
        },
        {
            "name": "imageData",
            "baseName": "image_data",
            "type": "CatalogImage"
        },
        {
            "name": "measurementUnitData",
            "baseName": "measurement_unit_data",
            "type": "CatalogMeasurementUnit"
        },
        {
            "name": "subscriptionPlanData",
            "baseName": "subscription_plan_data",
            "type": "CatalogSubscriptionPlan"
        },
        {
            "name": "itemOptionData",
            "baseName": "item_option_data",
            "type": "CatalogItemOption"
        },
        {
            "name": "itemOptionValueData",
            "baseName": "item_option_value_data",
            "type": "CatalogItemOptionValue"
        },
        {
            "name": "customAttributeDefinitionData",
            "baseName": "custom_attribute_definition_data",
            "type": "CatalogCustomAttributeDefinition"
        },
        {
            "name": "quickAmountsSettingsData",
            "baseName": "quick_amounts_settings_data",
            "type": "CatalogQuickAmountsSettings"
        }    ];

    static getAttributeTypeMap() {
        return CatalogObject.attributeTypeMap;
    }
}

/**
* A batch of catalog objects.
*/
export class CatalogObjectBatch {
    /**
    * A list of CatalogObjects belonging to this batch.
    */
    'objects': Array<CatalogObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "objects",
            "baseName": "objects",
            "type": "Array<CatalogObject>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogObjectBatch.attributeTypeMap;
    }
}

/**
* Possible types of CatalogObjects returned from the Catalog, each containing type-specific properties in the `*_data` field corresponding to the object type.
*/
export class CatalogObjectType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogObjectType.attributeTypeMap;
    }
}

/**
* Defines how discounts are automatically applied to a set of items that match the pricing rule  during the active time period.
*/
export class CatalogPricingRule {
    /**
    * User-defined name for the pricing rule. For example, \"Buy one get one free\" or \"10% off\".
    */
    'name'?: string;
    /**
    * A list of unique IDs for the catalog time periods when this pricing rule is in effect. If left unset, the pricing rule is always in effect.
    */
    'timePeriodIds'?: Array<string>;
    /**
    * Unique ID for the `CatalogDiscount` to take off the price of all matched items.
    */
    'discountId'?: string;
    /**
    * Unique ID for the `CatalogProductSet` that will be matched by this rule. A match rule matches within the entire cart. A match rule can match multiple times in the cart. If no `ProductSet` is present, the rule will match all products.
    */
    'matchProductsId'?: string;
    /**
    * __Deprecated__: Please use the `exclude_products_id` field to apply an exclude set instead. Exclude sets allow better control over quantity ranges and offer more flexibility for which matched items receive a discount.  `CatalogProductSet` to apply the pricing to. An apply rule matches within the subset of the cart that fits the match rules (the match set). An apply rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
    */
    'applyProductsId'?: string;
    /**
    * `CatalogProductSet` to exclude from the pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
    */
    'excludeProductsId'?: string;
    /**
    * Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
    */
    'validFromDate'?: string;
    /**
    * Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
    */
    'validFromLocalTime'?: string;
    /**
    * Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD).
    */
    'validUntilDate'?: string;
    /**
    * Represents the local time the pricing rule should be valid until. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
    */
    'validUntilLocalTime'?: string;
    /**
    * If an `exclude_products_id` was given, controls which subset of matched products is excluded from any discounts.  Default value: `LEAST_EXPENSIVE` See [ExcludeStrategy](#type-excludestrategy) for possible values
    */
    'excludeStrategy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriodIds",
            "baseName": "time_period_ids",
            "type": "Array<string>"
        },
        {
            "name": "discountId",
            "baseName": "discount_id",
            "type": "string"
        },
        {
            "name": "matchProductsId",
            "baseName": "match_products_id",
            "type": "string"
        },
        {
            "name": "applyProductsId",
            "baseName": "apply_products_id",
            "type": "string"
        },
        {
            "name": "excludeProductsId",
            "baseName": "exclude_products_id",
            "type": "string"
        },
        {
            "name": "validFromDate",
            "baseName": "valid_from_date",
            "type": "string"
        },
        {
            "name": "validFromLocalTime",
            "baseName": "valid_from_local_time",
            "type": "string"
        },
        {
            "name": "validUntilDate",
            "baseName": "valid_until_date",
            "type": "string"
        },
        {
            "name": "validUntilLocalTime",
            "baseName": "valid_until_local_time",
            "type": "string"
        },
        {
            "name": "excludeStrategy",
            "baseName": "exclude_strategy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogPricingRule.attributeTypeMap;
    }
}

/**
* Indicates whether the price of a CatalogItemVariation should be entered manually at the time of sale.
*/
export class CatalogPricingType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogPricingType.attributeTypeMap;
    }
}

/**
* Represents a collection of catalog objects for the purpose of applying a `PricingRule`. Including a catalog object will include all of its subtypes. For example, including a category in a product set will include all of its items and associated item variations in the product set. Including an item in a product set will also include its item variations.
*/
export class CatalogProductSet {
    /**
    * User-defined name for the product set. For example, \"Clearance Items\" or \"Winter Sale Items\".
    */
    'name'?: string;
    /**
    *  Unique IDs for any `CatalogObject` included in this product set. Any number of these catalog objects can be in an order for a pricing rule to apply.  This can be used with `product_ids_all` in a parent `CatalogProductSet` to match groups of products for a bulk discount, such as a discount for an entree and side combo.  Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.  Max: 500 catalog object IDs.
    */
    'productIdsAny'?: Array<string>;
    /**
    * Unique IDs for any `CatalogObject` included in this product set. All objects in this set must be included in an order for a pricing rule to apply.  Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.  Max: 500 catalog object IDs.
    */
    'productIdsAll'?: Array<string>;
    /**
    * If set, there must be exactly this many items from `products_any` or `products_all` in the cart for the discount to apply.  Cannot be combined with either `quantity_min` or `quantity_max`.
    */
    'quantityExact'?: number;
    /**
    * If set, there must be at least this many items from `products_any` or `products_all` in a cart for the discount to apply. See `quantity_exact`. Defaults to 0 if `quantity_exact`, `quantity_min` and `quantity_max` are all unspecified.
    */
    'quantityMin'?: number;
    /**
    * If set, the pricing rule will apply to a maximum of this many items from `products_any` or `products_all`.
    */
    'quantityMax'?: number;
    /**
    * If set to `true`, the product set will include every item in the catalog.  Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
    */
    'allProducts'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "productIdsAny",
            "baseName": "product_ids_any",
            "type": "Array<string>"
        },
        {
            "name": "productIdsAll",
            "baseName": "product_ids_all",
            "type": "Array<string>"
        },
        {
            "name": "quantityExact",
            "baseName": "quantity_exact",
            "type": "number"
        },
        {
            "name": "quantityMin",
            "baseName": "quantity_min",
            "type": "number"
        },
        {
            "name": "quantityMax",
            "baseName": "quantity_max",
            "type": "number"
        },
        {
            "name": "allProducts",
            "baseName": "all_products",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogProductSet.attributeTypeMap;
    }
}

/**
* A query composed of one or more different types of filters to narrow the scope of targeted objects when calling the `SearchCatalogObjects` endpoint.  Although a query can have multiple filters, only one query is allowed per call to [SearchCatalogObjects](#endpoint-Catalog-SearchCatalogObjects).  When a query filter is based on an attribute, the attribute must be searchable.  Searchable attributes are listed as follows, along their parent types that can be searched for with applicable query filters.   Searchable attribute and objects queryable by searchable attributes **  - `name`:  `CatalogItem`, `CatalogItemVariation`, `CatelogCatogry`, `CatalogTax`, `CatalogDiscount`, `CatalogModifier`, 'CatalogModifierList`, `CatalogItemOption`, `CatalogItemOptionValue`  - `description`: `CatalogItem`, `CatalogItemOptionValue`  - `abbreviation`: `CatalogItem`  - `upc`: `CatalogItemVariation`  - `sku`: `CatalogItemVariation`  - `caption`: `CatalogImage`  - `display_name`: `CatalogItemOption`   For example, to search for [CatalogItem](#type-CatalogItem) objects by searchable attributes, you can use  the `\"name\"`, `\"description\"`, or `\"abbreviation\"` attribute in an applicable query filter.
*/
export class CatalogQuery {
    /**
    * A query expression to sort returned query result by the given attribute.
    */
    'sortedAttributeQuery'?: CatalogQuerySortedAttribute;
    /**
    * An exact query expression to return objects with attribute name and value   matching the specified attribute name and value exactly. Value matching is case insensitive.
    */
    'exactQuery'?: CatalogQueryExact;
    /**
    * A prefix query expression to return objects with attribute values  that have a prefix matching the specified string value. Value maching is case insensitive.
    */
    'prefixQuery'?: CatalogQueryPrefix;
    /**
    * A range query expression to return objects with numberic values  that lie in the specified range.
    */
    'rangeQuery'?: CatalogQueryRange;
    /**
    * A text query expression to return objectd whose searchable attributes contain all of the given keywords, irrespective of their order. For example, if a `CatalogItem` contains custom attribute values of  `{\"name\": \"t-shirt\"}` and `{\"description\": \"Small, Purple\"}`, the query filter of `{\"keywords\": [\"shirt\", \"sma\", \"purp\"]}` returns this item.
    */
    'textQuery'?: CatalogQueryText;
    /**
    * A query expression to return items that have any of the specified taxes (as identified by the corresponding `CatalogTax` object IDs) enabled.
    */
    'itemsForTaxQuery'?: CatalogQueryItemsForTax;
    /**
    * A query expression to return items that have any of the given modifier list (as identifieid by the coresponding `CatalogModifierList`s IDs) enabled.
    */
    'itemsForModifierListQuery'?: CatalogQueryItemsForModifierList;
    /**
    * A query expression to return items that contains the specified item options (as identified the corresponding `CatalogItemOption` IDs).
    */
    'itemsForItemOptionsQuery'?: CatalogQueryItemsForItemOptions;
    /**
    * A query expression to return item variations (of the `CatalogItemVariation` that  contain all of the specified `CatalogItemOption` IDs.
    */
    'itemVariationsForItemOptionValuesQuery'?: CatalogQueryItemVariationsForItemOptionValues;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sortedAttributeQuery",
            "baseName": "sorted_attribute_query",
            "type": "CatalogQuerySortedAttribute"
        },
        {
            "name": "exactQuery",
            "baseName": "exact_query",
            "type": "CatalogQueryExact"
        },
        {
            "name": "prefixQuery",
            "baseName": "prefix_query",
            "type": "CatalogQueryPrefix"
        },
        {
            "name": "rangeQuery",
            "baseName": "range_query",
            "type": "CatalogQueryRange"
        },
        {
            "name": "textQuery",
            "baseName": "text_query",
            "type": "CatalogQueryText"
        },
        {
            "name": "itemsForTaxQuery",
            "baseName": "items_for_tax_query",
            "type": "CatalogQueryItemsForTax"
        },
        {
            "name": "itemsForModifierListQuery",
            "baseName": "items_for_modifier_list_query",
            "type": "CatalogQueryItemsForModifierList"
        },
        {
            "name": "itemsForItemOptionsQuery",
            "baseName": "items_for_item_options_query",
            "type": "CatalogQueryItemsForItemOptions"
        },
        {
            "name": "itemVariationsForItemOptionValuesQuery",
            "baseName": "item_variations_for_item_option_values_query",
            "type": "CatalogQueryItemVariationsForItemOptionValues"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQuery.attributeTypeMap;
    }
}

/**
* The query filter to return the serch result by exact match of the specified attribute name and value.
*/
export class CatalogQueryExact {
    /**
    * The name of the attribute to be searched. Matching of the attribute name is exact.
    */
    'attributeName': string;
    /**
    * The desired value of the search attribute. Matching of the attribute value is case insensitive and can be partial.  For example, if a specified value of \"sma\", objects with the named attribute value of \"Small\", \"small\" are both matched.
    */
    'attributeValue': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeName",
            "baseName": "attribute_name",
            "type": "string"
        },
        {
            "name": "attributeValue",
            "baseName": "attribute_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryExact.attributeTypeMap;
    }
}

/**
* The query filter to return the item variations containing the specified item option value IDs.
*/
export class CatalogQueryItemVariationsForItemOptionValues {
    /**
    * A set of `CatalogItemOptionValue` IDs to be used to find associated `CatalogItemVariation`s. All ItemVariations that contain all of the given Item Option Values (in any order) will be returned.
    */
    'itemOptionValueIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemOptionValueIds",
            "baseName": "item_option_value_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryItemVariationsForItemOptionValues.attributeTypeMap;
    }
}

/**
* The query filter to return the items containing the specified item option IDs.
*/
export class CatalogQueryItemsForItemOptions {
    /**
    * A set of `CatalogItemOption` IDs to be used to find associated `CatalogItem`s. All Items that contain all of the given Item Options (in any order) will be returned.
    */
    'itemOptionIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemOptionIds",
            "baseName": "item_option_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryItemsForItemOptions.attributeTypeMap;
    }
}

/**
* The query filter to return the items containing the specified modifier list IDs.
*/
export class CatalogQueryItemsForModifierList {
    /**
    * A set of `CatalogModifierList` IDs to be used to find associated `CatalogItem`s.
    */
    'modifierListIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "modifierListIds",
            "baseName": "modifier_list_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryItemsForModifierList.attributeTypeMap;
    }
}

/**
* The query filter to return the items containing the specified tax IDs.
*/
export class CatalogQueryItemsForTax {
    /**
    * A set of `CatalogTax` IDs to be used to find associated `CatalogItem`s.
    */
    'taxIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxIds",
            "baseName": "tax_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryItemsForTax.attributeTypeMap;
    }
}

/**
* The query filter to return the search result whose named attribute values are prefixed by the specified attribute value.
*/
export class CatalogQueryPrefix {
    /**
    * The name of the attribute to be searched.
    */
    'attributeName': string;
    /**
    * The desired prefix of the search attribute value.
    */
    'attributePrefix': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeName",
            "baseName": "attribute_name",
            "type": "string"
        },
        {
            "name": "attributePrefix",
            "baseName": "attribute_prefix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryPrefix.attributeTypeMap;
    }
}

/**
* The query filter to return the search result whose named attribute values fall between the specified range.
*/
export class CatalogQueryRange {
    /**
    * The name of the attribute to be searched.
    */
    'attributeName': string;
    /**
    * The desired minimum value for the search attribute (inclusive).
    */
    'attributeMinValue'?: number;
    /**
    * The desired maximum value for the search attribute (inclusive).
    */
    'attributeMaxValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeName",
            "baseName": "attribute_name",
            "type": "string"
        },
        {
            "name": "attributeMinValue",
            "baseName": "attribute_min_value",
            "type": "number"
        },
        {
            "name": "attributeMaxValue",
            "baseName": "attribute_max_value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryRange.attributeTypeMap;
    }
}

/**
* The query expression to specify the key to sort search results.
*/
export class CatalogQuerySortedAttribute {
    /**
    * The attribute whose value is used as the sort key.
    */
    'attributeName': string;
    /**
    * The first attribute value to be returned by the query. Ascending sorts will return only objects with this value or greater, while descending sorts will return only objects with this value or less. If unset, start at the beginning (for ascending sorts) or end (for descending sorts).
    */
    'initialAttributeValue'?: string;
    /**
    * The desired sort order, `\"ASC\"` (ascending) or `\"DESC\"` (descending). See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeName",
            "baseName": "attribute_name",
            "type": "string"
        },
        {
            "name": "initialAttributeValue",
            "baseName": "initial_attribute_value",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQuerySortedAttribute.attributeTypeMap;
    }
}

/**
* The query filter to return the search result whose searchable attribute values contain all of the specified keywords or tokens, independent of the token order or case.
*/
export class CatalogQueryText {
    /**
    * A list of 1, 2, or 3 search keywords. Keywords with fewer than 3 characters are ignored.
    */
    'keywords': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQueryText.attributeTypeMap;
    }
}

/**
* Represents a Quick Amount in the Catalog.
*/
export class CatalogQuickAmount {
    /**
    * Represents the type of the Quick Amount. See [CatalogQuickAmountType](#type-catalogquickamounttype) for possible values
    */
    'type': string;
    /**
    * Represents the actual amount of the Quick Amount with Money type.
    */
    'amount': Money;
    /**
    * Describes the ranking of the Quick Amount provided by machine learning model, in the range [0, 100]. MANUAL type amount will always have score = 100.
    */
    'score'?: number;
    /**
    * The order in which this Quick Amount should be displayed.
    */
    'ordinal'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Money"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQuickAmount.attributeTypeMap;
    }
}

/**
* Determines the type of a specific Quick Amount.
*/
export class CatalogQuickAmountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogQuickAmountType.attributeTypeMap;
    }
}

/**
* A parent Catalog Object model represents a set of Quick Amounts and the settings control the amounts.
*/
export class CatalogQuickAmountsSettings {
    /**
    * Represents the option seller currently uses on Quick Amounts. See [CatalogQuickAmountsSettingsOption](#type-catalogquickamountssettingsoption) for possible values
    */
    'option': string;
    /**
    * Represents location's eligibility for auto amounts The boolean should be consistent with whether there are AUTO amounts in the `amounts`.
    */
    'eligibleForAutoAmounts'?: boolean;
    /**
    * Represents a set of Quick Amounts at this location.
    */
    'amounts'?: Array<CatalogQuickAmount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "option",
            "baseName": "option",
            "type": "string"
        },
        {
            "name": "eligibleForAutoAmounts",
            "baseName": "eligible_for_auto_amounts",
            "type": "boolean"
        },
        {
            "name": "amounts",
            "baseName": "amounts",
            "type": "Array<CatalogQuickAmount>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogQuickAmountsSettings.attributeTypeMap;
    }
}

/**
* Determines a seller's option on Quick Amounts feature.
*/
export class CatalogQuickAmountsSettingsOption {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogQuickAmountsSettingsOption.attributeTypeMap;
    }
}

/**
* Describes a subscription plan. For more information, see [Set Up and Manage a Subscription Plan](/docs/subscriptions-api/setup-plan).
*/
export class CatalogSubscriptionPlan {
    /**
    * The name of the plan.
    */
    'name'?: string;
    /**
    * A list of SubscriptionPhase containing the `SubscriptionPhase` for this plan.
    */
    'phases'?: Array<SubscriptionPhase>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "phases",
            "baseName": "phases",
            "type": "Array<SubscriptionPhase>"
        }    ];

    static getAttributeTypeMap() {
        return CatalogSubscriptionPlan.attributeTypeMap;
    }
}

/**
* A tax applicable to an item.
*/
export class CatalogTax {
    /**
    * The tax's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
    */
    'name'?: string;
    /**
    * Whether the tax is calculated based on a payment's subtotal or total. See [TaxCalculationPhase](#type-taxcalculationphase) for possible values
    */
    'calculationPhase'?: string;
    /**
    * Whether the tax is `ADDITIVE` or `INCLUSIVE`. See [TaxInclusionType](#type-taxinclusiontype) for possible values
    */
    'inclusionType'?: string;
    /**
    * The percentage of the tax in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign. A value of `7.5` corresponds to 7.5%.
    */
    'percentage'?: string;
    /**
    * If `true`, the fee applies to custom amounts entered into the Square Point of Sale app that are not associated with a particular `CatalogItem`.
    */
    'appliesToCustomAmounts'?: boolean;
    /**
    * If `true`, the tax will be shown as enabled in the Square Point of Sale app.
    */
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "calculationPhase",
            "baseName": "calculation_phase",
            "type": "string"
        },
        {
            "name": "inclusionType",
            "baseName": "inclusion_type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "appliesToCustomAmounts",
            "baseName": "applies_to_custom_amounts",
            "type": "boolean"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogTax.attributeTypeMap;
    }
}

/**
* Represents a time period - either a single period or a repeating period.
*/
export class CatalogTimePeriod {
    /**
    * An iCalendar (RFC5545) [event](https://tools.ietf.org/html/rfc5545#section-3.6.1), which specifies the name, timing, duration and recurrence of this time period.  Example:  ``` DTSTART:20190707T180000 DURATION:P2H RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR ```  Only `SUMMARY`, `DTSTART`, `DURATION` and `RRULE` fields are supported. `DTSTART` must be in local (unzoned) time format. Note that while `BEGIN:VEVENT` and `END:VEVENT` is not required in the request. The response will always include them.
    */
    'event'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogTimePeriod.attributeTypeMap;
    }
}

/**
* A Square API V1 identifier of an item, including the object ID and its associated location ID.
*/
export class CatalogV1Id {
    /**
    * The ID for an object used in the Square API V1, if the object ID differs from the Square API V2 object ID.
    */
    'catalogV1Id'?: string;
    /**
    * The ID of the `Location` this Connect V1 ID is associated with.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "catalogV1Id",
            "baseName": "catalog_v1_id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogV1Id.attributeTypeMap;
    }
}

/**
* Defines the parameters that can be included in the body of a request to the [Charge](#endpoint-charge) endpoint.  Deprecated - recommend using [CreatePayment](#endpoint-payments-createpayment)
*/
export class ChargeRequest {
    /**
    * A value you specify that uniquely identifies this transaction among transactions you've created.  If you're unsure whether a particular transaction succeeded, you can reattempt it with the same idempotency key without worrying about double-charging the buyer.  See [Idempotency keys](#idempotencykeys) for more information.
    */
    'idempotencyKey': string;
    /**
    * The amount of money to charge.  Note that you specify the amount in the __smallest denomination of the applicable currency__. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  The value of `currency` must match the currency associated with the business that is charging the card.
    */
    'amountMoney': Money;
    /**
    * A nonce generated from the `SqPaymentForm` that represents the card to charge.  The application that provides a nonce to this endpoint must be the _same application_ that generated the nonce with the `SqPaymentForm`. Otherwise, the nonce is invalid.  Do not provide a value for this field if you provide a value for `customer_card_id`.
    */
    'cardNonce'?: string;
    /**
    * The ID of the customer card on file to charge. Do not provide a value for this field if you provide a value for `card_nonce`.  If you provide this value, you _must_ also provide a value for `customer_id`.
    */
    'customerCardId'?: string;
    /**
    * If `true`, the request will only perform an Auth on the provided card. You can then later perform either a Capture (with the `CaptureTransaction` or a Void (with the `VoidTransaction`.  Default value: `false`
    */
    'delayCapture'?: boolean;
    /**
    * An optional ID you can associate with the transaction for your own purposes (such as to associate the transaction with an entity ID in your own database).  This value cannot exceed 40 characters.
    */
    'referenceId'?: string;
    /**
    * An optional note to associate with the transaction.  This value cannot exceed 60 characters.
    */
    'note'?: string;
    /**
    * The ID of the customer to associate this transaction with. This field is required if you provide a value for `customer_card_id`, and optional otherwise.
    */
    'customerId'?: string;
    /**
    * The buyer's billing address. This value is optional, but this transaction is ineligible for chargeback protection if neither this parameter nor `shipping_address` is provided.
    */
    'billingAddress'?: Address;
    /**
    * The buyer's shipping address, if available. This value is optional, but this transaction is ineligible for chargeback protection if neither this parameter nor `billing_address` is provided.
    */
    'shippingAddress'?: Address;
    /**
    * The buyer's email address, if available. This value is optional, but this transaction is ineligible for chargeback protection if it is not provided.
    */
    'buyerEmailAddress'?: string;
    /**
    * The ID of the order to associate with this transaction.  If you provide this value, the `amount_money` value of your request must __exactly match__ the value of the order's `total_money` field.
    */
    'orderId'?: string;
    /**
    * The basic primitive of multi-party transaction. The value is optional. The transaction facilitated by you can be split from here.  If you provide this value, the `amount_money` value in your additional_recipients must not be more than 90% of the `amount_money` value in the charge request. The `location_id` must be the valid location of the app owner merchant.  This field requires the `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission.  This field is currently not supported in sandbox.
    */
    'additionalRecipients'?: Array<AdditionalRecipient>;
    /**
    * A token generated by SqPaymentForm's verifyBuyer() that represents customer's device info and 3ds challenge result.
    */
    'verificationToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "cardNonce",
            "baseName": "card_nonce",
            "type": "string"
        },
        {
            "name": "customerCardId",
            "baseName": "customer_card_id",
            "type": "string"
        },
        {
            "name": "delayCapture",
            "baseName": "delay_capture",
            "type": "boolean"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "billingAddress",
            "baseName": "billing_address",
            "type": "Address"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "buyerEmailAddress",
            "baseName": "buyer_email_address",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "additionalRecipients",
            "baseName": "additional_recipients",
            "type": "Array<AdditionalRecipient>"
        },
        {
            "name": "verificationToken",
            "baseName": "verification_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChargeRequest.attributeTypeMap;
    }
}

/**
* Represents an additional recipient (other than the merchant) entitled to a portion of the tender. Support is currently limited to USD, CAD and GBP currencies
*/
export class ChargeRequestAdditionalRecipient {
    /**
    * The location ID for a recipient (other than the merchant) receiving a portion of the tender.
    */
    'locationId': string;
    /**
    * The description of the additional recipient.
    */
    'description': string;
    /**
    * The amount of money distributed to the recipient.
    */
    'amountMoney': Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return ChargeRequestAdditionalRecipient.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [Charge](#endpoint-charge) endpoint.  One of `errors` or `transaction` is present in a given response (never both).
*/
export class ChargeResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created transaction.
    */
    'transaction'?: Transaction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        }    ];

    static getAttributeTypeMap() {
        return ChargeResponse.attributeTypeMap;
    }
}

/**
* Square Checkout lets merchants accept online payments for supported payment types using a checkout workflow hosted on squareup.com.
*/
export class Checkout {
    /**
    * ID generated by Square Checkout when a new checkout is requested.
    */
    'id'?: string;
    /**
    * The URL that the buyer's browser should be redirected to after the checkout is completed.
    */
    'checkoutPageUrl'?: string;
    /**
    * If `true`, Square Checkout will collect shipping information on your behalf and store that information with the transaction information in your Square Dashboard.  Default: `false`.
    */
    'askForShippingAddress'?: boolean;
    /**
    * The email address to display on the Square Checkout confirmation page and confirmation email that the buyer can use to contact the merchant.  If this value is not set, the confirmation page and email will display the primary email address associated with the merchant's Square account.  Default: none; only exists if explicitly set.
    */
    'merchantSupportEmail'?: string;
    /**
    * If provided, the buyer's email is pre-populated on the checkout page as an editable text field.  Default: none; only exists if explicitly set.
    */
    'prePopulateBuyerEmail'?: string;
    /**
    * If provided, the buyer's shipping info is pre-populated on the checkout page as editable text fields.  Default: none; only exists if explicitly set.
    */
    'prePopulateShippingAddress'?: Address;
    /**
    * The URL to redirect to after checkout is completed with `checkoutId`, Square's `orderId`, `transactionId`, and `referenceId` appended as URL parameters. For example, if the provided redirect_url is `http://www.example.com/order-complete`, a successful transaction redirects the customer to:  `http://www.example.com/order-complete?checkoutId=xxxxxx&orderId=xxxxxx&referenceId=xxxxxx&transactionId=xxxxxx`  If you do not provide a redirect URL, Square Checkout will display an order confirmation page on your behalf; however Square strongly recommends that you provide a redirect URL so you can verify the transaction results and finalize the order through your existing/normal confirmation workflow.
    */
    'redirectUrl'?: string;
    /**
    * Order to be checked out.
    */
    'order'?: Order;
    /**
    * The time when the checkout was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Additional recipients (other than the merchant) receiving a portion of this checkout. For example, fees assessed on the purchase by a third party integration.
    */
    'additionalRecipients'?: Array<AdditionalRecipient>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "checkoutPageUrl",
            "baseName": "checkout_page_url",
            "type": "string"
        },
        {
            "name": "askForShippingAddress",
            "baseName": "ask_for_shipping_address",
            "type": "boolean"
        },
        {
            "name": "merchantSupportEmail",
            "baseName": "merchant_support_email",
            "type": "string"
        },
        {
            "name": "prePopulateBuyerEmail",
            "baseName": "pre_populate_buyer_email",
            "type": "string"
        },
        {
            "name": "prePopulateShippingAddress",
            "baseName": "pre_populate_shipping_address",
            "type": "Address"
        },
        {
            "name": "redirectUrl",
            "baseName": "redirect_url",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "additionalRecipients",
            "baseName": "additional_recipients",
            "type": "Array<AdditionalRecipient>"
        }    ];

    static getAttributeTypeMap() {
        return Checkout.attributeTypeMap;
    }
}

/**
* Completes (captures) a payment.  By default, payments are set to autocomplete immediately after they are created. To complete payments manually, set `autocomplete` to false.
*/
export class CompletePaymentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CompletePaymentRequest.attributeTypeMap;
    }
}

/**
* Return value from a [CompletePayment](#endpoint-payments-completepayment) call.
*/
export class CompletePaymentResponse {
    /**
    * Information on errors encountered during the request
    */
    'errors'?: Array<Error>;
    /**
    * The successfully completed `Payment`.
    */
    'payment'?: Payment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }    ];

    static getAttributeTypeMap() {
        return CompletePaymentResponse.attributeTypeMap;
    }
}

/**
* Latitude and longitude coordinates.
*/
export class Coordinates {
    /**
    * The latitude of the coordinate expressed in degrees.
    */
    'latitude'?: number;
    /**
    * The longitude of the coordinate expressed in degrees.
    */
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

/**
* Indicates the country associated with another entity, such as a business. Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
*/
export class Country {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Country.attributeTypeMap;
    }
}

/**
* A request to create a new `BreakType`
*/
export class CreateBreakTypeRequest {
    /**
    * Unique string value to insure idempotency of the operation
    */
    'idempotencyKey'?: string;
    /**
    * The `BreakType` to be created.
    */
    'breakType': BreakType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "breakType",
            "baseName": "break_type",
            "type": "BreakType"
        }    ];

    static getAttributeTypeMap() {
        return CreateBreakTypeRequest.attributeTypeMap;
    }
}

/**
* The response to the request to create a `BreakType`. Contains the created `BreakType` object. May contain a set of `Error` objects if the request resulted in errors.
*/
export class CreateBreakTypeResponse {
    /**
    * The `BreakType` that was created by the request.
    */
    'breakType'?: BreakType;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "breakType",
            "baseName": "break_type",
            "type": "BreakType"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateBreakTypeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateCatalogImageRequest {
    /**
    * A unique string that identifies this CreateCatalogImage request. Keys can be any valid string but must be unique for every CreateCatalogImage request.  See [Idempotency keys](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * Unique ID of the `CatalogObject` to attach to this `CatalogImage`. Leave this field empty to create unattached images, for example if you are building an integration where these images can be attached to catalog items at a later time.
    */
    'objectId'?: string;
    /**
    * The new `IMAGE`-type `CatalogObject` to be attached to this `CatalogImage`. If the `CatalogObject` already has a `CatalogImage`, this call will overwrite it.
    */
    'image'?: CatalogObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "objectId",
            "baseName": "object_id",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "CatalogObject"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogImageRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateCatalogImageResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The newly created `CatalogImage` including a Square-generated URL for each image.
    */
    'image'?: CatalogObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "CatalogObject"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogImageResponse.attributeTypeMap;
    }
}

/**
* Defines the parameters that can be included in the body of a request to the __CreateCheckout__ endpoint.
*/
export class CreateCheckoutRequest {
    /**
    * A unique string that identifies this checkout among others you've created. It can be any valid string but must be unique for every order sent to Square Checkout for a given location ID.  The idempotency key is used to avoid processing the same order more than once. If you're unsure whether a particular checkout was created successfully, you can reattempt it with the same idempotency key and all the same other parameters without worrying about creating duplicates.  We recommend using a random number/string generator native to the language you are working in to generate strings for your idempotency keys.  See the [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency) guide for more information.
    */
    'idempotencyKey': string;
    /**
    * The order including line items to be checked out.
    */
    'order': CreateOrderRequest;
    /**
    * If `true`, Square Checkout will collect shipping information on your behalf and store that information with the transaction information in your Square Dashboard.  Default: `false`.
    */
    'askForShippingAddress'?: boolean;
    /**
    * The email address to display on the Square Checkout confirmation page and confirmation email that the buyer can use to contact the merchant.  If this value is not set, the confirmation page and email will display the primary email address associated with the merchant's Square account.  Default: none; only exists if explicitly set.
    */
    'merchantSupportEmail'?: string;
    /**
    * If provided, the buyer's email is pre-populated on the checkout page as an editable text field.  Default: none; only exists if explicitly set.
    */
    'prePopulateBuyerEmail'?: string;
    /**
    * If provided, the buyer's shipping info is pre-populated on the checkout page as editable text fields.  Default: none; only exists if explicitly set.
    */
    'prePopulateShippingAddress'?: Address;
    /**
    * The URL to redirect to after checkout is completed with `checkoutId`, Square's `orderId`, `transactionId`, and `referenceId` appended as URL parameters. For example, if the provided redirect_url is `http://www.example.com/order-complete`, a successful transaction redirects the customer to:  `http://www.example.com/order-complete?checkoutId=xxxxxx&orderId=xxxxxx&referenceId=xxxxxx&transactionId=xxxxxx`  If you do not provide a redirect URL, Square Checkout will display an order confirmation page on your behalf; however Square strongly recommends that you provide a redirect URL so you can verify the transaction results and finalize the order through your existing/normal confirmation workflow.  Default: none; only exists if explicitly set.
    */
    'redirectUrl'?: string;
    /**
    * The basic primitive of multi-party transaction. The value is optional. The transaction facilitated by you can be split from here.  If you provide this value, the `amount_money` value in your additional_recipients must not be more than 90% of the `total_money` calculated by Square for your order. The `location_id` must be the valid location of the app owner merchant.  This field requires `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission.  This field is currently not supported in sandbox.
    */
    'additionalRecipients'?: Array<ChargeRequestAdditionalRecipient>;
    /**
    * An optional note to associate with the checkout object.  This value cannot exceed 60 characters.
    */
    'note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "CreateOrderRequest"
        },
        {
            "name": "askForShippingAddress",
            "baseName": "ask_for_shipping_address",
            "type": "boolean"
        },
        {
            "name": "merchantSupportEmail",
            "baseName": "merchant_support_email",
            "type": "string"
        },
        {
            "name": "prePopulateBuyerEmail",
            "baseName": "pre_populate_buyer_email",
            "type": "string"
        },
        {
            "name": "prePopulateShippingAddress",
            "baseName": "pre_populate_shipping_address",
            "type": "Address"
        },
        {
            "name": "redirectUrl",
            "baseName": "redirect_url",
            "type": "string"
        },
        {
            "name": "additionalRecipients",
            "baseName": "additional_recipients",
            "type": "Array<ChargeRequestAdditionalRecipient>"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateCheckoutRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the __CreateCheckout__ endpoint.
*/
export class CreateCheckoutResponse {
    /**
    * The newly created checkout. If the same request was made with the same idempotency_key, this will be the checkout created with the idempotency_key.
    */
    'checkout'?: Checkout;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "Checkout"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateCheckoutResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the request body of a request to the CreateCustomerCard endpoint.
*/
export class CreateCustomerCardRequest {
    /**
    * A card nonce representing the credit card to link to the customer.  Card nonces are generated by the Square Payment Form when customers enter their card information. See [Embedding the payment form](https://developer.squareup.com/docs/payment-form/payment-form-walkthrough) for more information.  __NOTE:__ Card nonces generated by digital wallets (e.g., Apple Pay) cannot be used to create a customer card.
    */
    'cardNonce': string;
    /**
    * Address information for the card on file. Only the `postal_code` field is required for payments in the US and Canada.
    */
    'billingAddress'?: Address;
    /**
    * The full name printed on the credit card.
    */
    'cardholderName'?: string;
    /**
    * An identifying token generated by `SqPaymentForm.verifyBuyer()`. Verification tokens encapsulate customer device information and 3-D Secure challenge results to indicate that Square has verified the buyer identity.
    */
    'verificationToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardNonce",
            "baseName": "card_nonce",
            "type": "string"
        },
        {
            "name": "billingAddress",
            "baseName": "billing_address",
            "type": "Address"
        },
        {
            "name": "cardholderName",
            "baseName": "cardholder_name",
            "type": "string"
        },
        {
            "name": "verificationToken",
            "baseName": "verification_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerCardRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the CreateCustomerCard endpoint.  One of `errors` or `card` is present in a given response (never both).
*/
export class CreateCustomerCardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created card on file.
    */
    'card'?: Card;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerCardResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be provided in a request to the [CreateCustomerGroup](#endpoint-createcustomegroup) endpoint.
*/
export class CreateCustomerGroupRequest {
    /**
    * The idempotency key for the request. See the [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) guide for more information.
    */
    'idempotencyKey'?: string;
    /**
    * The customer group to create.
    */
    'group': CustomerGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "CustomerGroup"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerGroupRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [CreateCustomerGroup](#endpoint-createcustomergroup) endpoint.  One of `errors` or `group` is present in a given response (never both).
*/
export class CreateCustomerGroupResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The successfully created customer group.
    */
    'group'?: CustomerGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "CustomerGroup"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerGroupResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be provided in a request to the CreateCustomer endpoint.
*/
export class CreateCustomerRequest {
    /**
    * The idempotency key for the request. See the [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency) guide for more information.
    */
    'idempotencyKey'?: string;
    /**
    * The given (i.e., first) name associated with the customer profile.
    */
    'givenName'?: string;
    /**
    * The family (i.e., last) name associated with the customer profile.
    */
    'familyName'?: string;
    /**
    * A business name associated with the customer profile.
    */
    'companyName'?: string;
    /**
    * A nickname for the customer profile.
    */
    'nickname'?: string;
    /**
    * The email address associated with the customer profile.
    */
    'emailAddress'?: string;
    /**
    * The physical address associated with the customer profile.
    */
    'address'?: Address;
    /**
    * The 11-digit phone number associated with the customer profile.
    */
    'phoneNumber'?: string;
    /**
    * An optional, second ID used to associate the customer profile with an entity in another system.
    */
    'referenceId'?: string;
    /**
    * A custom note associated with the customer profile.
    */
    'note'?: string;
    /**
    * The birthday associated with the customer profile, in RFC-3339 format. Year is optional, timezone and times are not allowed. For example: `0000-09-01T00:00:00-00:00` indicates a birthday on September 1st. `1998-09-01T00:00:00-00:00` indications a birthday on September 1st __1998__.
    */
    'birthday'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "givenName",
            "baseName": "given_name",
            "type": "string"
        },
        {
            "name": "familyName",
            "baseName": "family_name",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "birthday",
            "baseName": "birthday",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the CreateCustomer endpoint.  One of `errors` or `customer` is present in a given response (never both).
*/
export class CreateCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created customer.
    */
    'customer'?: Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomerResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateDeviceCodeRequest {
    /**
    * A unique string that identifies this CreateCheckout request. Keys can be any valid string but must be unique for every CreateCheckout request.  See [Idempotency keys](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * The device code to create.
    */
    'deviceCode': DeviceCode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "deviceCode",
            "baseName": "device_code",
            "type": "DeviceCode"
        }    ];

    static getAttributeTypeMap() {
        return CreateDeviceCodeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateDeviceCodeResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created DeviceCode object containing the device code string.
    */
    'deviceCode'?: DeviceCode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "deviceCode",
            "baseName": "device_code",
            "type": "DeviceCode"
        }    ];

    static getAttributeTypeMap() {
        return CreateDeviceCodeResponse.attributeTypeMap;
    }
}

/**
* Defines parameters for a CreateDisputeEvidenceFile request.
*/
export class CreateDisputeEvidenceFileRequest {
    /**
    * Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey': string;
    /**
    * The type of evidence you are uploading. See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
    */
    'evidenceType'?: string;
    /**
    * The MIME type of the uploaded file. One of image/heic, image/heif, image/jpeg, application/pdf,  image/png, image/tiff.
    */
    'contentType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "evidenceType",
            "baseName": "evidence_type",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateDisputeEvidenceFileRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a CreateDisputeEvidenceFile response.
*/
export class CreateDisputeEvidenceFileResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The metadata of the newly uploaded dispute evidence.
    */
    'evidence'?: DisputeEvidence;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "evidence",
            "baseName": "evidence",
            "type": "DisputeEvidence"
        }    ];

    static getAttributeTypeMap() {
        return CreateDisputeEvidenceFileResponse.attributeTypeMap;
    }
}

/**
* Defines parameters for a CreateDisputeEvidenceText request.
*/
export class CreateDisputeEvidenceTextRequest {
    /**
    * Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey': string;
    /**
    * The type of evidence you are uploading. See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
    */
    'evidenceType'?: string;
    /**
    * The evidence string.
    */
    'evidenceText': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "evidenceType",
            "baseName": "evidence_type",
            "type": "string"
        },
        {
            "name": "evidenceText",
            "baseName": "evidence_text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateDisputeEvidenceTextRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a CreateDisputeEvidenceText response.
*/
export class CreateDisputeEvidenceTextResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The newly uploaded dispute evidence metadata.
    */
    'evidence'?: DisputeEvidence;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "evidence",
            "baseName": "evidence",
            "type": "DisputeEvidence"
        }    ];

    static getAttributeTypeMap() {
        return CreateDisputeEvidenceTextResponse.attributeTypeMap;
    }
}

/**
* Describes a `CreateInvoice` request.
*/
export class CreateInvoiceRequest {
    /**
    * The invoice to create.
    */
    'invoice': Invoice;
    /**
    * A unique string that identifies the `CreateInvoice` request. If you do not  provide `idempotency_key` (or provide an empty string as the value), the endpoint  treats each request as independent.  For more information, see [Idempotency](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateInvoiceRequest.attributeTypeMap;
    }
}

/**
* The response returned by the `CreateInvoice` request.
*/
export class CreateInvoiceResponse {
    /**
    * The newly created invoice.
    */
    'invoice'?: Invoice;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateInvoiceResponse.attributeTypeMap;
    }
}

/**
* Request object for the [CreateLocation](#endpoint-createlocation) endpoint.
*/
export class CreateLocationRequest {
    /**
    * The initial values of the location being created. The `name` field is required. All other fields are optional. Unspecified fields will be set to default values using existing location data.
    */
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocationRequest.attributeTypeMap;
    }
}

/**
* Response object returned by the [CreateLocation](#endpoint-createlocation) endpoint.
*/
export class CreateLocationResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The newly created `Location`.
    */
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocationResponse.attributeTypeMap;
    }
}

/**
* A request to create a new loyalty account.
*/
export class CreateLoyaltyAccountRequest {
    /**
    * The loyalty account to create.
    */
    'loyaltyAccount': LoyaltyAccount;
    /**
    * A unique string that identifies this `CreateLoyaltyAccount` request.  Keys can be any valid string, but must be unique for every request.
    */
    'idempotencyKey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyAccount",
            "baseName": "loyalty_account",
            "type": "LoyaltyAccount"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLoyaltyAccountRequest.attributeTypeMap;
    }
}

/**
* A response that includes loyalty account created.
*/
export class CreateLoyaltyAccountResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The newly created loyalty account.
    */
    'loyaltyAccount'?: LoyaltyAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "loyaltyAccount",
            "baseName": "loyalty_account",
            "type": "LoyaltyAccount"
        }    ];

    static getAttributeTypeMap() {
        return CreateLoyaltyAccountResponse.attributeTypeMap;
    }
}

/**
* A request to create a loyalty reward.
*/
export class CreateLoyaltyRewardRequest {
    /**
    * The reward to create.
    */
    'reward': LoyaltyReward;
    /**
    * A unique string that identifies this `CreateLoyaltyReward` request.  Keys can be any valid string, but must be unique for every request.
    */
    'idempotencyKey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reward",
            "baseName": "reward",
            "type": "LoyaltyReward"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLoyaltyRewardRequest.attributeTypeMap;
    }
}

/**
* A response that includes the loyalty reward created.
*/
export class CreateLoyaltyRewardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty reward created.
    */
    'reward'?: LoyaltyReward;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "reward",
            "baseName": "reward",
            "type": "LoyaltyReward"
        }    ];

    static getAttributeTypeMap() {
        return CreateLoyaltyRewardResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be provided in a request to the __CreateMobileAuthorizationCode__ endpoint.
*/
export class CreateMobileAuthorizationCodeRequest {
    /**
    * The Square location ID the authorization code should be tied to.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateMobileAuthorizationCodeRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the __CreateMobileAuthorizationCode__ endpoint.
*/
export class CreateMobileAuthorizationCodeResponse {
    /**
    * Generated authorization code that connects a mobile application instance to a Square account.
    */
    'authorizationCode'?: string;
    /**
    * The timestamp when `authorization_code` expires in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'expiresAt'?: string;
    /**
    * An error object that provides details about how creation of authorization code failed.
    */
    'error'?: Error;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorizationCode",
            "baseName": "authorization_code",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        }    ];

    static getAttributeTypeMap() {
        return CreateMobileAuthorizationCodeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateOrderRequest {
    /**
    * The order to create. If this field is set, then the only other top-level field that can be set is the idempotency_key.
    */
    'order'?: Order;
    /**
    * The ID of the business location to associate the order with.
    */
    'locationId'?: string;
    /**
    * A value you specify that uniquely identifies this order among orders you've created.  If you're unsure whether a particular order was created successfully, you can reattempt it with the same idempotency key without worrying about creating duplicate orders.  See [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateOrderRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the CreateOrder endpoint.  One of `errors` or `order` is present in a given response (never both).
*/
export class CreateOrderResponse {
    /**
    * The newly created order.
    */
    'order'?: Order;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateOrderResponse.attributeTypeMap;
    }
}

/**
* Creates a payment from the source (nonce, card on file, etc.)  The `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required to enable application fees.  For more information, see [Payments and Refunds Overview](/payments-api/overview).  For information about application fees in a payment, see [Collect Fees](/payments-api/take-payments-and-collect-fees).
*/
export class CreatePaymentRequest {
    /**
    * The ID for the source of funds for this payment.  This can be a nonce generated by the Payment Form or a card on file made with the Customers API.
    */
    'sourceId': string;
    /**
    * A unique string that identifies this CreatePayment request. Keys can be any valid string but must be unique for every CreatePayment request.  Max: 45 characters  See [Idempotency keys](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * The amount of money to accept for this payment, not including `tip_money`.  Must be specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  The currency code must match the currency associated with the business that is accepting the payment.
    */
    'amountMoney': Money;
    /**
    * The amount designated as a tip, in addition to `amount_money`  Must be specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  The currency code must match the currency associated with the business that is accepting the payment.
    */
    'tipMoney'?: Money;
    /**
    * The amount of money the developer is taking as a fee for facilitating the payment on behalf of the seller.  Cannot be more than 90% of the total amount of the Payment.  Must be specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  The fee currency code must match the currency associated with the merchant that is accepting the payment. The application must be from a developer account in the same country, and using the same currency code, as the merchant.  For more information about the application fee scenario, see [Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
    */
    'appFeeMoney'?: Money;
    /**
    * The duration of time after the payment's creation when Square automatically cancels the payment. This automatic cancellation applies only to payments that don't reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration` time period.  This parameter should be specified as a time duration, in RFC 3339 format, with a minimum value of 1 minute.  Notes: This feature is only supported for card payments. This parameter can only be set for a delayed capture payment (`autocomplete=false`).  Default:  - Card Present payments: \"PT36H\" (36 hours) from the creation time. - Card Not Present payments: \"P7D\" (7 days) from the creation time.
    */
    'delayDuration'?: string;
    /**
    * If set to `true`, this payment will be completed when possible. If set to `false`, this payment will be held in an approved state until either explicitly completed (captured) or canceled (voided). For more information, see [Delayed Payments](https://developer.squareup.com/docs/payments-api/take-payments#delayed-payments).  Default: true
    */
    'autocomplete'?: boolean;
    /**
    * Associate a previously created order with this payment
    */
    'orderId'?: string;
    /**
    * The `Customer` ID of the customer associated with the payment. Required if the `source_id` refers to a card on file created using the Customers API.
    */
    'customerId'?: string;
    /**
    * The location ID to associate with the payment. If not specified, the default location is used.
    */
    'locationId'?: string;
    /**
    * A user-defined ID to associate with the payment. You can use this field to associate the payment to an entity in an external system. For example, you might specify an order ID that is generated by a third-party shopping cart.  Limit 40 characters.
    */
    'referenceId'?: string;
    /**
    * An identifying token generated by `SqPaymentForm.verifyBuyer()`. Verification tokens encapsulate customer device information and 3-D Secure challenge results to indicate that Square has verified the buyer identity.  See the [SCA Overview](https://developer.squareup.com/docs/sca-overview).
    */
    'verificationToken'?: string;
    /**
    * If set to true and charging a Square Gift Card, a payment may be returned with amount_money equal to less than what was requested.  Example, a request for $20 when charging a Square Gift Card with balance of $5 wil result in an APPROVED payment of $5.  You may choose to prompt the buyer for an additional payment to cover the remainder, or cancel the gift card payment.  Cannot be `true` when `autocomplete = true`.  For more information, see [Partial amount with Square gift cards](https://developer.squareup.com/docs/payments-api/take-payments#partial-payment-gift-card).  Default: false
    */
    'acceptPartialAuthorization'?: boolean;
    /**
    * The buyer's e-mail address
    */
    'buyerEmailAddress'?: string;
    /**
    * The buyer's billing address.
    */
    'billingAddress'?: Address;
    /**
    * The buyer's shipping address.
    */
    'shippingAddress'?: Address;
    /**
    * An optional note to be entered by the developer when creating a payment  Limit 500 characters.
    */
    'note'?: string;
    /**
    * Optional additional payment information to include on the customer's card statement as part of statement description. This can be, for example, an invoice number, ticket number, or short description that uniquely identifies the purchase.  Note that the `statement_description_identifier` may get truncated on the statement description to fit the required information including the Square identifier (SQ *) and name of the merchant taking the payment.
    */
    'statementDescriptionIdentifier'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceId",
            "baseName": "source_id",
            "type": "string"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "tipMoney",
            "baseName": "tip_money",
            "type": "Money"
        },
        {
            "name": "appFeeMoney",
            "baseName": "app_fee_money",
            "type": "Money"
        },
        {
            "name": "delayDuration",
            "baseName": "delay_duration",
            "type": "string"
        },
        {
            "name": "autocomplete",
            "baseName": "autocomplete",
            "type": "boolean"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "verificationToken",
            "baseName": "verification_token",
            "type": "string"
        },
        {
            "name": "acceptPartialAuthorization",
            "baseName": "accept_partial_authorization",
            "type": "boolean"
        },
        {
            "name": "buyerEmailAddress",
            "baseName": "buyer_email_address",
            "type": "string"
        },
        {
            "name": "billingAddress",
            "baseName": "billing_address",
            "type": "Address"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "statementDescriptionIdentifier",
            "baseName": "statement_description_identifier",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreatePaymentRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [CreatePayment](#endpoint-payments-createpayment) endpoint.  Note: if there are errors processing the request, the payment field may not be present, or it may be present with a status of `FAILED`.
*/
export class CreatePaymentResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The newly created payment.
    */
    'payment'?: Payment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }    ];

    static getAttributeTypeMap() {
        return CreatePaymentResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be included in a request to the [CreateRefund](#endpoint-createrefund) endpoint.  Deprecated - recommend using [RefundPayment](#endpoint-refunds-refundpayment)
*/
export class CreateRefundRequest {
    /**
    * A value you specify that uniquely identifies this refund among refunds you've created for the tender.  If you're unsure whether a particular refund succeeded, you can reattempt it with the same idempotency key without worrying about duplicating the refund.  See [Idempotency keys](#idempotencykeys) for more information.
    */
    'idempotencyKey': string;
    /**
    * The ID of the tender to refund.  A ``Transaction`` has one or more `tenders` (i.e., methods of payment) associated with it, and you refund each tender separately with the Connect API.
    */
    'tenderId': string;
    /**
    * A description of the reason for the refund.  Default value: `Refund via API`
    */
    'reason'?: string;
    /**
    * The amount of money to refund.  Note that you specify the amount in the __smallest denomination of the applicable currency__. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  This amount cannot exceed the amount that was originally charged to the tender that corresponds to `tender_id`.
    */
    'amountMoney': Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "tenderId",
            "baseName": "tender_id",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return CreateRefundRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [CreateRefund](#endpoint-createrefund) endpoint.  One of `errors` or `refund` is present in a given response (never both).
*/
export class CreateRefundResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created refund.
    */
    'refund'?: Refund;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "refund",
            "baseName": "refund",
            "type": "Refund"
        }    ];

    static getAttributeTypeMap() {
        return CreateRefundResponse.attributeTypeMap;
    }
}

/**
* Represents a request to create a `Shift`
*/
export class CreateShiftRequest {
    /**
    * Unique string value to insure the idempotency of the operation.
    */
    'idempotencyKey'?: string;
    /**
    * The `Shift` to be created
    */
    'shift': Shift;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "shift",
            "baseName": "shift",
            "type": "Shift"
        }    ];

    static getAttributeTypeMap() {
        return CreateShiftRequest.attributeTypeMap;
    }
}

/**
* The response to the request to create a `Shift`. Contains the created `Shift` object. May contain a set of `Error` objects if the request resulted in errors.
*/
export class CreateShiftResponse {
    /**
    * The `Shift` that was created on the request.
    */
    'shift'?: Shift;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shift",
            "baseName": "shift",
            "type": "Shift"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateShiftResponse.attributeTypeMap;
    }
}

/**
* Defines parameters in a  [CreateSubscription](#endpoint-subscriptions-createsubscription) endpoint request.
*/
export class CreateSubscriptionRequest {
    /**
    * A unique string that identifies this `CreateSubscription` request. If you do not provide a unique string (or provide an empty string as the value), the endpoint treats each request as independent.  For more information, see [Idempotency keys](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey': string;
    /**
    * The ID of the location the subscription is associated with.
    */
    'locationId': string;
    /**
    * The ID of the subscription plan. For more information, see  [Subscription Plan Overview](https://developer.squareup.com/docs/docs/subscriptions/overview).
    */
    'planId': string;
    /**
    * The ID of the `customer` profile.
    */
    'customerId': string;
    /**
    * The start date of the subscription, in YYYY-MM-DD format. For example, 2013-01-15. If the start date is left empty, the subscription begins  immediately.
    */
    'startDate'?: string;
    /**
    * The date when the subscription should be canceled, in  YYYY-MM-DD format (for example, 2025-02-29). This overrides the plan configuration  if it comes before the date the subscription would otherwise end.
    */
    'canceledDate'?: string;
    /**
    * The tax to add when billing the subscription. The percentage is expressed in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign. For example, a value of 7.5 corresponds to 7.5%.
    */
    'taxPercentage'?: string;
    /**
    * A custom price to apply for the subscription. If specified,  it overrides the price configured by the subscription plan.
    */
    'priceOverrideMoney'?: Money;
    /**
    * The ID of the `customer](#type-customer) [card` to charge. If not specified, Square sends an invoice via email. For an example to create a customer and add a card on file, see [Subscriptions Walkthrough](https://developer.squareup.com/docs/docs/subscriptions-api/walkthrough).
    */
    'cardId'?: string;
    /**
    * The timezone that is used in date calculations for the subscription. If unset, defaults to the location timezone. If a timezone is not configured for the location, defaults to \"America/New_York\". Format: the IANA Timezone Database identifier for the location timezone. For a list of time zones, see [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
    */
    'timezone'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "plan_id",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "canceledDate",
            "baseName": "canceled_date",
            "type": "string"
        },
        {
            "name": "taxPercentage",
            "baseName": "tax_percentage",
            "type": "string"
        },
        {
            "name": "priceOverrideMoney",
            "baseName": "price_override_money",
            "type": "Money"
        },
        {
            "name": "cardId",
            "baseName": "card_id",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response from the [CreateSubscription](#endpoint-subscriptions-createsubscription) endpoint.
*/
export class CreateSubscriptionResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The newly created subscription.   For more information, see  [Subscription object](https://developer.squareup.com/docs/docs/subscriptions-api/overview#subscription-object).
    */
    'subscription'?: Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionResponse.attributeTypeMap;
    }
}

/**
* Represents a create request for a `TeamMember` object.
*/
export class CreateTeamMemberRequest {
    /**
    * A unique string that identifies this CreateTeamMember request. Keys can be any valid string but must be unique for every request. See [Idempotency keys](https://developer.squareup.com/docs/basics/api101/idempotency) for more information. <br> <b>Min Length 1    Max Length 45</b>
    */
    'idempotencyKey'?: string;
    /**
    * <b>Required</b> The data which will be used to create the `TeamMember` object.
    */
    'teamMember'?: TeamMember;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "teamMember",
            "baseName": "team_member",
            "type": "TeamMember"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeamMemberRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a create request, containing the created `TeamMember` object or error messages.
*/
export class CreateTeamMemberResponse {
    /**
    * The successfully created `TeamMember` object.
    */
    'teamMember'?: TeamMember;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMember",
            "baseName": "team_member",
            "type": "TeamMember"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeamMemberResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateTerminalCheckoutRequest {
    /**
    * A unique string that identifies this CreateCheckout request. Keys can be any valid string but must be unique for every CreateCheckout request.  See [Idempotency keys](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * The checkout to create.
    */
    'checkout': TerminalCheckout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "TerminalCheckout"
        }    ];

    static getAttributeTypeMap() {
        return CreateTerminalCheckoutRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateTerminalCheckoutResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The created `TerminalCheckout`
    */
    'checkout'?: TerminalCheckout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "TerminalCheckout"
        }    ];

    static getAttributeTypeMap() {
        return CreateTerminalCheckoutResponse.attributeTypeMap;
    }
}

/**
* Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
*/
export class Currency {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Currency.attributeTypeMap;
    }
}

/**
* Supported custom attribute query expressions for calling the  [SearchCatalogItems](#endpoint-Catalog-SearchCatalogItems)  endpoint to search for items or item variations.
*/
export class CustomAttributeFilter {
    /**
    * A query expression to filter items or item variations by matching their custom attributes'  `custom_attribute_definition_id`   property value against the the specified id.
    */
    'customAttributeDefinitionId'?: string;
    /**
    * A query expression to filter items or item variations by matching their custom attributes' `key` property value against  the specified key.
    */
    'key'?: string;
    /**
    * A query expression to filter items or item variations by matching their custom attributes'  `string_value`  property value  against the specified text.
    */
    'stringFilter'?: string;
    /**
    * A query expression to filter items or item variations with their custom attributes containing a number value within the specified range.
    */
    'numberFilter'?: Range;
    /**
    * A query expression to filter items or item variations by matching  their custom attributes'  `selection_uid_values`  values against the specified selection uids.
    */
    'selectionUidsFilter'?: Array<string>;
    /**
    * A query expression to filter items or item variations by matching their custom attributes' `boolean_value` property values  against the specified Boolean expression.
    */
    'boolFilter'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customAttributeDefinitionId",
            "baseName": "custom_attribute_definition_id",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "stringFilter",
            "baseName": "string_filter",
            "type": "string"
        },
        {
            "name": "numberFilter",
            "baseName": "number_filter",
            "type": "Range"
        },
        {
            "name": "selectionUidsFilter",
            "baseName": "selection_uids_filter",
            "type": "Array<string>"
        },
        {
            "name": "boolFilter",
            "baseName": "bool_filter",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomAttributeFilter.attributeTypeMap;
    }
}

/**
* Represents a Square customer profile, which can have one or more cards on file associated with it.
*/
export class Customer {
    /**
    * A unique Square-assigned ID for the customer profile.
    */
    'id'?: string;
    /**
    * The timestamp when the customer profile was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timestamp when the customer profile was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;
    /**
    * Payment details of cards stored on file for the customer profile.
    */
    'cards'?: Array<Card>;
    /**
    * The given (i.e., first) name associated with the customer profile.
    */
    'givenName'?: string;
    /**
    * The family (i.e., last) name associated with the customer profile.
    */
    'familyName'?: string;
    /**
    * A nickname for the customer profile.
    */
    'nickname'?: string;
    /**
    * A business name associated with the customer profile.
    */
    'companyName'?: string;
    /**
    * The email address associated with the customer profile.
    */
    'emailAddress'?: string;
    /**
    * The physical address associated with the customer profile.
    */
    'address'?: Address;
    /**
    * The 11-digit phone number associated with the customer profile.
    */
    'phoneNumber'?: string;
    /**
    * The birthday associated with the customer profile, in RFC-3339 format. Year is optional, timezone and times are not allowed. For example: `0000-09-01T00:00:00-00:00` indicates a birthday on September 1st. `1998-09-01T00:00:00-00:00` indications a birthday on September 1st __1998__.
    */
    'birthday'?: string;
    /**
    * An optional, second ID used to associate the customer profile with an entity in another system.
    */
    'referenceId'?: string;
    /**
    * A custom note associated with the customer profile.
    */
    'note'?: string;
    /**
    * Represents general customer preferences.
    */
    'preferences'?: CustomerPreferences;
    /**
    * The customer groups and segments the customer belongs to. This deprecated field has been replaced with  the dedicated `group_ids` for customer groups and the dedicated `segment_ids` field for customer segments. You can retrieve information about a given customer group and segment respectively using the Customer Groups API and Customer Segments API.
    */
    'groups'?: Array<CustomerGroupInfo>;
    /**
    * A creation source represents the method used to create the customer profile. See [CustomerCreationSource](#type-customercreationsource) for possible values
    */
    'creationSource'?: string;
    /**
    * The IDs of customer groups the customer belongs to.
    */
    'groupIds'?: Array<string>;
    /**
    * The IDs of segments the customer belongs to.
    */
    'segmentIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "cards",
            "baseName": "cards",
            "type": "Array<Card>"
        },
        {
            "name": "givenName",
            "baseName": "given_name",
            "type": "string"
        },
        {
            "name": "familyName",
            "baseName": "family_name",
            "type": "string"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "birthday",
            "baseName": "birthday",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "preferences",
            "baseName": "preferences",
            "type": "CustomerPreferences"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<CustomerGroupInfo>"
        },
        {
            "name": "creationSource",
            "baseName": "creation_source",
            "type": "string"
        },
        {
            "name": "groupIds",
            "baseName": "group_ids",
            "type": "Array<string>"
        },
        {
            "name": "segmentIds",
            "baseName": "segment_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

/**
* Indicates the method used to create the customer profile.
*/
export class CustomerCreationSource {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomerCreationSource.attributeTypeMap;
    }
}

/**
* Creation source filter.  If one or more creation sources are set, customer profiles are included in, or excluded from, the result if they match at least one of the filter criteria.
*/
export class CustomerCreationSourceFilter {
    /**
    * The list of creation sources used as filtering criteria. See [CustomerCreationSource](#type-customercreationsource) for possible values
    */
    'values'?: Array<string>;
    /**
    * Indicates whether a customer profile matching the filter criteria should be included in the result or excluded from the result.  Default: `INCLUDE`. See [CustomerInclusionExclusion](#type-customerinclusionexclusion) for possible values
    */
    'rule'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "rule",
            "baseName": "rule",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreationSourceFilter.attributeTypeMap;
    }
}

/**
* Represents a set of `CustomerQuery` filters used to limit the set of `Customers` returned by `SearchCustomers`.
*/
export class CustomerFilter {
    /**
    * A filter to select customers based on their creation source.
    */
    'creationSource'?: CustomerCreationSourceFilter;
    /**
    * A filter to select customers based on when they were created.
    */
    'createdAt'?: TimeRange;
    /**
    * A filter to select customers based on when they were updated.
    */
    'updatedAt'?: TimeRange;
    /**
    * A filter to [select customers by email address](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-email-address)  visible to the seller.  This filter is case insensitive.  For [exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-email-address), this filter causes the search to return customer profiles  whose `email_address` field value are identical to the email address provided in the query.  For [fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-email-address),  this filter causes the search to return customer profiles  whose `email_address` field value has a token-wise partial match against the filtering  expression in the query. For example, with `Steven gmail` provided in a search query, the search returns customers whose email address can be `steven.johnson&#64;gmail.com`  or `mygmail&#64;stevensbakery.com`. Email addresses are tokenized by replacing, by spaces,  punctuations including periods (`.`), underscores (`_`), and the `&#64;` symbols. A match is found if a tokenized email address contains all the tokens in the search query,  irrespective of the token order.
    */
    'emailAddress'?: CustomerTextFilter;
    /**
    * A filter to [select customers by their phone numbers](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-phone-number) visible to the seller.  This filter is case insensitive.   For [exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-phone-number),  this filter causes the search to return customers whose phone number matches the specified query expression. The number in the query must be of an E.164-compliant form. In particular, it must include the leading `+` sign followed by a contry code and then a subscriber number. The standard E.614 form of a US phone number is `+12061112222` of the domestic version or `+0012061112222` of the international version. The E.164-compliant variations include `+1 (206) 111-2222` or `+001 (206) 111-2222`, respectively. To match the query expression, stored customers' phone numbers are converted to the standard E.164 form of the national and internationalized versions.   For [fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-phone-number),  this filter causes the search to return customers whose phone number matches partially  the token or tokens provided in the query expression. For example, if the search query contains  `415-123-45`, the filter selects those customers with phone numbers of `415-123-4567` or  `234-151-2345`. The search does not return customers with the phone number of `415-123-4678`. Similarly, if the search query contains `415` as part of the phone number, the search returns those customers with phone numbers of `(415)-123-4567`, `(123) 415-1567`, and `1 (415) 123-4567`.
    */
    'phoneNumber'?: CustomerTextFilter;
    /**
    * A filter to [select customers by their reference IDs](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-reference-id). This filter is case insensitive.  [Exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-reference-id)  of a customer's reference ID against a query's reference ID is evaluated as exact match between two strings, character by character in the given order.  [Fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-reference-id) of stored reference IDs against queried reference IDs works  exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters  are replaced by spaces to tokenize stored and queried reference IDs. A match is found if a tokenized stored reference ID contains all tokens specified in any order in the query. For example, a query of `NYC M` will match customer profiles with the `reference_id` value of `NYC_M_35_JOHNSON` and `NYC_27_MURRAY`.
    */
    'referenceId'?: CustomerTextFilter;
    /**
    * A filter to select customers based on their group membership.  The `group_ids` is a JSON object of the following general format: ``` \"group_ids\": { \"any\":  [\"{group_a_id}\", \"{group_b_id}\", ...], \"all\":  [\"{group_1_id}\", \"{group_2_id}\", ...], 'none\": [\"{group_i_id}\", \"{group_ii_id}\", ...] } ```  You can use any combination of the above `group_ids` fields (also known as `FilterValue` properties)  to specify how customers are selected based on their group membership.   With the `any` option, the search returns customers in Groups `A` or `B` or ... of the list. With the `all` option, the search returns customers in Groups `1` and `2` and ... of the list. With the `none` option, the search returns customers not in Groups `i` and not in `ii` and not in ... of the list.  If any of the search conditions are not met, including when an invalid or non-existent group ID is provided, the result is an empty list.   You can use the `group_ids` search filter with other available filters.   You cannot use the `group_ids` filter to select customers based on segment membership.
    */
    'groupIds'?: FilterValue;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creationSource",
            "baseName": "creation_source",
            "type": "CustomerCreationSourceFilter"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "TimeRange"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "TimeRange"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "CustomerTextFilter"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "CustomerTextFilter"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "CustomerTextFilter"
        },
        {
            "name": "groupIds",
            "baseName": "group_ids",
            "type": "FilterValue"
        }    ];

    static getAttributeTypeMap() {
        return CustomerFilter.attributeTypeMap;
    }
}

/**
* Represents a group of customer profiles.   Customer groups can be created, modified, and have their membership defined either via  the Customers API or within Customer Directory in the Square Dashboard or Point of Sale.
*/
export class CustomerGroup {
    /**
    * Unique Square-generated ID for the customer group.
    */
    'id'?: string;
    /**
    * Name of the customer group.
    */
    'name': string;
    /**
    * The timestamp when the customer group was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timesamp when the customer group was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerGroup.attributeTypeMap;
    }
}

/**
* Contains some brief information about a Customer Group with its identifier included.
*/
export class CustomerGroupInfo {
    /**
    * The ID of the Customer Group.
    */
    'id': string;
    /**
    * The name of the Customer Group.
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerGroupInfo.attributeTypeMap;
    }
}

/**
* Indicates whether customers should be included in, or excluded from, the result set when they match the filtering criteria.
*/
export class CustomerInclusionExclusion {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomerInclusionExclusion.attributeTypeMap;
    }
}

/**
* Represents communication preferences for the customer profile.
*/
export class CustomerPreferences {
    /**
    * The customer has unsubscribed from receiving marketing campaign emails.
    */
    'emailUnsubscribed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailUnsubscribed",
            "baseName": "email_unsubscribed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerPreferences.attributeTypeMap;
    }
}

/**
* Represents a query (including filtering criteria, sorting criteria, or both) used to search for customer profiles.
*/
export class CustomerQuery {
    /**
    * A list of filtering criteria.
    */
    'filter'?: CustomerFilter;
    /**
    * Sorting criteria for query results. The default behavior is to sort  customers alphabetically by `given_name` and `family_name`.
    */
    'sort'?: CustomerSort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "CustomerFilter"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "CustomerSort"
        }    ];

    static getAttributeTypeMap() {
        return CustomerQuery.attributeTypeMap;
    }
}

/**
* Represents a group of customer profiles that match one or more predefined filter criteria.   Segments (also known as Smart Groups) are defined and created within Customer Directory in the Square Dashboard or Point of Sale.
*/
export class CustomerSegment {
    /**
    * Unique Square-generated ID for the segment.
    */
    'id'?: string;
    /**
    * Name of the segment.
    */
    'name': string;
    /**
    * The timestamp when the segment was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timestamp when the segment was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSegment.attributeTypeMap;
    }
}

/**
* Specifies how searched customers profiles are sorted, including the sort key and sort order.
*/
export class CustomerSort {
    /**
    *  Use one or more customer attributes as the sort key to sort searched customer profiles.  For example, use creation date (`created_at`) of customers or default attributes as the sort key.   Default: `DEFAULT`. See [CustomerSortField](#type-customersortfield) for possible values
    */
    'field'?: string;
    /**
    * Indicates the order in which results should be sorted based on the sort field value. Strings use standard alphabetic comparison to determine order. Strings representing numbers are sorted as strings.  Default: `ASC`. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSort.attributeTypeMap;
    }
}

/**
* Specifies customer attributes as the sort key to customer profiles returned from a search.
*/
export class CustomerSortField {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomerSortField.attributeTypeMap;
    }
}

/**
* A filter to select customers based on exact or fuzzy matching of customer attributes against a specified query. Depending on customer attributes,  the filter can be case sensitive. This filter can be either exact or fuzzy. It cannot be both.
*/
export class CustomerTextFilter {
    /**
    * Use the exact filter to select customers whose attributes match exactly the specified query.
    */
    'exact'?: string;
    /**
    * Use the fuzzy filter to select customers whose attributes match the specified query  in a fuzzy manner. When the fuzzy option is used, search queries are tokenized, and then  each query token must be matched somewhere in the searched attribute. For single token queries,  this is effectively the same behavior as a partial match operation.
    */
    'fuzzy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exact",
            "baseName": "exact",
            "type": "string"
        },
        {
            "name": "fuzzy",
            "baseName": "fuzzy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTextFilter.attributeTypeMap;
    }
}

/**
* A range defined by two dates. Used for filtering a query for Connect v2 objects that have date properties.
*/
export class DateRange {
    /**
    * String in `YYYY-MM-DD` format, e.g. `2017-10-31` per the ISO 8601 extended format for calendar dates. The beginning of a date range (inclusive)
    */
    'startDate'?: string;
    /**
    * String in `YYYY-MM-DD` format, e.g. `2017-10-31` per the ISO 8601 extended format for calendar dates. The end of a date range (inclusive)
    */
    'endDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DateRange.attributeTypeMap;
    }
}

/**
* Indicates the specific day  of the week.
*/
export class DayOfWeek {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DayOfWeek.attributeTypeMap;
    }
}

/**
* A request to delete a `BreakType`
*/
export class DeleteBreakTypeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteBreakTypeRequest.attributeTypeMap;
    }
}

/**
* The response to a request to delete a `BreakType`. May contain a set  of `Error` objects if the request resulted in errors.
*/
export class DeleteBreakTypeResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteBreakTypeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class DeleteCatalogObjectRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteCatalogObjectRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class DeleteCatalogObjectResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The IDs of all catalog objects deleted by this request. Multiple IDs may be returned when associated objects are also deleted, for example a catalog item variation will be deleted (and its ID included in this field) when its parent catalog item is deleted.
    */
    'deletedObjectIds'?: Array<string>;
    /**
    * The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this deletion in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
    */
    'deletedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "deletedObjectIds",
            "baseName": "deleted_object_ids",
            "type": "Array<string>"
        },
        {
            "name": "deletedAt",
            "baseName": "deleted_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteCatalogObjectResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the DeleteCustomerCard endpoint.
*/
export class DeleteCustomerCardRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteCustomerCardRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the DeleteCustomerCard endpoint.
*/
export class DeleteCustomerCardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteCustomerCardResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that can be provided in a request to the [DeleteCustomerGroup](#endpoint-deletecustomergroup) endpoint.
*/
export class DeleteCustomerGroupRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteCustomerGroupRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [DeleteCustomerGroup](#endpoint-deletecustomergroup) endpoint.
*/
export class DeleteCustomerGroupResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteCustomerGroupResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in a request to the DeleteCustomer endpoint.
*/
export class DeleteCustomerRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the DeleteCustomer endpoint.
*/
export class DeleteCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteCustomerResponse.attributeTypeMap;
    }
}

/**
* Describes a `DeleteInvoice` request.
*/
export class DeleteInvoiceRequest {
    /**
    * The version of the `invoice` to delete. If you do not know the version, you can call `GetInvoice` or  `ListInvoices`.
    */
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoiceRequest.attributeTypeMap;
    }
}

/**
* Describes a `DeleteInvoice` response.
*/
export class DeleteInvoiceResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoiceResponse.attributeTypeMap;
    }
}

/**
* A request to delete a loyalty reward.
*/
export class DeleteLoyaltyRewardRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteLoyaltyRewardRequest.attributeTypeMap;
    }
}

/**
* A response returned by the API call.
*/
export class DeleteLoyaltyRewardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteLoyaltyRewardResponse.attributeTypeMap;
    }
}

/**
* A request to delete a `Shift`
*/
export class DeleteShiftRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeleteShiftRequest.attributeTypeMap;
    }
}

/**
* The response to a request to delete a `Shift`. May contain a set of  `Error` objects if the request resulted in errors.
*/
export class DeleteShiftResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteShiftResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class Device {
    /**
    * The device's Square-issued ID.
    */
    'id'?: string;
    /**
    * The device's merchant-specified name.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Device.attributeTypeMap;
    }
}

/**
* 
*/
export class DeviceCheckoutOptions {
    /**
    * The unique Id of the device intended for this `TerminalCheckout`. The Id can be retrieved from /v2/devices api.
    */
    'deviceId': string;
    /**
    * Instruct the device to skip the receipt screen. Defaults to false.
    */
    'skipReceiptScreen'?: boolean;
    /**
    * Tip specific settings
    */
    'tipSettings'?: TipSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "device_id",
            "type": "string"
        },
        {
            "name": "skipReceiptScreen",
            "baseName": "skip_receipt_screen",
            "type": "boolean"
        },
        {
            "name": "tipSettings",
            "baseName": "tip_settings",
            "type": "TipSettings"
        }    ];

    static getAttributeTypeMap() {
        return DeviceCheckoutOptions.attributeTypeMap;
    }
}

/**
* 
*/
export class DeviceCode {
    /**
    * The unique id for this device code.
    */
    'id'?: string;
    /**
    * An optional user-defined name for the device code.
    */
    'name'?: string;
    /**
    * The unique code that can be used to login.
    */
    'code'?: string;
    /**
    * The unique id of the device that used this code. Populated when the device is paired up.
    */
    'deviceId'?: string;
    /**
    * The targeting product type of the device code. See [ProductType](#type-producttype) for possible values
    */
    'productType': string;
    /**
    * The location assigned to this code.
    */
    'locationId'?: string;
    /**
    * The pairing status of the device code. See [DeviceCodeStatus](#type-devicecodestatus) for possible values
    */
    'status'?: string;
    /**
    * When this DeviceCode will expire and no longer login. Timestamp in RFC 3339 format.
    */
    'pairBy'?: string;
    /**
    * When this DeviceCode was created. Timestamp in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * When this DeviceCode's status was last changed. Timestamp in RFC 3339 format.
    */
    'statusChangedAt'?: string;
    /**
    * When this DeviceCode was paired. Timestamp in RFC 3339 format.
    */
    'pairedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "deviceId",
            "baseName": "device_id",
            "type": "string"
        },
        {
            "name": "productType",
            "baseName": "product_type",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "pairBy",
            "baseName": "pair_by",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "statusChangedAt",
            "baseName": "status_changed_at",
            "type": "string"
        },
        {
            "name": "pairedAt",
            "baseName": "paired_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeviceCode.attributeTypeMap;
    }
}

/**
* DeviceCode.Status enum.
*/
export class DeviceCodeStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DeviceCodeStatus.attributeTypeMap;
    }
}

/**
* Details about the device that took the payment.
*/
export class DeviceDetails {
    /**
    * Square-issued ID of the device.
    */
    'deviceId'?: string;
    /**
    * The name of the device set by the merchant.
    */
    'deviceName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "device_id",
            "type": "string"
        },
        {
            "name": "deviceName",
            "baseName": "device_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeviceDetails.attributeTypeMap;
    }
}

/**
* Represents a dispute a cardholder initiated with their bank.
*/
export class Dispute {
    /**
    * Unique ID for this `Dispute`, generated by Square.
    */
    'disputeId'?: string;
    /**
    * The disputed amount. The amount can be less than the entire transaction amount. For example, a cardholder purchased multiple items, however initiated dispute only for some of the items.
    */
    'amountMoney'?: Money;
    /**
    * The dispute reason why cardholder initiated dispute with their bank. See [DisputeReason](#type-disputereason) for possible values
    */
    'reason'?: string;
    /**
    * The current state of this dispute. See [DisputeState](#type-disputestate) for possible values
    */
    'state'?: string;
    /**
    * The time when the next action is due, in RFC 3339 format.
    */
    'dueAt'?: string;
    /**
    * The payment challenged in this dispute.
    */
    'disputedPayment'?: DisputedPayment;
    /**
    * The IDs of the evidence associated with the dispute.
    */
    'evidenceIds'?: Array<string>;
    /**
    * The card brand used in the disputed payment. See [CardBrand](#type-cardbrand) for possible values
    */
    'cardBrand'?: string;
    /**
    * Timestamp when the dispute was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Timestamp when dispute was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;
    /**
    * ID of the dispute in the card brand system, generated by the card brand.
    */
    'brandDisputeId'?: string;
    /**
    * Timestamp when the dispute was reported, in RFC 3339 format.
    */
    'reportedDate'?: string;
    /**
    * The current version of the `Dispute`.
    */
    'version'?: number;
    /**
    * The ID of location where dispute originated.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "disputeId",
            "baseName": "dispute_id",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "dueAt",
            "baseName": "due_at",
            "type": "string"
        },
        {
            "name": "disputedPayment",
            "baseName": "disputed_payment",
            "type": "DisputedPayment"
        },
        {
            "name": "evidenceIds",
            "baseName": "evidence_ids",
            "type": "Array<string>"
        },
        {
            "name": "cardBrand",
            "baseName": "card_brand",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "brandDisputeId",
            "baseName": "brand_dispute_id",
            "type": "string"
        },
        {
            "name": "reportedDate",
            "baseName": "reported_date",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dispute.attributeTypeMap;
    }
}

/**
* 
*/
export class DisputeEvidence {
    /**
    * The Square-generated ID of the evidence.
    */
    'evidenceId'?: string;
    /**
    * The ID of the dispute the evidence is associated with.
    */
    'disputeId'?: string;
    /**
    * The time when the next action is due, in RFC 3339 format.
    */
    'uploadedAt'?: string;
    /**
    * The type of the evidence. See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
    */
    'evidenceType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "evidenceId",
            "baseName": "evidence_id",
            "type": "string"
        },
        {
            "name": "disputeId",
            "baseName": "dispute_id",
            "type": "string"
        },
        {
            "name": "uploadedAt",
            "baseName": "uploaded_at",
            "type": "string"
        },
        {
            "name": "evidenceType",
            "baseName": "evidence_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DisputeEvidence.attributeTypeMap;
    }
}

/**
* A file to be uploaded as dispute evidence.
*/
export class DisputeEvidenceFile {
    /**
    * The file name including the file extension. For example: \"receipt.tiff\".
    */
    'filename'?: string;
    /**
    * Dispute evidence files must one of application/pdf, image/heic, image/heif, image/jpeg, image/png, image/tiff formats.
    */
    'filetype'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "filetype",
            "baseName": "filetype",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DisputeEvidenceFile.attributeTypeMap;
    }
}

/**
* Type of the dispute evidence.
*/
export class DisputeEvidenceType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DisputeEvidenceType.attributeTypeMap;
    }
}

/**
* List of possible reasons why a cardholder might initiate a dispute with their bank.
*/
export class DisputeReason {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DisputeReason.attributeTypeMap;
    }
}

/**
* List of possible dispute states.
*/
export class DisputeState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DisputeState.attributeTypeMap;
    }
}

/**
* The payment the cardholder disputed.
*/
export class DisputedPayment {
    /**
    * Square-generated unique ID of the payment being disputed.
    */
    'paymentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DisputedPayment.attributeTypeMap;
    }
}

/**
* Determines item visibility in Ecom (Online Store) and Online Checkout.
*/
export class EcomVisibility {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return EcomVisibility.attributeTypeMap;
    }
}

/**
* An employee object that is used by the external API.
*/
export class Employee {
    /**
    * UUID for this object.
    */
    'id'?: string;
    /**
    * The employee's first name.
    */
    'firstName'?: string;
    /**
    * The employee's last name.
    */
    'lastName'?: string;
    /**
    * The employee's email address
    */
    'email'?: string;
    /**
    * The employee's phone number in E.164 format, i.e. \"+12125554250\"
    */
    'phoneNumber'?: string;
    /**
    * A list of location IDs where this employee has access to.
    */
    'locationIds'?: Array<string>;
    /**
    * Specifies the status of the employees being fetched. See [EmployeeStatus](#type-employeestatus) for possible values
    */
    'status'?: string;
    /**
    * Whether this employee is the owner of the merchant. Each merchant has one owner employee, and that employee has full authority over the account.
    */
    'isOwner'?: boolean;
    /**
    * A read-only timestamp in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "isOwner",
            "baseName": "is_owner",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Employee.attributeTypeMap;
    }
}

/**
* The status of the Employee being retrieved.
*/
export class EmployeeStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return EmployeeStatus.attributeTypeMap;
    }
}

/**
* The hourly wage rate that an employee will earn on a `Shift` for doing the job specified by the `title` property of this object. Deprecated at verison 2020-08-26. Use `TeamMemberWage` instead.
*/
export class EmployeeWage {
    /**
    * UUID for this object.
    */
    'id'?: string;
    /**
    * The `Employee` that this wage is assigned to.
    */
    'employeeId'?: string;
    /**
    * The job title that this wage relates to.
    */
    'title'?: string;
    /**
    * Can be a custom-set hourly wage or the calculated effective hourly wage based on annual wage and hours worked per week.
    */
    'hourlyRate'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "hourlyRate",
            "baseName": "hourly_rate",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return EmployeeWage.attributeTypeMap;
    }
}

/**
* Indicates which high-level category of error has occurred during a request to the Connect API.
*/
export class ErrorCategory {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ErrorCategory.attributeTypeMap;
    }
}

/**
* Indicates the specific error that occurred during a request to a Square API.
*/
export class ErrorCode {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ErrorCode.attributeTypeMap;
    }
}

/**
* Indicates which products matched by a CatalogPricingRule will be excluded if the pricing rule uses an exclude set.
*/
export class ExcludeStrategy {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExcludeStrategy.attributeTypeMap;
    }
}

/**
* A filter to select resources based on an exact field value. For any given value, the value can only be in one property. Depending on the field, either all properties can be set or only a subset will be available.  Refer to the documentation of the field.
*/
export class FilterValue {
    /**
    * A list of terms that must be present on the field of the resource.
    */
    'all'?: Array<string>;
    /**
    * A list of terms where at least one of them must be present on the field of the resource.
    */
    'any'?: Array<string>;
    /**
    * A list of terms that must not be present on the field the resource
    */
    'none'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "all",
            "baseName": "all",
            "type": "Array<string>"
        },
        {
            "name": "any",
            "baseName": "any",
            "type": "Array<string>"
        },
        {
            "name": "none",
            "baseName": "none",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FilterValue.attributeTypeMap;
    }
}

/**
* Request object for fetching a specific `BankAccount` by the object ID.
*/
export class GetBankAccountByV1IdRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetBankAccountByV1IdRequest.attributeTypeMap;
    }
}

/**
* Response object returned by GetBankAccountByV1Id.
*/
export class GetBankAccountByV1IdResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `BankAccount` object.
    */
    'bankAccount'?: BankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "bankAccount",
            "baseName": "bank_account",
            "type": "BankAccount"
        }    ];

    static getAttributeTypeMap() {
        return GetBankAccountByV1IdResponse.attributeTypeMap;
    }
}

/**
* Request object to fetch a specific `BankAccount` by the object ID.
*/
export class GetBankAccountRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetBankAccountRequest.attributeTypeMap;
    }
}

/**
* Response object returned by `GetBankAccount`.
*/
export class GetBankAccountResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `BankAccount` object.
    */
    'bankAccount'?: BankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "bankAccount",
            "baseName": "bank_account",
            "type": "BankAccount"
        }    ];

    static getAttributeTypeMap() {
        return GetBankAccountResponse.attributeTypeMap;
    }
}

/**
* A request to GET a `BreakType` by ID
*/
export class GetBreakTypeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetBreakTypeRequest.attributeTypeMap;
    }
}

/**
* The response to a request to get a `BreakType`. Contains the requested `BreakType` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class GetBreakTypeResponse {
    /**
    * The response object.
    */
    'breakType'?: BreakType;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "breakType",
            "baseName": "break_type",
            "type": "BreakType"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return GetBreakTypeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class GetDeviceCodeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetDeviceCodeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class GetDeviceCodeResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The queried DeviceCode.
    */
    'deviceCode'?: DeviceCode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "deviceCode",
            "baseName": "device_code",
            "type": "DeviceCode"
        }    ];

    static getAttributeTypeMap() {
        return GetDeviceCodeResponse.attributeTypeMap;
    }
}

/**
* A request to get an `EmployeeWage`
*/
export class GetEmployeeWageRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetEmployeeWageRequest.attributeTypeMap;
    }
}

/**
* A response to a request to get an `EmployeeWage`. Contains the requested `EmployeeWage` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class GetEmployeeWageResponse {
    /**
    * The requested `EmployeeWage` object.
    */
    'employeeWage'?: EmployeeWage;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employeeWage",
            "baseName": "employee_wage",
            "type": "EmployeeWage"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return GetEmployeeWageResponse.attributeTypeMap;
    }
}

/**
* Describes a `GetInvoice` request.
*/
export class GetInvoiceRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetInvoiceRequest.attributeTypeMap;
    }
}

/**
* Describes a `GetInvoice` response.
*/
export class GetInvoiceResponse {
    /**
    * The invoice requested.
    */
    'invoice'?: Invoice;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return GetInvoiceResponse.attributeTypeMap;
    }
}

/**
* Retrieves a specific `Refund` using the `refund_id`.
*/
export class GetPaymentRefundRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetPaymentRefundRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [GetRefund](#endpoint-refunds-getpaymentrefund) endpoint.  Note: if there are errors processing the request, the refund field may not be present, or it may be present in a FAILED state.
*/
export class GetPaymentRefundResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `PaymentRefund`.
    */
    'refund'?: PaymentRefund;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "refund",
            "baseName": "refund",
            "type": "PaymentRefund"
        }    ];

    static getAttributeTypeMap() {
        return GetPaymentRefundResponse.attributeTypeMap;
    }
}

/**
* Retrieve details for a specific Payment.
*/
export class GetPaymentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetPaymentRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [GetPayment](#endpoint-payments-getpayment) endpoint.
*/
export class GetPaymentResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `Payment`.
    */
    'payment'?: Payment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }    ];

    static getAttributeTypeMap() {
        return GetPaymentResponse.attributeTypeMap;
    }
}

/**
* A request to get a `Shift` by ID
*/
export class GetShiftRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetShiftRequest.attributeTypeMap;
    }
}

/**
* A response to request to get a `Shift`. Contains the requested `Shift` object. May contain a set of `Error` objects if the request resulted in errors.
*/
export class GetShiftResponse {
    /**
    * The requested `Shift`.
    */
    'shift'?: Shift;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shift",
            "baseName": "shift",
            "type": "Shift"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return GetShiftResponse.attributeTypeMap;
    }
}

/**
* A request to get an `TeamMemberWage`
*/
export class GetTeamMemberWageRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetTeamMemberWageRequest.attributeTypeMap;
    }
}

/**
* A response to a request to get a `TeamMemberWage`. Contains the requested `TeamMemberWage` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class GetTeamMemberWageResponse {
    /**
    * The requested `TeamMemberWage` object.
    */
    'teamMemberWage'?: TeamMemberWage;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberWage",
            "baseName": "team_member_wage",
            "type": "TeamMemberWage"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return GetTeamMemberWageResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class GetTerminalCheckoutRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetTerminalCheckoutRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class GetTerminalCheckoutResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `Checkout`
    */
    'checkout'?: TerminalCheckout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "TerminalCheckout"
        }    ];

    static getAttributeTypeMap() {
        return GetTerminalCheckoutResponse.attributeTypeMap;
    }
}

/**
* Represents a change in state or quantity of product inventory at a particular time and location.
*/
export class InventoryAdjustment {
    /**
    * A unique ID generated by Square for the `InventoryAdjustment`.
    */
    'id'?: string;
    /**
    * An optional ID provided by the application to tie the `InventoryAdjustment` to an external system.
    */
    'referenceId'?: string;
    /**
    * The `InventoryState` of the related quantity of items before the adjustment. See [InventoryState](#type-inventorystate) for possible values
    */
    'fromState'?: string;
    /**
    * The `InventoryState` of the related quantity of items after the adjustment. See [InventoryState](#type-inventorystate) for possible values
    */
    'toState'?: string;
    /**
    * The Square ID of the `Location` where the related quantity of items are being tracked.
    */
    'locationId'?: string;
    /**
    * The Square generated ID of the `CatalogObject` being tracked.
    */
    'catalogObjectId'?: string;
    /**
    * The `CatalogObjectType` of the `CatalogObject` being tracked. Tracking is only supported for the `ITEM_VARIATION` type.
    */
    'catalogObjectType'?: string;
    /**
    * The number of items affected by the adjustment as a decimal string. Can support up to 5 digits after the decimal point.
    */
    'quantity'?: string;
    /**
    * The read-only total price paid for goods associated with the adjustment. Present if and only if `to_state` is `SOLD`. Always non-negative.
    */
    'totalPriceMoney'?: Money;
    /**
    * A client-generated timestamp in RFC 3339 format that indicates when the adjustment took place. For write actions, the `occurred_at` timestamp cannot be older than 24 hours or in the future relative to the time of the request.
    */
    'occurredAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format that indicates when Square received the adjustment.
    */
    'createdAt'?: string;
    /**
    * Read-only information about the application that caused the inventory adjustment.
    */
    'source'?: SourceApplication;
    /**
    * The Square ID of the `Employee` responsible for the inventory adjustment.
    */
    'employeeId'?: string;
    /**
    * The read-only Square ID of the [Transaction][#type-transaction] that caused the adjustment. Only relevant for payment-related state transitions.
    */
    'transactionId'?: string;
    /**
    * The read-only Square ID of the [Refund][#type-refund] that caused the adjustment. Only relevant for refund-related state transitions.
    */
    'refundId'?: string;
    /**
    * The read-only Square ID of the purchase order that caused the adjustment. Only relevant for state transitions from the Square for Retail app.
    */
    'purchaseOrderId'?: string;
    /**
    * The read-only Square ID of the Square goods receipt that caused the adjustment. Only relevant for state transitions from the Square for Retail app.
    */
    'goodsReceiptId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "fromState",
            "baseName": "from_state",
            "type": "string"
        },
        {
            "name": "toState",
            "baseName": "to_state",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "catalogObjectType",
            "baseName": "catalog_object_type",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "totalPriceMoney",
            "baseName": "total_price_money",
            "type": "Money"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "SourceApplication"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "refundId",
            "baseName": "refund_id",
            "type": "string"
        },
        {
            "name": "purchaseOrderId",
            "baseName": "purchase_order_id",
            "type": "string"
        },
        {
            "name": "goodsReceiptId",
            "baseName": "goods_receipt_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InventoryAdjustment.attributeTypeMap;
    }
}

/**
* Indicates whether Square should alert the merchant when the inventory quantity of a CatalogItemVariation is low.
*/
export class InventoryAlertType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InventoryAlertType.attributeTypeMap;
    }
}

/**
* Represents a single physical count, inventory, adjustment, or transfer that is part of the history of inventory changes for a particular `CatalogObject`.
*/
export class InventoryChange {
    /**
    * Indicates how the inventory change was applied. See `InventoryChangeType` for all possible values. See [InventoryChangeType](#type-inventorychangetype) for possible values
    */
    'type'?: string;
    /**
    * Contains details about the physical count when `type` is `PHYSICAL_COUNT` and unset for all other types.
    */
    'physicalCount'?: InventoryPhysicalCount;
    /**
    * Contains details about the inventory adjustment when `type` is `ADJUSTMENT` and unset for all other types.
    */
    'adjustment'?: InventoryAdjustment;
    /**
    * Contains details about the inventory transfer when `type` is `TRANSFER` and unset for all other types.  _Note:_ An `InventoryTransfer` object is read-only and can only be present in a `RetrieveInventoryChangesResponse` and `BatchRetrieveInventoryChangesResponse` object.
    */
    'transfer'?: InventoryTransfer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "physicalCount",
            "baseName": "physical_count",
            "type": "InventoryPhysicalCount"
        },
        {
            "name": "adjustment",
            "baseName": "adjustment",
            "type": "InventoryAdjustment"
        },
        {
            "name": "transfer",
            "baseName": "transfer",
            "type": "InventoryTransfer"
        }    ];

    static getAttributeTypeMap() {
        return InventoryChange.attributeTypeMap;
    }
}

/**
* Indicates how the inventory change was applied to a tracked quantity of items.
*/
export class InventoryChangeType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InventoryChangeType.attributeTypeMap;
    }
}

/**
* Represents Square's estimated quantity of items in a particular state at a particular location based on the known history of physical counts and inventory adjustments.
*/
export class InventoryCount {
    /**
    * The Square generated ID of the `CatalogObject` being tracked.
    */
    'catalogObjectId'?: string;
    /**
    * The `CatalogObjectType` of the `CatalogObject` being tracked. Tracking is only supported for the `ITEM_VARIATION` type.
    */
    'catalogObjectType'?: string;
    /**
    * The current `InventoryState` for the related quantity of items. See [InventoryState](#type-inventorystate) for possible values
    */
    'state'?: string;
    /**
    * The Square ID of the `Location` where the related quantity of items are being tracked.
    */
    'locationId'?: string;
    /**
    * The number of items affected by the estimated count as a decimal string. Can support up to 5 digits after the decimal point.
    */
    'quantity'?: string;
    /**
    * A read-only timestamp in RFC 3339 format that indicates when Square received the most recent physical count or adjustment that had an affect on the estimated count.
    */
    'calculatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "catalogObjectType",
            "baseName": "catalog_object_type",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "calculatedAt",
            "baseName": "calculated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InventoryCount.attributeTypeMap;
    }
}

/**
* Represents the quantity of an item variation that is physically present at a specific location, verified by a seller or a seller's employee. For example, a physical count might come from an employee counting the item variations on hand or from syncing with an external system.
*/
export class InventoryPhysicalCount {
    /**
    * A unique ID generated by Square for the `InventoryPhysicalCount`.
    */
    'id'?: string;
    /**
    * An optional ID provided by the application to tie the `InventoryPhysicalCount` to an external system.
    */
    'referenceId'?: string;
    /**
    * The Square generated ID of the `CatalogObject` being tracked.
    */
    'catalogObjectId'?: string;
    /**
    * The `CatalogObjectType` of the `CatalogObject` being tracked. Tracking is only supported for the `ITEM_VARIATION` type.
    */
    'catalogObjectType'?: string;
    /**
    * The current `InventoryState` for the related quantity of items. See [InventoryState](#type-inventorystate) for possible values
    */
    'state'?: string;
    /**
    * The Square ID of the `Location` where the related quantity of items are being tracked.
    */
    'locationId'?: string;
    /**
    * The number of items affected by the physical count as a decimal string. Can support up to 5 digits after the decimal point.
    */
    'quantity'?: string;
    /**
    * Read-only information about the application that submitted the physical count.
    */
    'source'?: SourceApplication;
    /**
    * The Square ID of the `Employee` responsible for the physical count.
    */
    'employeeId'?: string;
    /**
    * A client-generated timestamp in RFC 3339 format that indicates when the physical count took place. For write actions, the `occurred_at` timestamp cannot be older than 24 hours or in the future relative to the time of the request.
    */
    'occurredAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format that indicates when Square received the physical count.
    */
    'createdAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "catalogObjectType",
            "baseName": "catalog_object_type",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "SourceApplication"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InventoryPhysicalCount.attributeTypeMap;
    }
}

/**
* Indicates the state of a tracked item quantity in the lifecycle of goods.
*/
export class InventoryState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InventoryState.attributeTypeMap;
    }
}

/**
* Represents the transfer of a quantity of product inventory at a particular time from one location to another.
*/
export class InventoryTransfer {
    /**
    * A unique ID generated by Square for the `InventoryTransfer`.
    */
    'id'?: string;
    /**
    * An optional ID provided by the application to tie the `InventoryTransfer` to an external system.
    */
    'referenceId'?: string;
    /**
    * The `InventoryState` for the quantity of items being transferred. See [InventoryState](#type-inventorystate) for possible values
    */
    'state'?: string;
    /**
    * The Square ID of the `Location` where the related quantity of items were tracked before the transfer.
    */
    'fromLocationId'?: string;
    /**
    * The Square ID of the `Location` where the related quantity of items were tracked after the transfer.
    */
    'toLocationId'?: string;
    /**
    * The Square generated ID of the `CatalogObject` being tracked.
    */
    'catalogObjectId'?: string;
    /**
    * The `CatalogObjectType` of the `CatalogObject` being tracked.Tracking is only supported for the `ITEM_VARIATION` type.
    */
    'catalogObjectType'?: string;
    /**
    * The number of items affected by the transfer as a decimal string. Can support up to 5 digits after the decimal point.
    */
    'quantity'?: string;
    /**
    * A client-generated timestamp in RFC 3339 format that indicates when the transfer took place. For write actions, the `occurred_at` timestamp cannot be older than 24 hours or in the future relative to the time of the request.
    */
    'occurredAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format that indicates when Square received the transfer request.
    */
    'createdAt'?: string;
    /**
    * Read-only information about the application that initiated the inventory transfer.
    */
    'source'?: SourceApplication;
    /**
    * The Square ID of the `Employee` responsible for the inventory transfer.
    */
    'employeeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "fromLocationId",
            "baseName": "from_location_id",
            "type": "string"
        },
        {
            "name": "toLocationId",
            "baseName": "to_location_id",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "catalogObjectType",
            "baseName": "catalog_object_type",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "SourceApplication"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InventoryTransfer.attributeTypeMap;
    }
}

/**
* Stores information about an invoice. You use the Invoices API to create and process invoices. For more information, see [Manage Invoices Using the Invoices API](/docs/invoices-api/overview).
*/
export class Invoice {
    /**
    * The Square-assigned ID of the invoice.
    */
    'id'?: string;
    /**
    * The version number, which is incremented each time an update is committed to the invoice.
    */
    'version'?: number;
    /**
    * The ID of the location that this invoice is associated with. This field is required when creating an invoice.
    */
    'locationId'?: string;
    /**
    * The ID of the `order` for which the invoice is created.  This order must be in the `OPEN` state and must belong to the `location_id` specified for this invoice. This field is required when creating an invoice.
    */
    'orderId'?: string;
    /**
    * The customer who gets the invoice. Square uses the contact information to deliver the invoice. This field is required when creating an invoice.
    */
    'primaryRecipient'?: InvoiceRecipient;
    /**
    * An array of `InvoicePaymentRequest` objects. Each object defines a payment request in an invoice payment schedule. It provides information such as when and how Square processes payments. You can specify maximum of nine payment requests. All all the payment requests must specify the same `request_method`.  This field is required when creating an invoice.
    */
    'paymentRequests'?: Array<InvoicePaymentRequest>;
    /**
    * A user-friendly invoice number. The value is unique within a location. If not provided when creating an invoice, Square assigns a value. It increments from 1 and padded with zeros making it 7 characters long for example, 0000001, 0000002.
    */
    'invoiceNumber'?: string;
    /**
    * The title of the invoice.
    */
    'title'?: string;
    /**
    * The description of the invoice. This is visible the customer receiving the invoice.
    */
    'description'?: string;
    /**
    * The timestamp when the invoice is scheduled for processing, in RFC 3339 format. At the specified time, depending on the `request_method`, Square sends the invoice to the customer's email address or charge the customer's card on file.  If the field is not set, Square processes the invoice immediately after publication.
    */
    'scheduledAt'?: string;
    /**
    * The URL of the Square-hosted invoice page. After you publish the invoice using the `PublishInvoice` endpoint, Square hosts the invoice page and returns the page URL in the response.
    */
    'publicUrl'?: string;
    /**
    * The current amount due for the invoice. In addition to the amount due on the next payment request, this also includes any overdue payment amounts.
    */
    'nextPaymentAmountMoney'?: Money;
    /**
    * The status of the invoice. See [InvoiceStatus](#type-invoicestatus) for possible values
    */
    'status'?: string;
    /**
    * The time zone of the date values (for example, `due_date`) specified in the invoice.
    */
    'timezone'?: string;
    /**
    * The timestamp when the invoice was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timestamp when the invoice was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "primaryRecipient",
            "baseName": "primary_recipient",
            "type": "InvoiceRecipient"
        },
        {
            "name": "paymentRequests",
            "baseName": "payment_requests",
            "type": "Array<InvoicePaymentRequest>"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduled_at",
            "type": "string"
        },
        {
            "name": "publicUrl",
            "baseName": "public_url",
            "type": "string"
        },
        {
            "name": "nextPaymentAmountMoney",
            "baseName": "next_payment_amount_money",
            "type": "Money"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoice.attributeTypeMap;
    }
}

/**
* Describes query filters to apply.
*/
export class InvoiceFilter {
    /**
    * Limits the search to the specified locations. A location is required.  In the current implementation, only one location can be specified.
    */
    'locationIds': Array<string>;
    /**
    * Limits the search to the specified customers, within the specified locations.  Specifying a customer is optional. In the current implementation,  a maximum of one customer can be specified.
    */
    'customerIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "customerIds",
            "baseName": "customer_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceFilter.attributeTypeMap;
    }
}

/**
* Describes a payment request reminder (automatic notification) that Square sends to the customer. You configure a reminder relative to the payment request `due_date`.
*/
export class InvoicePaymentReminder {
    /**
    * A Square-assigned ID that uniquely identifies the reminder within the `InvoicePaymentRequest`.
    */
    'uid'?: string;
    /**
    * The number of days before (a negative number) or after (a positive number) the payment request `due_date` when the reminder is sent. For example, -3 indicates that the reminder should be sent 3 days before the payment request `due_date`.
    */
    'relativeScheduledDays'?: number;
    /**
    * The reminder message.
    */
    'message'?: string;
    /**
    * The status of the reminder. See [InvoicePaymentReminderStatus](#type-invoicepaymentreminderstatus) for possible values
    */
    'status'?: string;
    /**
    * If sent, the timestamp when the reminder was sent, in RFC 3339 format.
    */
    'sentAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "relativeScheduledDays",
            "baseName": "relative_scheduled_days",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "sentAt",
            "baseName": "sent_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicePaymentReminder.attributeTypeMap;
    }
}

/**
* The status of a payment request reminder.
*/
export class InvoicePaymentReminderStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InvoicePaymentReminderStatus.attributeTypeMap;
    }
}

/**
* Describes a specific payment request in an invoice. You can have  up to nine payment requests for an invoice.
*/
export class InvoicePaymentRequest {
    /**
    * The Square-generated ID of the payment request in an `invoice`.
    */
    'uid'?: string;
    /**
    * Indicates how Square processes the payment request. See [InvoiceRequestMethod](#type-invoicerequestmethod) for possible values
    */
    'requestMethod'?: string;
    /**
    * Identifies the payment request type. This type defines how the payment request amount is determined. See [InvoiceRequestType](#type-invoicerequesttype) for possible values
    */
    'requestType'?: string;
    /**
    * The due date (in the invoice location's time zone) for the payment request.  After this date, the invoice becomes overdue.
    */
    'dueDate'?: string;
    /**
    * If the payment request specifies `DEPOSIT` or `INSTALLMENT` as the  `request_type`,  this indicates the request amount. You cannot specify this when `request_type` is `BALANCE` or when the  payment request includes the `percentage_requested` field.
    */
    'fixedAmountRequestedMoney'?: Money;
    /**
    * Specifies the amount for the payment request in percentage:  - When the payment `request_type` is `DEPOSIT`, it is the percentage of the order total amount. - When the payment `request_type` is `INSTALLMENT`, it is the percentage of the order total less  the deposit, if requested. The sum of the `percentage_requested` in all installment  payment requests must be equal to 100.  You cannot specify this when the payment `request_type` is `BALANCE` or when the  payment request specifies the `fixed_amount_requested_money` field.
    */
    'percentageRequested'?: string;
    /**
    * If set to true, the Square-hosted invoice page (the `public_url` field of the invoice)  provides a place for the customer to pay a tip.   This field is allowed only on the final payment request   and the payment `request_type` must be `BALANCE` or `INSTALLMENT`.
    */
    'tippingEnabled'?: boolean;
    /**
    * If the request method is `CHARGE_CARD_ON_FILE`, this field provides the  card to charge.
    */
    'cardId'?: string;
    /**
    * A list of one or more reminders to send for the payment request.
    */
    'reminders'?: Array<InvoicePaymentReminder>;
    /**
    * The payment request amount, computed using the order amount and information from the various payment request fields (`invoice_request_type`,  `fixed_amount_requested_money`, and `percentage_requested`).
    */
    'computedAmountMoney'?: Money;
    /**
    * The amount of money already paid for the specific payment request.  This amount might include a rounding adjustment if the most recent invoice payment  was in cash in a currency that rounds cash payments (such as, `CAD` or `AUD`).
    */
    'totalCompletedAmountMoney'?: Money;
    /**
    * If the most recent payment was a cash payment  in a currency that rounds cash payments (such as, `CAD` or `AUD`) and the payment  is rounded from `computed_amount_money` in the payment request, then this  field specifies the rounding adjustment applied. This amount  might be negative.
    */
    'roundingAdjustmentIncludedMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "requestMethod",
            "baseName": "request_method",
            "type": "string"
        },
        {
            "name": "requestType",
            "baseName": "request_type",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "fixedAmountRequestedMoney",
            "baseName": "fixed_amount_requested_money",
            "type": "Money"
        },
        {
            "name": "percentageRequested",
            "baseName": "percentage_requested",
            "type": "string"
        },
        {
            "name": "tippingEnabled",
            "baseName": "tipping_enabled",
            "type": "boolean"
        },
        {
            "name": "cardId",
            "baseName": "card_id",
            "type": "string"
        },
        {
            "name": "reminders",
            "baseName": "reminders",
            "type": "Array<InvoicePaymentReminder>"
        },
        {
            "name": "computedAmountMoney",
            "baseName": "computed_amount_money",
            "type": "Money"
        },
        {
            "name": "totalCompletedAmountMoney",
            "baseName": "total_completed_amount_money",
            "type": "Money"
        },
        {
            "name": "roundingAdjustmentIncludedMoney",
            "baseName": "rounding_adjustment_included_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return InvoicePaymentRequest.attributeTypeMap;
    }
}

/**
* Describes query criteria for searching invoices.
*/
export class InvoiceQuery {
    /**
    * Query filters to apply in  searching invoices.  For more information, see [Retrieve invoices](https://developer.squareup.com/docs/docs/invoices-api/overview#retrieve-invoices).
    */
    'filter': InvoiceFilter;
    /**
    * Describes the sort order for the search result.
    */
    'sort'?: InvoiceSort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "InvoiceFilter"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "InvoiceSort"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceQuery.attributeTypeMap;
    }
}

/**
* Provides customer data that Square uses to deliver an invoice.
*/
export class InvoiceRecipient {
    /**
    * The ID of the customer. This is the customer profile ID that  you provide when creating a draft invoice.
    */
    'customerId'?: string;
    /**
    * The recipient's given (that is, first) name.
    */
    'givenName'?: string;
    /**
    * The recipient's family (that is, last) name.
    */
    'familyName'?: string;
    /**
    * The recipient's email address.
    */
    'emailAddress'?: string;
    /**
    * The recipient's physical address.
    */
    'address'?: Address;
    /**
    * The recipient's phone number.
    */
    'phoneNumber'?: string;
    /**
    * The name of the recipient's company.
    */
    'companyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "givenName",
            "baseName": "given_name",
            "type": "string"
        },
        {
            "name": "familyName",
            "baseName": "family_name",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceRecipient.attributeTypeMap;
    }
}

/**
* Specifies the action for Square to take for processing the invoice. For example,  email the invoice, charge a customer's card on file, or do nothing.
*/
export class InvoiceRequestMethod {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InvoiceRequestMethod.attributeTypeMap;
    }
}

/**
* Identifies the type of the payment request. For more information,  see [Payment request](TBD).
*/
export class InvoiceRequestType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InvoiceRequestType.attributeTypeMap;
    }
}

/**
* Identifies the  sort field and sort order.
*/
export class InvoiceSort {
    /**
    * The field to sort on. See [InvoiceSortField](#type-invoicesortfield) for possible values
    */
    'field': string;
    /**
    * The order to use for sorting the results. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceSort.attributeTypeMap;
    }
}

/**
* Field to use for sorting.
*/
export class InvoiceSortField {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InvoiceSortField.attributeTypeMap;
    }
}

/**
* Indicates the status of an invoice.
*/
export class InvoiceStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InvoiceStatus.attributeTypeMap;
    }
}

/**
* Price and inventory alerting overrides for a `CatalogItemVariation` at a specific `Location`.
*/
export class ItemVariationLocationOverrides {
    /**
    * The ID of the `Location`.
    */
    'locationId'?: string;
    /**
    * The price of the `CatalogItemVariation` at the given `Location`, or blank for variable pricing.
    */
    'priceMoney'?: Money;
    /**
    * The pricing type (fixed or variable) for the `CatalogItemVariation` at the given `Location`. See [CatalogPricingType](#type-catalogpricingtype) for possible values
    */
    'pricingType'?: string;
    /**
    * If `true`, inventory tracking is active for the `CatalogItemVariation` at this `Location`.
    */
    'trackInventory'?: boolean;
    /**
    * Indicates whether the `CatalogItemVariation` displays an alert when its inventory quantity is less than or equal to its `inventory_alert_threshold`. See [InventoryAlertType](#type-inventoryalerttype) for possible values
    */
    'inventoryAlertType'?: string;
    /**
    * If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type` is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.  This value is always an integer.
    */
    'inventoryAlertThreshold'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "priceMoney",
            "baseName": "price_money",
            "type": "Money"
        },
        {
            "name": "pricingType",
            "baseName": "pricing_type",
            "type": "string"
        },
        {
            "name": "trackInventory",
            "baseName": "track_inventory",
            "type": "boolean"
        },
        {
            "name": "inventoryAlertType",
            "baseName": "inventory_alert_type",
            "type": "string"
        },
        {
            "name": "inventoryAlertThreshold",
            "baseName": "inventory_alert_threshold",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemVariationLocationOverrides.attributeTypeMap;
    }
}

/**
* An object describing a job that a team member is assigned to.
*/
export class JobAssignment {
    /**
    * The title of the job.
    */
    'jobTitle': string;
    /**
    * The current pay type for the job assignment used to calculate the pay amount in a pay period. See [JobAssignmentPayType](#type-jobassignmentpaytype) for possible values
    */
    'payType': string;
    /**
    * The hourly pay rate of the job.
    */
    'hourlyRate'?: Money;
    /**
    * The total pay amount for a 12 month period on the job. Set if the job `PayType` is `SALARY`.
    */
    'annualRate'?: Money;
    /**
    * The planned hours per week for the job. Set if the job `PayType` is `SALARY`.
    */
    'weeklyHours'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jobTitle",
            "baseName": "job_title",
            "type": "string"
        },
        {
            "name": "payType",
            "baseName": "pay_type",
            "type": "string"
        },
        {
            "name": "hourlyRate",
            "baseName": "hourly_rate",
            "type": "Money"
        },
        {
            "name": "annualRate",
            "baseName": "annual_rate",
            "type": "Money"
        },
        {
            "name": "weeklyHours",
            "baseName": "weekly_hours",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobAssignment.attributeTypeMap;
    }
}

/**
* Enumerates the possible pay types that a job can be assigned.
*/
export class JobAssignmentPayType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return JobAssignmentPayType.attributeTypeMap;
    }
}

/**
* Request object for fetching all `BankAccount` objects linked to a account.
*/
export class ListBankAccountsRequest {
    /**
    * The pagination cursor returned by a previous call to this endpoint. Use it in the next `ListBankAccounts` request to retrieve the next set  of results.  See the [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;
    /**
    * Upper limit on the number of bank accounts to return in the response.  Currently, 1000 is the largest supported limit. You can specify a limit  of up to 1000 bank accounts. This is also the default limit.
    */
    'limit'?: number;
    /**
    * Location ID. You can specify this optional filter  to retrieve only the linked bank accounts belonging to a specific location.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListBankAccountsRequest.attributeTypeMap;
    }
}

/**
* Response object returned by ListBankAccounts.
*/
export class ListBankAccountsResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * List of BankAccounts associated with this account.
    */
    'bankAccounts'?: Array<BankAccount>;
    /**
    * When a response is truncated, it includes a cursor that you can  use in a subsequent request to fetch next set of bank accounts. If empty, this is the final response.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "bankAccounts",
            "baseName": "bank_accounts",
            "type": "Array<BankAccount>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListBankAccountsResponse.attributeTypeMap;
    }
}

/**
* A request for a filtered set of `BreakType` objects
*/
export class ListBreakTypesRequest {
    /**
    * Filter Break Types returned to only those that are associated with the specified location.
    */
    'locationId'?: string;
    /**
    * Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
    */
    'limit'?: number;
    /**
    * Pointer to the next page of Break Type results to fetch.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListBreakTypesRequest.attributeTypeMap;
    }
}

/**
* The response to a request for a set of `BreakTypes`. Contains the requested `BreakType` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class ListBreakTypesResponse {
    /**
    *  A page of `BreakType` results.
    */
    'breakTypes'?: Array<BreakType>;
    /**
    * Value supplied in the subsequent request to fetch the next next page of Break Type results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "breakTypes",
            "baseName": "break_types",
            "type": "Array<BreakType>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListBreakTypesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCashDrawerShiftEventsRequest {
    /**
    * The ID of the location to list cash drawer shifts for.
    */
    'locationId': string;
    /**
    * Number of resources to be returned in a page of results (200 by default, 1000 max).
    */
    'limit'?: number;
    /**
    * Opaque cursor for fetching the next page of results.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCashDrawerShiftEventsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCashDrawerShiftEventsResponse {
    /**
    * All of the events (payments, refunds, etc.) for a cash drawer during the shift.
    */
    'events'?: Array<CashDrawerShiftEvent>;
    /**
    * Opaque cursor for fetching the next page. Cursor is not present in the last page of results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<CashDrawerShiftEvent>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListCashDrawerShiftEventsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCashDrawerShiftsRequest {
    /**
    * The ID of the location to query for a list of cash drawer shifts.
    */
    'locationId': string;
    /**
    * The order in which cash drawer shifts are listed in the response, based on their opened_at field. Default value: ASC See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;
    /**
    * The inclusive start time of the query on opened_at, in ISO 8601 format.
    */
    'beginTime'?: string;
    /**
    * The exclusive end date of the query on opened_at, in ISO 8601 format.
    */
    'endTime'?: string;
    /**
    * Number of cash drawer shift events in a page of results (200 by default, 1000 max).
    */
    'limit'?: number;
    /**
    * Opaque cursor for fetching the next page of results.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCashDrawerShiftsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCashDrawerShiftsResponse {
    /**
    * A collection of CashDrawerShiftSummary objects for shifts that match the query.
    */
    'items'?: Array<CashDrawerShiftSummary>;
    /**
    * Opaque cursor for fetching the next page of results. Cursor is not present in the last page of results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CashDrawerShiftSummary>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListCashDrawerShiftsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCatalogRequest {
    /**
    * The pagination cursor returned in the previous response. Leave unset for an initial request. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * An optional case-insensitive, comma-separated list of object types to retrieve, for example `ITEM,ITEM_VARIATION,CATEGORY,IMAGE`.  The legal values are taken from the CatalogObjectType enum: `ITEM`, `ITEM_VARIATION`, `CATEGORY`, `DISCOUNT`, `TAX`, `MODIFIER`, `MODIFIER_LIST`, or `IMAGE`.
    */
    'types'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCatalogRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ListCatalogResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * The CatalogObjects returned.
    */
    'objects'?: Array<CatalogObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "objects",
            "baseName": "objects",
            "type": "Array<CatalogObject>"
        }    ];

    static getAttributeTypeMap() {
        return ListCatalogResponse.attributeTypeMap;
    }
}

/**
* Defines the query parameters that can be provided in a request to the [ListCustomerGroups](#endpoint-listcustomergroups) endpoint.
*/
export class ListCustomerGroupsRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomerGroupsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [ListCustomerGroups](#endpoint-listcustomergroups) endpoint.  One of `errors` or `groups` is present in a given response (never both).
*/
export class ListCustomerGroupsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * A list of customer groups belonging to the current merchant.
    */
    'groups'?: Array<CustomerGroup>;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint. This value is present only if the request succeeded and additional results are available.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<CustomerGroup>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomerGroupsResponse.attributeTypeMap;
    }
}

/**
* Defines the valid parameters for requests to __ListCustomerSegments__.
*/
export class ListCustomerSegmentsRequest {
    /**
    * A pagination cursor returned by previous calls to __ListCustomerSegments__. Used to retrieve the next set of query results.  See the [Pagination guide](https://developer.squareup.com/docs/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomerSegmentsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields included in the response body for requests to __ListCustomerSegments__.  One of `errors` or `segments` is present in a given response (never both).
*/
export class ListCustomerSegmentsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The list of customer segments belonging to the associated Square account.
    */
    'segments'?: Array<CustomerSegment>;
    /**
    * A pagination cursor to be used in subsequent calls to __ListCustomerSegments__ to retrieve the next set of query results. Only present only if the request succeeded and additional results are available.  See the [Pagination guide](https://developer.squareup.com/docs/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "segments",
            "baseName": "segments",
            "type": "Array<CustomerSegment>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomerSegmentsResponse.attributeTypeMap;
    }
}

/**
* Defines the query parameters that can be provided in a request to the ListCustomers endpoint.
*/
export class ListCustomersRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * Indicates how Customers should be sorted.  Default: `DEFAULT`. See [CustomerSortField](#type-customersortfield) for possible values
    */
    'sortField'?: string;
    /**
    * Indicates whether Customers should be sorted in ascending (`ASC`) or descending (`DESC`) order.  Default: `ASC`. See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "sortField",
            "baseName": "sort_field",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomersRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the ListCustomers endpoint.  One of `errors` or `customers` is present in a given response (never both).
*/
export class ListCustomersResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * An array of `Customer` objects that match the provided query.
    */
    'customers'?: Array<Customer>;
    /**
    * A pagination cursor to retrieve the next set of results for the original query. Only present if the request succeeded and additional results are available.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<Customer>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListCustomersResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ListDeviceCodesRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;
    /**
    * If specified, only returns DeviceCodes of the specified location. Returns DeviceCodes of all locations if empty.
    */
    'locationId'?: string;
    /**
    * If specified, only returns DeviceCodes targeting the specified product type. Returns DeviceCodes of all product types if empty. See [ProductType](#type-producttype) for possible values
    */
    'productType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "productType",
            "baseName": "product_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListDeviceCodesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ListDeviceCodesResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The queried DeviceCode.
    */
    'deviceCodes'?: Array<DeviceCode>;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint. This value is present only if the request succeeded and additional results are available.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "deviceCodes",
            "baseName": "device_codes",
            "type": "Array<DeviceCode>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListDeviceCodesResponse.attributeTypeMap;
    }
}

/**
* Defines parameters for a ListDisputeEvidence request.
*/
export class ListDisputeEvidenceRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ListDisputeEvidenceRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a ListDisputeEvidence response.
*/
export class ListDisputeEvidenceResponse {
    /**
    * The list of evidence previously uploaded to the specified dispute.
    */
    'evidence'?: Array<DisputeEvidence>;
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "evidence",
            "baseName": "evidence",
            "type": "Array<DisputeEvidence>"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListDisputeEvidenceResponse.attributeTypeMap;
    }
}

/**
* Defines request parameters for the ListDisputes endpoint.
*/
export class ListDisputesRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
    */
    'cursor'?: string;
    /**
    * The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not `INQUIRY_CLOSED`, `WON`, or `LOST`). See [DisputeState](#type-disputestate) for possible values
    */
    'states'?: Array<string>;
    /**
    * The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not `INQUIRY_CLOSED`, `WON`, or  `LOST`) associated with all locations.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<string>"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListDisputesRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a ListDisputes response.
*/
export class ListDisputesResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The list of Disputes.
    */
    'disputes'?: Array<Dispute>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "disputes",
            "baseName": "disputes",
            "type": "Array<Dispute>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListDisputesResponse.attributeTypeMap;
    }
}

/**
* A request for a set of `EmployeeWage` objects
*/
export class ListEmployeeWagesRequest {
    /**
    * Filter wages returned to only those that are associated with the specified employee.
    */
    'employeeId'?: string;
    /**
    * Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
    */
    'limit'?: number;
    /**
    * Pointer to the next page of Employee Wage results to fetch.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListEmployeeWagesRequest.attributeTypeMap;
    }
}

/**
* The response to a request for a set of `EmployeeWage` objects. Contains  a set of `EmployeeWage`.
*/
export class ListEmployeeWagesResponse {
    /**
    * A page of Employee Wage results.
    */
    'employeeWages'?: Array<EmployeeWage>;
    /**
    * Value supplied in the subsequent request to fetch the next next page of Employee Wage results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employeeWages",
            "baseName": "employee_wages",
            "type": "Array<EmployeeWage>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListEmployeeWagesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class ListEmployeesRequest {
    /**
    * 
    */
    'locationId'?: string;
    /**
    * Specifies the EmployeeStatus to filter the employee by. See [EmployeeStatus](#type-employeestatus) for possible values
    */
    'status'?: string;
    /**
    * The number of employees to be returned on each page.
    */
    'limit'?: number;
    /**
    * The token required to retrieve the specified page of results.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListEmployeesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ListEmployeesResponse {
    /**
    * 
    */
    'employees'?: Array<Employee>;
    /**
    * The token to be used to retrieve the next page of results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employees",
            "baseName": "employees",
            "type": "Array<Employee>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListEmployeesResponse.attributeTypeMap;
    }
}

/**
* Describes a `ListInvoice` request.
*/
export class ListInvoicesRequest {
    /**
    * The ID of the location for which to list invoices.
    */
    'locationId': string;
    /**
    * A pagination cursor returned by a previous call to this endpoint.  Provide this cursor to retrieve the next set of results for your original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;
    /**
    * The maximum number of invoices to return (200 is the maximum `limit`).  If not provided, the server  uses a default limit of 100 invoices.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ListInvoicesRequest.attributeTypeMap;
    }
}

/**
* Describes a `ListInvoice` response.
*/
export class ListInvoicesResponse {
    /**
    * The invoices retrieved.
    */
    'invoices'?: Array<Invoice>;
    /**
    * When a response is truncated, it includes a cursor that you can use in a  subsequent request to fetch the next set of invoices. If empty, this is the final  response.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoices",
            "baseName": "invoices",
            "type": "Array<Invoice>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListInvoicesResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the __ListLocations__ endpoint.
*/
export class ListLocationsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ListLocationsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the __ListLocations__ endpoint.  One of `errors` or `locations` is present in a given response (never both).
*/
export class ListLocationsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The business locations.
    */
    'locations'?: Array<Location>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "locations",
            "baseName": "locations",
            "type": "Array<Location>"
        }    ];

    static getAttributeTypeMap() {
        return ListLocationsResponse.attributeTypeMap;
    }
}

/**
* A request to list `LoyaltyProgram`.
*/
export class ListLoyaltyProgramsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ListLoyaltyProgramsRequest.attributeTypeMap;
    }
}

/**
* A response that contains all loyalty programs.
*/
export class ListLoyaltyProgramsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * A list of `LoyaltyProgram` for the merchant.
    */
    'programs'?: Array<LoyaltyProgram>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "programs",
            "baseName": "programs",
            "type": "Array<LoyaltyProgram>"
        }    ];

    static getAttributeTypeMap() {
        return ListLoyaltyProgramsResponse.attributeTypeMap;
    }
}

/**
* Request object for the [ListMerchant](#endpoint-listmerchant) endpoint.
*/
export class ListMerchantsRequest {
    /**
    * The cursor generated by the previous response.
    */
    'cursor'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ListMerchantsRequest.attributeTypeMap;
    }
}

/**
* The response object returned by the [ListMerchant](#endpoint-listmerchant) endpoint.
*/
export class ListMerchantsResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `Merchant` entities.
    */
    'merchant'?: Array<Merchant>;
    /**
    * If the  response is truncated, the cursor to use in next  request to fetch next set of objects.
    */
    'cursor'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "Array<Merchant>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ListMerchantsResponse.attributeTypeMap;
    }
}

/**
* Retrieves a list of refunds for the account making the request.  Max results per page: 100
*/
export class ListPaymentRefundsRequest {
    /**
    * Timestamp for the beginning of the requested reporting period, in RFC 3339 format.  Default: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * Timestamp for the end of the requested reporting period, in RFC 3339 format.  Default: The current time.
    */
    'endTime'?: string;
    /**
    * The order in which results are listed. - `ASC` - oldest to newest - `DESC` - newest to oldest (default).
    */
    'sortOrder'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * Limit results to the location supplied. By default, results are returned for all locations associated with the merchant.
    */
    'locationId'?: string;
    /**
    * If provided, only refunds with the given status are returned. For a list of refund status values, see `PaymentRefund`.  Default: If omitted refunds are returned regardless of status.
    */
    'status'?: string;
    /**
    * If provided, only refunds with the given source type are returned. - `CARD` - List refunds only for payments where card was specified as payment source.  Default: If omitted refunds are returned regardless of source type.
    */
    'sourceType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "sourceType",
            "baseName": "source_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListPaymentRefundsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [ListPaymentRefunds](#endpoint-refunds-listpaymentrefunds) endpoint.  One of `errors` or `refunds` is present in a given response (never both).
*/
export class ListPaymentRefundsResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The list of requested refunds.
    */
    'refunds'?: Array<PaymentRefund>;
    /**
    * The pagination cursor to be used in a subsequent request. If empty, this is the final response.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<PaymentRefund>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListPaymentRefundsResponse.attributeTypeMap;
    }
}

/**
* Retrieves a list of payments taken by the account making the request.  Max results per page: 100
*/
export class ListPaymentsRequest {
    /**
    * Timestamp for the beginning of the reporting period, in RFC 3339 format. Inclusive. Default: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * Timestamp for the end of the requested reporting period, in RFC 3339 format.  Default: The current time.
    */
    'endTime'?: string;
    /**
    * The order in which results are listed. - `ASC` - oldest to newest - `DESC` - newest to oldest (default).
    */
    'sortOrder'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * Limit results to the location supplied. By default, results are returned for all locations associated with the merchant.
    */
    'locationId'?: string;
    /**
    * The exact amount in the total_money for a `Payment`.
    */
    'total'?: number;
    /**
    * The last 4 digits of `Payment` card.
    */
    'last4'?: string;
    /**
    * The brand of `Payment` card. For example, `VISA`
    */
    'cardBrand'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "last4",
            "baseName": "last_4",
            "type": "string"
        },
        {
            "name": "cardBrand",
            "baseName": "card_brand",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListPaymentsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [ListPayments](#endpoint-payments-listpayments) endpoint.
*/
export class ListPaymentsResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested list of `Payment`s.
    */
    'payments'?: Array<Payment>;
    /**
    * The pagination cursor to be used in a subsequent request. If empty, this is the final response.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<Payment>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListPaymentsResponse.attributeTypeMap;
    }
}

/**
* Defines the query parameters that can be included in a request to the [ListRefunds](#endpoint-listrefunds) endpoint.  Deprecated - recommend using [SearchOrders](#endpoint-orders-searchorders)
*/
export class ListRefundsRequest {
    /**
    * The beginning of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * The end of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time.
    */
    'endTime'?: string;
    /**
    * The order in which results are listed in the response (`ASC` for oldest first, `DESC` for newest first).  Default value: `DESC` See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListRefundsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [ListRefunds](#endpoint-listrefunds) endpoint.  One of `errors` or `refunds` is present in a given response (never both).
*/
export class ListRefundsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * An array of refunds that match your query.
    */
    'refunds'?: Array<Refund>;
    /**
    * A pagination cursor for retrieving the next set of results, if any remain. Provide this value as the `cursor` parameter in a subsequent request to this endpoint.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<Refund>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListRefundsResponse.attributeTypeMap;
    }
}

/**
* Defines parameters in a  [ListSubscriptionEvents](#endpoint-subscriptions-listsubscriptionevents) endpoint request.
*/
export class ListSubscriptionEventsRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;
    /**
    * The upper limit on the number of subscription events to return  in the response.   Default: `200`
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ListSubscriptionEventsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response from the [ListSubscriptionEvents](#endpoint-subscriptions-listsubscriptionevents) endpoint.
*/
export class ListSubscriptionEventsResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The `SubscriptionEvents` retrieved.
    */
    'subscriptionEvents'?: Array<SubscriptionEvent>;
    /**
    * When a response is truncated, it includes a cursor that you can  use in a subsequent request to fetch the next set of events.  If empty, this is the final response.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscriptionEvents",
            "baseName": "subscription_events",
            "type": "Array<SubscriptionEvent>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListSubscriptionEventsResponse.attributeTypeMap;
    }
}

/**
* A request for a set of `TeamMemberWage` objects
*/
export class ListTeamMemberWagesRequest {
    /**
    * Filter wages returned to only those that are associated with the specified team member.
    */
    'teamMemberId'?: string;
    /**
    * Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
    */
    'limit'?: number;
    /**
    * Pointer to the next page of Employee Wage results to fetch.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberId",
            "baseName": "team_member_id",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListTeamMemberWagesRequest.attributeTypeMap;
    }
}

/**
* The response to a request for a set of `TeamMemberWage` objects. Contains a set of `TeamMemberWage`.
*/
export class ListTeamMemberWagesResponse {
    /**
    * A page of Team Member Wage results.
    */
    'teamMemberWages'?: Array<TeamMemberWage>;
    /**
    * Value supplied in the subsequent request to fetch the next next page of Team Member Wage results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberWages",
            "baseName": "team_member_wages",
            "type": "Array<TeamMemberWage>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListTeamMemberWagesResponse.attributeTypeMap;
    }
}

/**
* Defines the query parameters that can be included in a request to the [ListTransactions](#endpoint-listtransactions) endpoint.  Deprecated - recommend using [SearchOrders](#endpoint-orders-searchorders)
*/
export class ListTransactionsRequest {
    /**
    * The beginning of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * The end of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time.
    */
    'endTime'?: string;
    /**
    * The order in which results are listed in the response (`ASC` for oldest first, `DESC` for newest first).  Default value: `DESC` See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListTransactionsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [ListTransactions](#endpoint-listtransactions) endpoint.  One of `errors` or `transactions` is present in a given response (never both).
*/
export class ListTransactionsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * An array of transactions that match your query.
    */
    'transactions'?: Array<Transaction>;
    /**
    * A pagination cursor for retrieving the next set of results, if any remain. Provide this value as the `cursor` parameter in a subsequent request to this endpoint.  See [Paginating results](#paginatingresults) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<Transaction>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListTransactionsResponse.attributeTypeMap;
    }
}

/**
* A request for a set of `WorkweekConfig` objects
*/
export class ListWorkweekConfigsRequest {
    /**
    * Maximum number of Workweek Configs to return per page.
    */
    'limit'?: number;
    /**
    * Pointer to the next page of Workweek Config results to fetch.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListWorkweekConfigsRequest.attributeTypeMap;
    }
}

/**
* The response to a request for a set of `WorkweekConfig` objects. Contains the requested `WorkweekConfig` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class ListWorkweekConfigsResponse {
    /**
    * A page of Employee Wage results.
    */
    'workweekConfigs'?: Array<WorkweekConfig>;
    /**
    * Value supplied in the subsequent request to fetch the next page of Employee Wage results.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "workweekConfigs",
            "baseName": "workweek_configs",
            "type": "Array<WorkweekConfig>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return ListWorkweekConfigsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class Location {
    /**
    * The Square-issued ID of the location.
    */
    'id'?: string;
    /**
    * The name of the location. This information appears in the dashboard as the nickname.
    */
    'name'?: string;
    /**
    * The physical address of the location.
    */
    'address'?: Address;
    /**
    * The [IANA Timezone](https://www.iana.org/time-zones) identifier for the timezone of the location.
    */
    'timezone'?: string;
    /**
    * The Square features that are enabled for the location. See `LocationCapability` for possible values. See [LocationCapability](#type-locationcapability) for possible values
    */
    'capabilities'?: Array<string>;
    /**
    * The status of the location, either active or inactive. See [LocationStatus](#type-locationstatus) for possible values
    */
    'status'?: string;
    /**
    * The time when the location was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The ID of the merchant that owns the location.
    */
    'merchantId'?: string;
    /**
    * The country of the location, in ISO 3166-1-alpha-2 format.  See `Country` for possible values. See [Country](#type-country) for possible values
    */
    'country'?: string;
    /**
    * The language associated with the location, in [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A).
    */
    'languageCode'?: string;
    /**
    * The currency used for all transactions at this location, in ISO 4217 format. See `Currency` for possible values. See [Currency](#type-currency) for possible values
    */
    'currency'?: string;
    /**
    * The phone number of the location in human readable format.
    */
    'phoneNumber'?: string;
    /**
    * The business name of the location This is the name visible to the customers of the location. For example, this name appears on customer receipts.
    */
    'businessName'?: string;
    /**
    * The type of the location, either physical or mobile. See [LocationType](#type-locationtype) for possible values
    */
    'type'?: string;
    /**
    * The website URL of the location.
    */
    'websiteUrl'?: string;
    /**
    *  Represents the hours of operation for the location.
    */
    'businessHours'?: BusinessHours;
    /**
    * The email of the location. This email is visible to the customers of the location. For example, the email appears on customer receipts.
    */
    'businessEmail'?: string;
    /**
    * The description of the location.
    */
    'description'?: string;
    /**
    * The Twitter username of the location without the '&#64;' symbol.
    */
    'twitterUsername'?: string;
    /**
    * The Instagram username of the location without the '&#64;' symbol.
    */
    'instagramUsername'?: string;
    /**
    * The Facebook profile URL of the location. The URL should begin with 'facebook.com/'.
    */
    'facebookUrl'?: string;
    /**
    * The physical coordinates (latitude and longitude) of the location.
    */
    'coordinates'?: Coordinates;
    /**
    * The URL of the logo image for the location.
    */
    'logoUrl'?: string;
    /**
    * The URL of the Point of Sale background image for the location.
    */
    'posBackgroundUrl'?: string;
    /**
    * The merchant category code (MCC) of the location, as standardized by ISO 18245. The MCC describes the kind of goods or services sold at the location.
    */
    'mcc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "capabilities",
            "baseName": "capabilities",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "language_code",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "business_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "websiteUrl",
            "baseName": "website_url",
            "type": "string"
        },
        {
            "name": "businessHours",
            "baseName": "business_hours",
            "type": "BusinessHours"
        },
        {
            "name": "businessEmail",
            "baseName": "business_email",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "twitterUsername",
            "baseName": "twitter_username",
            "type": "string"
        },
        {
            "name": "instagramUsername",
            "baseName": "instagram_username",
            "type": "string"
        },
        {
            "name": "facebookUrl",
            "baseName": "facebook_url",
            "type": "string"
        },
        {
            "name": "coordinates",
            "baseName": "coordinates",
            "type": "Coordinates"
        },
        {
            "name": "logoUrl",
            "baseName": "logo_url",
            "type": "string"
        },
        {
            "name": "posBackgroundUrl",
            "baseName": "pos_background_url",
            "type": "string"
        },
        {
            "name": "mcc",
            "baseName": "mcc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Location.attributeTypeMap;
    }
}

/**
* The capabilities a location may have.
*/
export class LocationCapability {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LocationCapability.attributeTypeMap;
    }
}

/**
* The status of the location, whether a location is active or inactive.
*/
export class LocationStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LocationStatus.attributeTypeMap;
    }
}

/**
* A location's physical or mobile type.
*/
export class LocationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LocationType.attributeTypeMap;
    }
}

/**
* Describes a loyalty account. For more information, see  [Loyalty Overview](/docs/loyalty/overview).
*/
export class LoyaltyAccount {
    /**
    * The Square-assigned ID of the loyalty account.
    */
    'id'?: string;
    /**
    * The list of mappings that the account is associated with.  Currently, a buyer can only be mapped to a loyalty account using  a phone number. Therefore, the list can only have one mapping.
    */
    'mappings': Array<LoyaltyAccountMapping>;
    /**
    * The Square-assigned ID of the `loyalty program` to which the account belongs.
    */
    'programId': string;
    /**
    * The available point balance in the loyalty account.
    */
    'balance'?: number;
    /**
    * The total points accrued during the lifetime of the account.
    */
    'lifetimePoints'?: number;
    /**
    * The Square-assigned ID of the `customer` that is associated with the account.
    */
    'customerId'?: string;
    /**
    * The timestamp when enrollment occurred, in RFC 3339 format.
    */
    'enrolledAt'?: string;
    /**
    * The timestamp when the loyalty account was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timestamp when the loyalty account was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "mappings",
            "baseName": "mappings",
            "type": "Array<LoyaltyAccountMapping>"
        },
        {
            "name": "programId",
            "baseName": "program_id",
            "type": "string"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "lifetimePoints",
            "baseName": "lifetime_points",
            "type": "number"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "enrolledAt",
            "baseName": "enrolled_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyAccount.attributeTypeMap;
    }
}

/**
* Associates a loyalty account with the buyer's phone number. or more information, see  [Loyalty Overview](/docs/loyalty/overview).
*/
export class LoyaltyAccountMapping {
    /**
    * The Square-assigned ID of the mapping.
    */
    'id'?: string;
    /**
    * The type of mapping. See [LoyaltyAccountMappingType](#type-loyaltyaccountmappingtype) for possible values
    */
    'type': string;
    /**
    * The phone number, in E.164 format. For example, \"+14155551111\".
    */
    'value': string;
    /**
    * The timestamp when the mapping was created, in RFC 3339 format.
    */
    'createdAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyAccountMapping.attributeTypeMap;
    }
}

/**
* The type of mapping.
*/
export class LoyaltyAccountMappingType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyAccountMappingType.attributeTypeMap;
    }
}

/**
* Provides information about a loyalty event.  For more information, see [Loyalty events](/docs/loyalty-api/overview/#loyalty-events).
*/
export class LoyaltyEvent {
    /**
    * The Square-assigned ID of the loyalty event.
    */
    'id': string;
    /**
    * The type of the loyalty event. See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
    */
    'type': string;
    /**
    * The timestamp when the event was created, in RFC 3339 format.
    */
    'createdAt': string;
    /**
    * Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
    */
    'accumulatePoints'?: LoyaltyEventAccumulatePoints;
    /**
    * Provides metadata when the event `type` is `CREATE_REWARD`.
    */
    'createReward'?: LoyaltyEventCreateReward;
    /**
    * Provides metadata when the event `type` is `REDEEM_REWARD`.
    */
    'redeemReward'?: LoyaltyEventRedeemReward;
    /**
    * Provides metadata when the event `type` is `DELETE_REWARD`.
    */
    'deleteReward'?: LoyaltyEventDeleteReward;
    /**
    * Provides metadata when the event `type` is `ADJUST_POINTS`.
    */
    'adjustPoints'?: LoyaltyEventAdjustPoints;
    /**
    * The ID of the `loyalty account` in which the event occurred.
    */
    'loyaltyAccountId': string;
    /**
    * The ID of the `location` where the event occurred.
    */
    'locationId'?: string;
    /**
    * Defines whether the event was generated by the Square Point of Sale. See [LoyaltyEventSource](#type-loyaltyeventsource) for possible values
    */
    'source': string;
    /**
    * Provides metadata when the event `type` is `EXPIRE_POINTS`.
    */
    'expirePoints'?: LoyaltyEventExpirePoints;
    /**
    * Provides metadata when the event `type` is `OTHER`.
    */
    'otherEvent'?: LoyaltyEventOther;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "accumulatePoints",
            "baseName": "accumulate_points",
            "type": "LoyaltyEventAccumulatePoints"
        },
        {
            "name": "createReward",
            "baseName": "create_reward",
            "type": "LoyaltyEventCreateReward"
        },
        {
            "name": "redeemReward",
            "baseName": "redeem_reward",
            "type": "LoyaltyEventRedeemReward"
        },
        {
            "name": "deleteReward",
            "baseName": "delete_reward",
            "type": "LoyaltyEventDeleteReward"
        },
        {
            "name": "adjustPoints",
            "baseName": "adjust_points",
            "type": "LoyaltyEventAdjustPoints"
        },
        {
            "name": "loyaltyAccountId",
            "baseName": "loyalty_account_id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "expirePoints",
            "baseName": "expire_points",
            "type": "LoyaltyEventExpirePoints"
        },
        {
            "name": "otherEvent",
            "baseName": "other_event",
            "type": "LoyaltyEventOther"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEvent.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
*/
export class LoyaltyEventAccumulatePoints {
    /**
    * The ID of the `loyalty program`.
    */
    'loyaltyProgramId'?: string;
    /**
    * The number of points accumulated by the event.
    */
    'points'?: number;
    /**
    * The ID of the `order` for which the buyer accumulated the points. This field is returned only if the Orders API is used to process orders.
    */
    'orderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventAccumulatePoints.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `ADJUST_POINTS`.
*/
export class LoyaltyEventAdjustPoints {
    /**
    * The Square-assigned ID of the `loyalty program`.
    */
    'loyaltyProgramId'?: string;
    /**
    * The number of points added or removed.
    */
    'points': number;
    /**
    * The reason for the adjustment of points.
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventAdjustPoints.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `CREATE_REWARD`.
*/
export class LoyaltyEventCreateReward {
    /**
    * The ID of the `loyalty program`.
    */
    'loyaltyProgramId': string;
    /**
    * The Square-assigned ID of the created `loyalty reward`. This field is returned only if the event source is `LOYALTY_API`.
    */
    'rewardId'?: string;
    /**
    * The loyalty points used to create the reward.
    */
    'points': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "rewardId",
            "baseName": "reward_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventCreateReward.attributeTypeMap;
    }
}

/**
* Filter events by date time range.
*/
export class LoyaltyEventDateTimeFilter {
    /**
    * The `created_at` date time range used to filter the result.
    */
    'createdAt': TimeRange;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "TimeRange"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventDateTimeFilter.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `DELETE_REWARD`.
*/
export class LoyaltyEventDeleteReward {
    /**
    * The ID of the `loyalty program`.
    */
    'loyaltyProgramId': string;
    /**
    * The ID of the deleted `loyalty reward`. This field is returned only if the event source is `LOYALTY_API`.
    */
    'rewardId'?: string;
    /**
    * The number of points returned to the loyalty account.
    */
    'points': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "rewardId",
            "baseName": "reward_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventDeleteReward.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `EXPIRE_POINTS`.
*/
export class LoyaltyEventExpirePoints {
    /**
    * The Square-assigned ID of the `loyalty program`.
    */
    'loyaltyProgramId': string;
    /**
    * The number of points expired.
    */
    'points': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventExpirePoints.attributeTypeMap;
    }
}

/**
* The filtering criteria. If the request specifies multiple filters,  the endpoint uses a logical AND to evaluate them.
*/
export class LoyaltyEventFilter {
    /**
    * Filter events by loyalty account.
    */
    'loyaltyAccountFilter'?: LoyaltyEventLoyaltyAccountFilter;
    /**
    * Filter events by event type.
    */
    'typeFilter'?: LoyaltyEventTypeFilter;
    /**
    * Filter events by date time range.  For each range, the start time is inclusive and the end time  is exclusive.
    */
    'dateTimeFilter'?: LoyaltyEventDateTimeFilter;
    /**
    * Filter events by location.
    */
    'locationFilter'?: LoyaltyEventLocationFilter;
    /**
    * Filter events by the order associated with the event.
    */
    'orderFilter'?: LoyaltyEventOrderFilter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyAccountFilter",
            "baseName": "loyalty_account_filter",
            "type": "LoyaltyEventLoyaltyAccountFilter"
        },
        {
            "name": "typeFilter",
            "baseName": "type_filter",
            "type": "LoyaltyEventTypeFilter"
        },
        {
            "name": "dateTimeFilter",
            "baseName": "date_time_filter",
            "type": "LoyaltyEventDateTimeFilter"
        },
        {
            "name": "locationFilter",
            "baseName": "location_filter",
            "type": "LoyaltyEventLocationFilter"
        },
        {
            "name": "orderFilter",
            "baseName": "order_filter",
            "type": "LoyaltyEventOrderFilter"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventFilter.attributeTypeMap;
    }
}

/**
* Filter events by location.
*/
export class LoyaltyEventLocationFilter {
    /**
    * The `location` IDs for loyalty events to query. If multiple values are specified, the endpoint uses  a logical OR to combine them.
    */
    'locationIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventLocationFilter.attributeTypeMap;
    }
}

/**
* Filter events by loyalty account.
*/
export class LoyaltyEventLoyaltyAccountFilter {
    /**
    * The ID of the `loyalty account` associated with loyalty events.
    */
    'loyaltyAccountId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyAccountId",
            "baseName": "loyalty_account_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventLoyaltyAccountFilter.attributeTypeMap;
    }
}

/**
* Filter events by the order associated with the event.
*/
export class LoyaltyEventOrderFilter {
    /**
    * The ID of the `order` associated with the event.
    */
    'orderId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventOrderFilter.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `OTHER`.
*/
export class LoyaltyEventOther {
    /**
    * The Square-assigned ID of the `loyalty program`.
    */
    'loyaltyProgramId': string;
    /**
    * The number of points added or removed.
    */
    'points': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventOther.attributeTypeMap;
    }
}

/**
* Represents a query used to search for loyalty events.
*/
export class LoyaltyEventQuery {
    /**
    * The query filter criteria.
    */
    'filter'?: LoyaltyEventFilter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "LoyaltyEventFilter"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventQuery.attributeTypeMap;
    }
}

/**
* Provides metadata when the event `type` is `REDEEM_REWARD`.
*/
export class LoyaltyEventRedeemReward {
    /**
    * The ID of the `loyalty program`.
    */
    'loyaltyProgramId': string;
    /**
    * The ID of the redeemed `loyalty reward`. This field is returned only if the event source is `LOYALTY_API`.
    */
    'rewardId'?: string;
    /**
    * The ID of the `order` that redeemed the reward. This field is returned only if the Orders API is used to process orders.
    */
    'orderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyProgramId",
            "baseName": "loyalty_program_id",
            "type": "string"
        },
        {
            "name": "rewardId",
            "baseName": "reward_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventRedeemReward.attributeTypeMap;
    }
}

/**
* Defines whether the event was generated by the Square Point of Sale.
*/
export class LoyaltyEventSource {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyEventSource.attributeTypeMap;
    }
}

/**
* The type of the loyalty event.
*/
export class LoyaltyEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyEventType.attributeTypeMap;
    }
}

/**
* Filter events by event type.
*/
export class LoyaltyEventTypeFilter {
    /**
    * The loyalty event types used to filter the result. If multiple values are specified, the endpoint uses a  logical OR to combine them. See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
    */
    'types': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyEventTypeFilter.attributeTypeMap;
    }
}

/**
* 
*/
export class LoyaltyProgram {
    /**
    * The Square-assigned ID of the loyalty program. Updates to  the loyalty program do not modify the identifier.
    */
    'id': string;
    /**
    * Whether the program is currently active. See [LoyaltyProgramStatus](#type-loyaltyprogramstatus) for possible values
    */
    'status': string;
    /**
    * The list of rewards for buyers, sorted by ascending points.
    */
    'rewardTiers': Array<LoyaltyProgramRewardTier>;
    /**
    * If present, details for how points expire.
    */
    'expirationPolicy'?: LoyaltyProgramExpirationPolicy;
    /**
    * A cosmetic name for the â€œpointsâ€ currency.
    */
    'terminology': LoyaltyProgramTerminology;
    /**
    * The `locations` at which the program is active.
    */
    'locationIds': Array<string>;
    /**
    * The timestamp when the program was created, in RFC 3339 format.
    */
    'createdAt': string;
    /**
    * The timestamp when the reward was last updated, in RFC 3339 format.
    */
    'updatedAt': string;
    /**
    * Defines how buyers can earn loyalty points.
    */
    'accrualRules': Array<LoyaltyProgramAccrualRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "rewardTiers",
            "baseName": "reward_tiers",
            "type": "Array<LoyaltyProgramRewardTier>"
        },
        {
            "name": "expirationPolicy",
            "baseName": "expiration_policy",
            "type": "LoyaltyProgramExpirationPolicy"
        },
        {
            "name": "terminology",
            "baseName": "terminology",
            "type": "LoyaltyProgramTerminology"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "accrualRules",
            "baseName": "accrual_rules",
            "type": "Array<LoyaltyProgramAccrualRule>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgram.attributeTypeMap;
    }
}

/**
* Defines an accrual rule, which is how buyers can earn points.
*/
export class LoyaltyProgramAccrualRule {
    /**
    * The type of the accrual rule that defines how buyers can earn points. See [LoyaltyProgramAccrualRuleType](#type-loyaltyprogramaccrualruletype) for possible values
    */
    'accrualType': string;
    /**
    * The number of points that  buyers earn based on the `accrual_type`.
    */
    'points'?: number;
    /**
    * When the accrual rule is visit-based (`accrual_type` is `VISIT`), this field indicates the minimum purchase required during the visit to  quality for the reward.
    */
    'visitMinimumAmountMoney'?: Money;
    /**
    * When the accrual rule is spend-based (`accrual_type` is `SPEND`), this field indicates the amount that a buyer must spend  to earn the points. For example, suppose the accrual rule is \"earn 1 point for every $10 you spend\".  Then, buyer earns a point for every $10 they spend. If  buyer spends $105, the buyer earns 10 points.
    */
    'spendAmountMoney'?: Money;
    /**
    * The ID of the `catalog object` to purchase to earn the number of points defined by the rule. This is either an item variation or a category, depending on the type. This is defined on `ITEM_VARIATION` rules and `CATEGORY` rules.
    */
    'catalogObjectId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accrualType",
            "baseName": "accrual_type",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "visitMinimumAmountMoney",
            "baseName": "visit_minimum_amount_money",
            "type": "Money"
        },
        {
            "name": "spendAmountMoney",
            "baseName": "spend_amount_money",
            "type": "Money"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramAccrualRule.attributeTypeMap;
    }
}

/**
* The type of the accrual rule that defines how buyers can earn points.
*/
export class LoyaltyProgramAccrualRuleType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramAccrualRuleType.attributeTypeMap;
    }
}

/**
* Describes when the loyalty program expires.
*/
export class LoyaltyProgramExpirationPolicy {
    /**
    * The duration of time before points expire, in RFC 3339 format.
    */
    'expirationDuration': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationDuration",
            "baseName": "expiration_duration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramExpirationPolicy.attributeTypeMap;
    }
}

/**
* Provides details about the loyalty program reward tier definition.
*/
export class LoyaltyProgramRewardDefinition {
    /**
    * Indicates the scope of the reward tier. See [LoyaltyProgramRewardDefinitionScope](#type-loyaltyprogramrewarddefinitionscope) for possible values
    */
    'scope': string;
    /**
    * The type of discount the reward tier offers. See [LoyaltyProgramRewardDefinitionType](#type-loyaltyprogramrewarddefinitiontype) for possible values
    */
    'discountType': string;
    /**
    * Present if `discount_type` is `FIXED_PERCENTAGE`. For example, a 7.25% off discount will be represented as \"7.25\".
    */
    'percentageDiscount'?: string;
    /**
    * A list of `catalog object` ids to which this reward can be applied. They are either all item-variation ids or category ids, depending on the `type` field.
    */
    'catalogObjectIds'?: Array<string>;
    /**
    * Present if `discount_type` is `FIXED_AMOUNT`. For example, $5 off.
    */
    'fixedDiscountMoney'?: Money;
    /**
    * When `discount_type` is `FIXED_PERCENTAGE`, the maximum discount amount that can be applied.
    */
    'maxDiscountMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "string"
        },
        {
            "name": "percentageDiscount",
            "baseName": "percentage_discount",
            "type": "string"
        },
        {
            "name": "catalogObjectIds",
            "baseName": "catalog_object_ids",
            "type": "Array<string>"
        },
        {
            "name": "fixedDiscountMoney",
            "baseName": "fixed_discount_money",
            "type": "Money"
        },
        {
            "name": "maxDiscountMoney",
            "baseName": "max_discount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramRewardDefinition.attributeTypeMap;
    }
}

/**
* Indicates the scope of the reward tier.
*/
export class LoyaltyProgramRewardDefinitionScope {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramRewardDefinitionScope.attributeTypeMap;
    }
}

/**
* The type of discount the reward tier offers.
*/
export class LoyaltyProgramRewardDefinitionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramRewardDefinitionType.attributeTypeMap;
    }
}

/**
* Describes a loyalty program reward tier.
*/
export class LoyaltyProgramRewardTier {
    /**
    * The Square-assigned ID of the reward tier.
    */
    'id': string;
    /**
    * The points exchanged for the reward tier.
    */
    'points': number;
    /**
    * The name of the reward tier.
    */
    'name': string;
    /**
    * Provides details about the reward tier definition.
    */
    'definition': LoyaltyProgramRewardDefinition;
    /**
    * The timestamp when the reward tier was created, in RFC 3339 format.
    */
    'createdAt': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "definition",
            "baseName": "definition",
            "type": "LoyaltyProgramRewardDefinition"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramRewardTier.attributeTypeMap;
    }
}

/**
* Whether the program is currently active.
*/
export class LoyaltyProgramStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramStatus.attributeTypeMap;
    }
}

/**
* 
*/
export class LoyaltyProgramTerminology {
    /**
    * A singular unit for a point (for example, 1 point is called 1 star).
    */
    'one': string;
    /**
    * A plural unit for point (for example, 10 points is called 10 stars).
    */
    'other': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "one",
            "baseName": "one",
            "type": "string"
        },
        {
            "name": "other",
            "baseName": "other",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyProgramTerminology.attributeTypeMap;
    }
}

/**
* 
*/
export class LoyaltyReward {
    /**
    * The Square-assigned ID of the loyalty reward.
    */
    'id'?: string;
    /**
    * The status of a loyalty reward. See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
    */
    'status'?: string;
    /**
    * The Square-assigned ID of the `loyalty account` to which the reward belongs.
    */
    'loyaltyAccountId': string;
    /**
    * The Square-assigned ID of the `reward tier` used to create the reward.
    */
    'rewardTierId': string;
    /**
    * The number of loyalty points used for the reward.
    */
    'points'?: number;
    /**
    * The Square-assigned ID of the `order` to which the reward is attached.
    */
    'orderId'?: string;
    /**
    * The timestamp when the reward was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The timestamp when the reward was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;
    /**
    * The timestamp when the reward was redeemed, in RFC 3339 format.
    */
    'redeemedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "loyaltyAccountId",
            "baseName": "loyalty_account_id",
            "type": "string"
        },
        {
            "name": "rewardTierId",
            "baseName": "reward_tier_id",
            "type": "string"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemed_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyReward.attributeTypeMap;
    }
}

/**
* The status of the loyalty reward.
*/
export class LoyaltyRewardStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LoyaltyRewardStatus.attributeTypeMap;
    }
}

/**
* Represents a unit of measurement to use with a quantity, such as ounces or inches. Exactly one of the following fields are required: `custom_unit`, `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
*/
export class MeasurementUnit {
    /**
    * A custom unit of measurement defined by the seller using the Point of Sale app or ad-hoc as an order line item.
    */
    'customUnit'?: MeasurementUnitCustom;
    /**
    * Represents a standard area unit. See [MeasurementUnitArea](#type-measurementunitarea) for possible values
    */
    'areaUnit'?: string;
    /**
    * Represents a standard length unit. See [MeasurementUnitLength](#type-measurementunitlength) for possible values
    */
    'lengthUnit'?: string;
    /**
    * Represents a standard volume unit. See [MeasurementUnitVolume](#type-measurementunitvolume) for possible values
    */
    'volumeUnit'?: string;
    /**
    * Represents a standard unit of weight or mass. See [MeasurementUnitWeight](#type-measurementunitweight) for possible values
    */
    'weightUnit'?: string;
    /**
    * Reserved for API integrations that lack the ability to specify a real measurement unit See [MeasurementUnitGeneric](#type-measurementunitgeneric) for possible values
    */
    'genericUnit'?: string;
    /**
    * Represents a standard unit of time. See [MeasurementUnitTime](#type-measurementunittime) for possible values
    */
    'timeUnit'?: string;
    /**
    * Represents the type of the measurement unit. See [MeasurementUnitUnitType](#type-measurementunitunittype) for possible values
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customUnit",
            "baseName": "custom_unit",
            "type": "MeasurementUnitCustom"
        },
        {
            "name": "areaUnit",
            "baseName": "area_unit",
            "type": "string"
        },
        {
            "name": "lengthUnit",
            "baseName": "length_unit",
            "type": "string"
        },
        {
            "name": "volumeUnit",
            "baseName": "volume_unit",
            "type": "string"
        },
        {
            "name": "weightUnit",
            "baseName": "weight_unit",
            "type": "string"
        },
        {
            "name": "genericUnit",
            "baseName": "generic_unit",
            "type": "string"
        },
        {
            "name": "timeUnit",
            "baseName": "time_unit",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MeasurementUnit.attributeTypeMap;
    }
}

/**
* Unit of area used to measure a quantity.
*/
export class MeasurementUnitArea {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitArea.attributeTypeMap;
    }
}

/**
* The information needed to define a custom unit, provided by the seller.
*/
export class MeasurementUnitCustom {
    /**
    * The name of the custom unit, for example \"bushel\".
    */
    'name': string;
    /**
    * The abbreviation of the custom unit, such as \"bsh\" (bushel). This appears in the cart for the Point of Sale app, and in reports.
    */
    'abbreviation': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "abbreviation",
            "baseName": "abbreviation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MeasurementUnitCustom.attributeTypeMap;
    }
}

/**
* 
*/
export class MeasurementUnitGeneric {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitGeneric.attributeTypeMap;
    }
}

/**
* The unit of length used to measure a quantity.
*/
export class MeasurementUnitLength {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitLength.attributeTypeMap;
    }
}

/**
* Unit of time used to measure a quantity (a duration).
*/
export class MeasurementUnitTime {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitTime.attributeTypeMap;
    }
}

/**
* Describes the type of this unit and indicates which field contains the unit information. This is an â€˜openâ€™ enum.
*/
export class MeasurementUnitUnitType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitUnitType.attributeTypeMap;
    }
}

/**
* The unit of volume used to measure a quantity.
*/
export class MeasurementUnitVolume {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitVolume.attributeTypeMap;
    }
}

/**
* Unit of weight used to measure a quantity.
*/
export class MeasurementUnitWeight {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MeasurementUnitWeight.attributeTypeMap;
    }
}

/**
* Represents a Square seller.
*/
export class Merchant {
    /**
    * The Square-issued ID of the merchant.
    */
    'id'?: string;
    /**
    * The business name of the merchant.
    */
    'businessName'?: string;
    /**
    * The country code associated with the merchant account, in ISO 3166 format. See [Country](#type-country) for possible values
    */
    'country': string;
    /**
    * The language code associated with the merchant account, in BCP 47 format.
    */
    'languageCode'?: string;
    /**
    * The currency associated with the merchant account, in ISO 4217 format. See [Currency](#type-currency) for possible values
    */
    'currency'?: string;
    /**
    * The merchant status, active or inactive. See [MerchantStatus](#type-merchantstatus) for possible values
    */
    'status'?: string;
    /**
    * The ID of the main `Location` for this merchant.
    */
    'mainLocationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "business_name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "language_code",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "mainLocationId",
            "baseName": "main_location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Merchant.attributeTypeMap;
    }
}

/**
* 
*/
export class MerchantStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MerchantStatus.attributeTypeMap;
    }
}

/**
* A record of an employee's break during a shift.
*/
export class ModelBreak {
    /**
    * UUID for this object
    */
    'id'?: string;
    /**
    * RFC 3339; follows same timezone info as `Shift`. Precision up to the minute is respected; seconds are truncated.
    */
    'startAt': string;
    /**
    * RFC 3339; follows same timezone info as `Shift`. Precision up to the minute is respected; seconds are truncated.
    */
    'endAt'?: string;
    /**
    * The `BreakType` this `Break` was templated on.
    */
    'breakTypeId': string;
    /**
    * A human-readable name.
    */
    'name': string;
    /**
    * Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of the break.
    */
    'expectedDuration': string;
    /**
    * Whether this break counts towards time worked for compensation purposes.
    */
    'isPaid': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "startAt",
            "baseName": "start_at",
            "type": "string"
        },
        {
            "name": "endAt",
            "baseName": "end_at",
            "type": "string"
        },
        {
            "name": "breakTypeId",
            "baseName": "break_type_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "expectedDuration",
            "baseName": "expected_duration",
            "type": "string"
        },
        {
            "name": "isPaid",
            "baseName": "is_paid",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ModelBreak.attributeTypeMap;
    }
}

/**
* Represents an error encountered during a request to the Connect API.  See [Handling errors](#handlingerrors) for more information.
*/
export class ModelError {
    /**
    * The high-level category for the error. See `ErrorCategory` for possible values. See [ErrorCategory](#type-errorcategory) for possible values
    */
    'category': string;
    /**
    * The specific code of the error. See `ErrorCode` for possible values See [ErrorCode](#type-errorcode) for possible values
    */
    'code': string;
    /**
    * A human-readable description of the error for debugging purposes.
    */
    'detail'?: string;
    /**
    * The name of the field provided in the original request (if any) that the error pertains to.
    */
    'field'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "detail",
            "baseName": "detail",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

/**
* Represents an amount of money. `Money` fields can be signed or unsigned. Fields that do not explicitly define whether they are signed or unsigned are considered unsigned and can only hold positive amounts. For signed fields, the sign of the value indicates the purpose of the money transfer. See [Working with Monetary Amounts](/build-basics/working-with-monetary-amounts) for more information.
*/
export class Money {
    /**
    * The amount of money, in the smallest denomination of the currency indicated by `currency`. For example, when `currency` is `USD`, `amount` is in cents. Monetary amounts can be positive or negative. See the specific field description to determine the meaning of the sign in a particular case.
    */
    'amount'?: number;
    /**
    * The type of currency, in __ISO 4217 format__. For example, the currency code for US dollars is `USD`.  See `Currency` for possible values. See [Currency](#type-currency) for possible values
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Money.attributeTypeMap;
    }
}

/**
* 
*/
export class ObtainTokenRequest {
    /**
    * The Square-issued ID of your application, available from the [application dashboard](https://connect.squareup.com/apps).
    */
    'clientId': string;
    /**
    * The Square-issued application secret for your application, available from the [application dashboard](https://connect.squareup.com/apps).
    */
    'clientSecret': string;
    /**
    * The authorization code to exchange. This is required if `grant_type` is set to `authorization_code`, to indicate that the application wants to exchange an authorization code for an OAuth access token.
    */
    'code'?: string;
    /**
    * The redirect URL assigned in the [application dashboard](https://connect.squareup.com/apps).
    */
    'redirectUri'?: string;
    /**
    * Specifies the method to request an OAuth access token. Valid values are: `authorization_code`, `refresh_token`, and `migration_token`
    */
    'grantType': string;
    /**
    * A valid refresh token for generating a new OAuth access token. A valid refresh token is required if `grant_type` is set to `refresh_token` , to indicate the application wants a replacement for an expired OAuth access token.
    */
    'refreshToken'?: string;
    /**
    * Legacy OAuth access token obtained using a Connect API version prior to 2019-03-13. This parameter is required if `grant_type` is set to `migration_token` to indicate that the application wants to get a replacement OAuth access token. The response also returns a refresh token. For more information, see [Migrate to Using Refresh Tokens](https://developer.squareup.com/docs/authz/oauth/migration).
    */
    'migrationToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "client_secret",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "redirectUri",
            "baseName": "redirect_uri",
            "type": "string"
        },
        {
            "name": "grantType",
            "baseName": "grant_type",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "refresh_token",
            "type": "string"
        },
        {
            "name": "migrationToken",
            "baseName": "migration_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObtainTokenRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ObtainTokenResponse {
    /**
    * A valid OAuth access token. OAuth access tokens are 64 bytes long. Provide the access token in a header with every request to Connect API endpoints. See the [Build with OAuth](https://developer.squareup.com/docs/authz/oauth/build-with-the-api) guide for more information.
    */
    'accessToken'?: string;
    /**
    * This value is always _bearer_.
    */
    'tokenType'?: string;
    /**
    * The date when access_token expires, in [ISO 8601](http://www.iso.org/iso/home/standards/iso8601.htm) format.
    */
    'expiresAt'?: string;
    /**
    * The ID of the authorizing merchant's business.
    */
    'merchantId'?: string;
    /**
    * __LEGACY FIELD__. The ID of a subscription plan the merchant signed up for. Only present if the merchant signed up for a subscription during authorization.
    */
    'subscriptionId'?: string;
    /**
    * T__LEGACY FIELD__. The ID of the subscription plan the merchant signed up for. Only present if the merchant signed up for a subscription during authorization.
    */
    'planId'?: string;
    /**
    * Then OpenID token belonging to this this person. Only present if the OPENID scope is included in the authorize request.
    */
    'idToken'?: string;
    /**
    * A refresh token. OAuth refresh tokens are 64 bytes long. For more information, see [OAuth access token management](https://developer.squareup.com/docs/authz/oauth/how-it-works#oauth-access-token-management).
    */
    'refreshToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "token_type",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "subscriptionId",
            "baseName": "subscription_id",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "plan_id",
            "type": "string"
        },
        {
            "name": "idToken",
            "baseName": "id_token",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "refresh_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObtainTokenResponse.attributeTypeMap;
    }
}

/**
* Contains all information related to a single order to process with Square, including line items that specify the products to purchase. Order objects also include information on any associated tenders, refunds, and returns.  All Connect V2 Transactions have all been converted to Orders including all associated itemization data.
*/
export class Order {
    /**
    * The order's unique ID.
    */
    'id'?: string;
    /**
    * The ID of the merchant location this order is associated with.
    */
    'locationId': string;
    /**
    * A client specified identifier to associate an entity in another system with this order.
    */
    'referenceId'?: string;
    /**
    * The origination details of the order.
    */
    'source'?: OrderSource;
    /**
    * The `Customer` ID of the customer associated with the order.
    */
    'customerId'?: string;
    /**
    * The line items included in the order.
    */
    'lineItems'?: Array<OrderLineItem>;
    /**
    * The list of all taxes associated with the order.  Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes with `ORDER` scope, the server will generate an `OrderLineItemAppliedTax` for every line item.  On reads, each tax in the list will include the total amount of that tax applied to the order.  __IMPORTANT__: If `LINE_ITEM` scope is set on any taxes in this field, usage of the deprecated `line_items.taxes` field will result in an error. Please use `line_items.applied_taxes` instead.
    */
    'taxes'?: Array<OrderLineItemTax>;
    /**
    * The list of all discounts associated with the order.  Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`, an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to. For discounts with `ORDER` scope, the server will generate an `OrderLineItemAppliedDiscount` for every line item.  __IMPORTANT__: If `LINE_ITEM` scope is set on any discounts in this field, usage of the deprecated `line_items.discounts` field will result in an error. Please use `line_items.applied_discounts` instead.
    */
    'discounts'?: Array<OrderLineItemDiscount>;
    /**
    * A list of service charges applied to the order.
    */
    'serviceCharges'?: Array<OrderServiceCharge>;
    /**
    * Details on order fulfillment.  Orders can only be created with at most one fulfillment. However, orders returned by the API may contain multiple fulfillments.
    */
    'fulfillments'?: Array<OrderFulfillment>;
    /**
    * Collection of items from sale Orders being returned in this one. Normally part of an Itemized Return or Exchange.  There will be exactly one `Return` object per sale Order being referenced.
    */
    'returns'?: Array<OrderReturn>;
    /**
    * Rollup of returned money amounts.
    */
    'returnAmounts'?: OrderMoneyAmounts;
    /**
    * Net money amounts (sale money - return money).
    */
    'netAmounts'?: OrderMoneyAmounts;
    /**
    * A positive or negative rounding adjustment to the total of the order, commonly used to apply Cash Rounding when the minimum unit of account is smaller than the lowest physical denomination of currency.
    */
    'roundingAdjustment'?: OrderRoundingAdjustment;
    /**
    * The Tenders which were used to pay for the Order.
    */
    'tenders'?: Array<Tender>;
    /**
    * The Refunds that are part of this Order.
    */
    'refunds'?: Array<Refund>;
    /**
    * Application-defined data attached to this order. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };
    /**
    * Timestamp for when the order was created. In RFC 3339 format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'createdAt'?: string;
    /**
    * Timestamp for when the order was last updated. In RFC 3339 format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'updatedAt'?: string;
    /**
    * Timestamp for when the order reached a terminal [state](#property-state). In RFC 3339 format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'closedAt'?: string;
    /**
    * The current state of the order. `OPEN`,`COMPLETED`,`CANCELED` See [OrderState](#type-orderstate) for possible values
    */
    'state'?: string;
    /**
    * Version number which is incremented each time an update is committed to the order. Orders that were not created through the API will not include a version and thus cannot be updated.  [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders).
    */
    'version'?: number;
    /**
    * The total amount of money to collect for the order.
    */
    'totalMoney'?: Money;
    /**
    * The total tax amount of money to collect for the order.
    */
    'totalTaxMoney'?: Money;
    /**
    * The total discount amount of money to collect for the order.
    */
    'totalDiscountMoney'?: Money;
    /**
    * The total tip amount of money to collect for the order.
    */
    'totalTipMoney'?: Money;
    /**
    * The total amount of money collected in service charges for the order.  Note: `total_service_charge_money` is the sum of `applied_money` fields for each individual service charge. Therefore, `total_service_charge_money` will only include inclusive tax amounts, not additive tax amounts.
    */
    'totalServiceChargeMoney'?: Money;
    /**
    * Pricing options for an order. The options affect how the order's price is calculated. They can be used, for example, to apply automatic price adjustments that are based on pre-configured [pricing rules](https://developer.squareup.com/docs/reference/square/objects/CatalogPricingRule).
    */
    'pricingOptions'?: OrderPricingOptions;
    /**
    * A set-like list of rewards that have been added to the order.
    */
    'rewards'?: Array<OrderReward>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "OrderSource"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "lineItems",
            "baseName": "line_items",
            "type": "Array<OrderLineItem>"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<OrderLineItemTax>"
        },
        {
            "name": "discounts",
            "baseName": "discounts",
            "type": "Array<OrderLineItemDiscount>"
        },
        {
            "name": "serviceCharges",
            "baseName": "service_charges",
            "type": "Array<OrderServiceCharge>"
        },
        {
            "name": "fulfillments",
            "baseName": "fulfillments",
            "type": "Array<OrderFulfillment>"
        },
        {
            "name": "returns",
            "baseName": "returns",
            "type": "Array<OrderReturn>"
        },
        {
            "name": "returnAmounts",
            "baseName": "return_amounts",
            "type": "OrderMoneyAmounts"
        },
        {
            "name": "netAmounts",
            "baseName": "net_amounts",
            "type": "OrderMoneyAmounts"
        },
        {
            "name": "roundingAdjustment",
            "baseName": "rounding_adjustment",
            "type": "OrderRoundingAdjustment"
        },
        {
            "name": "tenders",
            "baseName": "tenders",
            "type": "Array<Tender>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<Refund>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "Money"
        },
        {
            "name": "totalDiscountMoney",
            "baseName": "total_discount_money",
            "type": "Money"
        },
        {
            "name": "totalTipMoney",
            "baseName": "total_tip_money",
            "type": "Money"
        },
        {
            "name": "totalServiceChargeMoney",
            "baseName": "total_service_charge_money",
            "type": "Money"
        },
        {
            "name": "pricingOptions",
            "baseName": "pricing_options",
            "type": "OrderPricingOptions"
        },
        {
            "name": "rewards",
            "baseName": "rewards",
            "type": "Array<OrderReward>"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderCreated {
    /**
    * The order's unique ID.
    */
    'orderId'?: string;
    /**
    * Version number which is incremented each time an update is committed to the order. Orders that were not created through the API will not include a version and thus cannot be updated.  [Read more about working with versions](https://developer.squareup.com/docs/docs/orders-api/manage-orders#update-orders)
    */
    'version'?: number;
    /**
    * The ID of the merchant location this order is associated with.
    */
    'locationId'?: string;
    /**
    * The state of the order. See [OrderState](#type-orderstate) for possible values
    */
    'state'?: string;
    /**
    * Timestamp for when the order was created in RFC 3339 format.
    */
    'createdAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreated.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderCreatedObject {
    /**
    * Information about the created order.
    */
    'orderCreated'?: OrderCreated;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderCreated",
            "baseName": "order_created",
            "type": "OrderCreated"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedObject.attributeTypeMap;
    }
}

/**
* A lightweight description of an [Order](#type-order) that is returned when `returned_entries` is true on a [SearchOrderRequest](#type-searchorderrequest)
*/
export class OrderEntry {
    /**
    * The id of the Order
    */
    'orderId'?: string;
    /**
    * Version number which is incremented each time an update is committed to the order. Orders that were not created through the API will not include a version and thus cannot be updated.  [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders).
    */
    'version'?: number;
    /**
    * The location id the Order belongs to.
    */
    'locationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderEntry.attributeTypeMap;
    }
}

/**
* Contains details on how to fulfill this order.
*/
export class OrderFulfillment {
    /**
    * Unique ID that identifies the fulfillment only within this order.
    */
    'uid'?: string;
    /**
    * The type of the fulfillment. See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
    */
    'type'?: string;
    /**
    * The state of the fulfillment. See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
    */
    'state'?: string;
    /**
    * Application-defined data attached to this fulfillment. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };
    /**
    * Contains details for a pickup fulfillment. Required when fulfillment type is `PICKUP`.
    */
    'pickupDetails'?: OrderFulfillmentPickupDetails;
    /**
    * Contains details for a shipment fulfillment. Required when fulfillment type is `SHIPMENT`.  A shipment fulfillment's relationship to fulfillment `state`: `PROPOSED`: A shipment is requested. `RESERVED`: Fulfillment accepted. Shipment processing. `PREPARED`: Shipment packaged. Shipping label created. `COMPLETED`: Package has been shipped. `CANCELED`: Shipment has been canceled. `FAILED`: Shipment has failed.
    */
    'shipmentDetails'?: OrderFulfillmentShipmentDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "pickupDetails",
            "baseName": "pickup_details",
            "type": "OrderFulfillmentPickupDetails"
        },
        {
            "name": "shipmentDetails",
            "baseName": "shipment_details",
            "type": "OrderFulfillmentShipmentDetails"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillment.attributeTypeMap;
    }
}

/**
* Contains details necessary to fulfill a pickup order.
*/
export class OrderFulfillmentPickupDetails {
    /**
    * Information on the person meant to pick up this fulfillment from a physical location.
    */
    'recipient'?: OrderFulfillmentRecipient;
    /**
    * The [timestamp](#workingwithdates) indicating when this fulfillment will expire if it is not accepted. Must be in RFC 3339 format e.g., \"2016-09-04T23:59:33.123Z\". Expiration time can only be set up to 7 days in the future. If `expires_at` is not set, this pickup fulfillment will be automatically accepted when placed.
    */
    'expiresAt'?: string;
    /**
    * The duration of time after which an open and accepted pickup fulfillment will automatically move to the `COMPLETED` state. Must be in RFC3339 duration format e.g., \"P1W3D\".  If not set, this pickup fulfillment will remain accepted until it is canceled or completed.
    */
    'autoCompleteDuration'?: string;
    /**
    * The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`. See [OrderFulfillmentPickupDetailsScheduleType](#type-orderfulfillmentpickupdetailsscheduletype) for possible values
    */
    'scheduleType'?: string;
    /**
    * The [timestamp](#workingwithdates) that represents the start of the pickup window. Must be in RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\". For fulfillments with the schedule type `ASAP`, this is automatically set to the current time plus the expected duration to prepare the fulfillment.
    */
    'pickupAt'?: string;
    /**
    * The window of time in which the order should be picked up after the `pickup_at` timestamp. Must be in RFC3339 duration format, e.g., \"P1W3D\". Can be used as an informational guideline for merchants.
    */
    'pickupWindowDuration'?: string;
    /**
    * The duration of time it takes to prepare this fulfillment. Must be in RFC3339 duration format, e.g., \"P1W3D\".
    */
    'prepTimeDuration'?: string;
    /**
    * A note meant to provide additional instructions about the pickup fulfillment displayed in the Square Point of Sale and set by the API.
    */
    'note'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment was placed. Must be in RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'placedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment was accepted. In RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'acceptedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment was rejected. In RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'rejectedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment is marked as ready for pickup. In RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'readyAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment expired. In RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'expiredAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the fulfillment was picked up by the recipient. In RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'pickedUpAt'?: string;
    /**
    * The [timestamp](#workingwithdates) in RFC3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\", indicating when the fulfillment was canceled.
    */
    'canceledAt'?: string;
    /**
    * A description of why the pickup was canceled. Max length: 100 characters.
    */
    'cancelReason'?: string;
    /**
    * If true, indicates this pickup order is for curbside pickup, not in-store pickup.
    */
    'isCurbsidePickup'?: boolean;
    /**
    * Specific details for curbside pickup. Can only be populated if `is_curbside_pickup` is true.
    */
    'curbsidePickupDetails'?: OrderFulfillmentPickupDetailsCurbsidePickupDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "OrderFulfillmentRecipient"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "string"
        },
        {
            "name": "autoCompleteDuration",
            "baseName": "auto_complete_duration",
            "type": "string"
        },
        {
            "name": "scheduleType",
            "baseName": "schedule_type",
            "type": "string"
        },
        {
            "name": "pickupAt",
            "baseName": "pickup_at",
            "type": "string"
        },
        {
            "name": "pickupWindowDuration",
            "baseName": "pickup_window_duration",
            "type": "string"
        },
        {
            "name": "prepTimeDuration",
            "baseName": "prep_time_duration",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "placedAt",
            "baseName": "placed_at",
            "type": "string"
        },
        {
            "name": "acceptedAt",
            "baseName": "accepted_at",
            "type": "string"
        },
        {
            "name": "rejectedAt",
            "baseName": "rejected_at",
            "type": "string"
        },
        {
            "name": "readyAt",
            "baseName": "ready_at",
            "type": "string"
        },
        {
            "name": "expiredAt",
            "baseName": "expired_at",
            "type": "string"
        },
        {
            "name": "pickedUpAt",
            "baseName": "picked_up_at",
            "type": "string"
        },
        {
            "name": "canceledAt",
            "baseName": "canceled_at",
            "type": "string"
        },
        {
            "name": "cancelReason",
            "baseName": "cancel_reason",
            "type": "string"
        },
        {
            "name": "isCurbsidePickup",
            "baseName": "is_curbside_pickup",
            "type": "boolean"
        },
        {
            "name": "curbsidePickupDetails",
            "baseName": "curbside_pickup_details",
            "type": "OrderFulfillmentPickupDetailsCurbsidePickupDetails"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentPickupDetails.attributeTypeMap;
    }
}

/**
* Specific details for curbside pickup.
*/
export class OrderFulfillmentPickupDetailsCurbsidePickupDetails {
    /**
    * Specific details for curbside pickup, such as parking number, vehicle model, etc.
    */
    'curbsideDetails'?: string;
    /**
    * The [timestamp](#workingwithdates) in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\", indicating when the buyer arrived and is waiting for pickup.
    */
    'buyerArrivedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "curbsideDetails",
            "baseName": "curbside_details",
            "type": "string"
        },
        {
            "name": "buyerArrivedAt",
            "baseName": "buyer_arrived_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentPickupDetailsCurbsidePickupDetails.attributeTypeMap;
    }
}

/**
* The schedule type of the pickup fulfillment.
*/
export class OrderFulfillmentPickupDetailsScheduleType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentPickupDetailsScheduleType.attributeTypeMap;
    }
}

/**
* Contains information on the recipient of a fulfillment.
*/
export class OrderFulfillmentRecipient {
    /**
    * The Customer ID of the customer associated with the fulfillment.  If `customer_id` is provided, the fulfillment recipient's `display_name`, `email_address`, and `phone_number` are automatically populated from the targeted customer profile. If these fields are set in the request, the request values will override the information from the customer profile. If the targeted customer profile does not contain the necessary information and these fields are left unset, the request will result in an error.
    */
    'customerId'?: string;
    /**
    * The display name of the fulfillment recipient.  If provided, overrides the value pulled from the customer profile indicated by `customer_id`.
    */
    'displayName'?: string;
    /**
    * The email address of the fulfillment recipient.  If provided, overrides the value pulled from the customer profile indicated by `customer_id`.
    */
    'emailAddress'?: string;
    /**
    * The phone number of the fulfillment recipient.  If provided, overrides the value pulled from the customer profile indicated by `customer_id`.
    */
    'phoneNumber'?: string;
    /**
    * The address of the fulfillment recipient.  If provided, overrides the value pulled from the customer profile indicated by `customer_id`.
    */
    'address'?: Address;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentRecipient.attributeTypeMap;
    }
}

/**
* Contains details necessary to fulfill a shipment order.
*/
export class OrderFulfillmentShipmentDetails {
    /**
    * Information on the person meant to receive this shipment fulfillment.
    */
    'recipient'?: OrderFulfillmentRecipient;
    /**
    * The shipping carrier being used to ship this fulfillment e.g. UPS, FedEx, USPS, etc.
    */
    'carrier'?: string;
    /**
    * A note with additional information for the shipping carrier.
    */
    'shippingNote'?: string;
    /**
    * A description of the type of shipping product purchased from the carrier. e.g. First Class, Priority, Express
    */
    'shippingType'?: string;
    /**
    * The reference number provided by the carrier to track the shipment's progress.
    */
    'trackingNumber'?: string;
    /**
    * A link to the tracking webpage on the carrier's website.
    */
    'trackingUrl'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the shipment was requested. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'placedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when this fulfillment was moved to the `RESERVED` state. Indicates that preparation of this shipment has begun. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'inProgressAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when this fulfillment was moved to the `PREPARED` state. Indicates that the fulfillment is packaged. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'packagedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the shipment is expected to be delivered to the shipping carrier. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'expectedShippedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when this fulfillment was moved to the `COMPLETED`state. Indicates that the fulfillment has been given to the shipping carrier. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'shippedAt'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating the shipment was canceled. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'canceledAt'?: string;
    /**
    * A description of why the shipment was canceled.
    */
    'cancelReason'?: string;
    /**
    * The [timestamp](#workingwithdates) indicating when the shipment failed to be completed. Must be in RFC 3339 timestamp format, e.g., \"2016-09-04T23:59:33.123Z\".
    */
    'failedAt'?: string;
    /**
    * A description of why the shipment failed to be completed.
    */
    'failureReason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "OrderFulfillmentRecipient"
        },
        {
            "name": "carrier",
            "baseName": "carrier",
            "type": "string"
        },
        {
            "name": "shippingNote",
            "baseName": "shipping_note",
            "type": "string"
        },
        {
            "name": "shippingType",
            "baseName": "shipping_type",
            "type": "string"
        },
        {
            "name": "trackingNumber",
            "baseName": "tracking_number",
            "type": "string"
        },
        {
            "name": "trackingUrl",
            "baseName": "tracking_url",
            "type": "string"
        },
        {
            "name": "placedAt",
            "baseName": "placed_at",
            "type": "string"
        },
        {
            "name": "inProgressAt",
            "baseName": "in_progress_at",
            "type": "string"
        },
        {
            "name": "packagedAt",
            "baseName": "packaged_at",
            "type": "string"
        },
        {
            "name": "expectedShippedAt",
            "baseName": "expected_shipped_at",
            "type": "string"
        },
        {
            "name": "shippedAt",
            "baseName": "shipped_at",
            "type": "string"
        },
        {
            "name": "canceledAt",
            "baseName": "canceled_at",
            "type": "string"
        },
        {
            "name": "cancelReason",
            "baseName": "cancel_reason",
            "type": "string"
        },
        {
            "name": "failedAt",
            "baseName": "failed_at",
            "type": "string"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentShipmentDetails.attributeTypeMap;
    }
}

/**
* The current state of this fulfillment.
*/
export class OrderFulfillmentState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentState.attributeTypeMap;
    }
}

/**
* The type of fulfillment.
*/
export class OrderFulfillmentType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentType.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderFulfillmentUpdated {
    /**
    * The order's unique ID.
    */
    'orderId'?: string;
    /**
    * Version number which is incremented each time an update is committed to the order. Orders that were not created through the API will not include a version and thus cannot be updated.  [Read more about working with versions](https://developer.squareup.com/docs/docs/orders-api/manage-orders#update-orders)
    */
    'version'?: number;
    /**
    * The ID of the merchant location this order is associated with.
    */
    'locationId'?: string;
    /**
    * The state of the order. See [OrderState](#type-orderstate) for possible values
    */
    'state'?: string;
    /**
    * Timestamp for when the order was created in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Timestamp for when the order was last updated in RFC 3339 format.
    */
    'updatedAt'?: string;
    /**
    * The fulfillments that were updated with this version change.
    */
    'fulfillmentUpdate'?: Array<OrderFulfillmentUpdatedUpdate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "fulfillmentUpdate",
            "baseName": "fulfillment_update",
            "type": "Array<OrderFulfillmentUpdatedUpdate>"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentUpdated.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderFulfillmentUpdatedObject {
    /**
    * Information about the updated order fulfillment.
    */
    'orderFulfillmentUpdated'?: OrderFulfillmentUpdated;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderFulfillmentUpdated",
            "baseName": "order_fulfillment_updated",
            "type": "OrderFulfillmentUpdated"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentUpdatedObject.attributeTypeMap;
    }
}

/**
* Information about fulfillment updates.
*/
export class OrderFulfillmentUpdatedUpdate {
    /**
    * Unique ID that identifies the fulfillment only within this order.
    */
    'fulfillmentUid'?: string;
    /**
    * The state of the fulfillment before the change. Will not be populated if the fulfillment is created with this new Order version. See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
    */
    'oldState'?: string;
    /**
    * The state of the fulfillment after the change. May be equal to old_state if a non-state field was changed on the fulfillment (e.g. tracking number). See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
    */
    'newState'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fulfillmentUid",
            "baseName": "fulfillment_uid",
            "type": "string"
        },
        {
            "name": "oldState",
            "baseName": "old_state",
            "type": "string"
        },
        {
            "name": "newState",
            "baseName": "new_state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentUpdatedUpdate.attributeTypeMap;
    }
}

/**
* Represents a line item in an order. Each line item describes a different product to purchase, with its own quantity and price details.
*/
export class OrderLineItem {
    /**
    * Unique ID that identifies the line item only within this order.
    */
    'uid'?: string;
    /**
    * The name of the line item.
    */
    'name'?: string;
    /**
    * The quantity purchased, formatted as a decimal number. For example: `\"3\"`.  Line items with a `quantity_unit` can have non-integer quantities. For example: `\"1.70000\"`.
    */
    'quantity': string;
    /**
    * The unit and precision that this line item's quantity is measured in.
    */
    'quantityUnit'?: OrderQuantityUnit;
    /**
    * The note of the line item.
    */
    'note'?: string;
    /**
    * The `CatalogItemVariation` id applied to this line item.
    */
    'catalogObjectId'?: string;
    /**
    * The name of the variation applied to this line item.
    */
    'variationName'?: string;
    /**
    * Application-defined data attached to this line item. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };
    /**
    * The `CatalogModifier`s applied to this line item.
    */
    'modifiers'?: Array<OrderLineItemModifier>;
    /**
    * The list of references to taxes applied to this line item. Each `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level `OrderLineItemTax` applied to the line item. On reads, the amount applied is populated.  An `OrderLineItemAppliedTax` will be automatically created on every line item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax` records for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any line items.  To change the amount of a tax, modify the referenced top-level tax.
    */
    'appliedTaxes'?: Array<OrderLineItemAppliedTax>;
    /**
    * The list of references to discounts applied to this line item. Each `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level `OrderLineItemDiscounts` applied to the line item. On reads, the amount applied is populated.  An `OrderLineItemAppliedDiscount` will be automatically created on every line item for all `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any line items.  To change the amount of a discount, modify the referenced top-level discount.
    */
    'appliedDiscounts'?: Array<OrderLineItemAppliedDiscount>;
    /**
    * The base price for a single unit of the line item.
    */
    'basePriceMoney'?: Money;
    /**
    * The total price of all item variations sold in this line item. Calculated as `base_price_money` multiplied by `quantity`. Does not include modifiers.
    */
    'variationTotalPriceMoney'?: Money;
    /**
    * The amount of money made in gross sales for this line item. Calculated as the sum of the variation's total price and each modifier's total price.
    */
    'grossSalesMoney'?: Money;
    /**
    * The total tax amount of money to collect for the line item.
    */
    'totalTaxMoney'?: Money;
    /**
    * The total discount amount of money to collect for the line item.
    */
    'totalDiscountMoney'?: Money;
    /**
    * The total amount of money to collect for this line item.
    */
    'totalMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "quantityUnit",
            "baseName": "quantity_unit",
            "type": "OrderQuantityUnit"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "variationName",
            "baseName": "variation_name",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "modifiers",
            "baseName": "modifiers",
            "type": "Array<OrderLineItemModifier>"
        },
        {
            "name": "appliedTaxes",
            "baseName": "applied_taxes",
            "type": "Array<OrderLineItemAppliedTax>"
        },
        {
            "name": "appliedDiscounts",
            "baseName": "applied_discounts",
            "type": "Array<OrderLineItemAppliedDiscount>"
        },
        {
            "name": "basePriceMoney",
            "baseName": "base_price_money",
            "type": "Money"
        },
        {
            "name": "variationTotalPriceMoney",
            "baseName": "variation_total_price_money",
            "type": "Money"
        },
        {
            "name": "grossSalesMoney",
            "baseName": "gross_sales_money",
            "type": "Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "Money"
        },
        {
            "name": "totalDiscountMoney",
            "baseName": "total_discount_money",
            "type": "Money"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItem.attributeTypeMap;
    }
}

/**
* Represents an applied portion of a discount to a line item in an order.  Order scoped discounts will automatically have applied discounts present for each line item. Line item scoped discounts must have applied discounts added manually for any applicable line items. The corresponding applied money will automatically be computed based on participating line items.
*/
export class OrderLineItemAppliedDiscount {
    /**
    * Unique ID that identifies the applied discount only within this order.
    */
    'uid'?: string;
    /**
    * The `uid` of the discount the applied discount represents. Must reference a discount present in the `order.discounts` field.  This field is immutable. To change which discounts apply to a line item, you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
    */
    'discountUid': string;
    /**
    * The amount of money applied by the discount to the line item.
    */
    'appliedMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "discountUid",
            "baseName": "discount_uid",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItemAppliedDiscount.attributeTypeMap;
    }
}

/**
* Represents an applied portion of a tax to a line item in an order.  Order-scoped taxes automatically include the applied taxes in each line item. Line item taxes must be referenced from any applicable line items. The corresponding applied money is automatically computed, based on the set of participating line items.
*/
export class OrderLineItemAppliedTax {
    /**
    * Unique ID that identifies the applied tax only within this order.
    */
    'uid'?: string;
    /**
    * The `uid` of the tax for which this applied tax represents.  Must reference a tax present in the `order.taxes` field.  This field is immutable. To change which taxes apply to a line item, delete and add new `OrderLineItemAppliedTax`s.
    */
    'taxUid': string;
    /**
    * The amount of money applied by the tax to the line item.
    */
    'appliedMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "taxUid",
            "baseName": "tax_uid",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItemAppliedTax.attributeTypeMap;
    }
}

/**
* Represents a discount that applies to one or more line items in an order.  Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals. The amount distributed to each line item is relative to the amount contributed by the item to the order subtotal.
*/
export class OrderLineItemDiscount {
    /**
    * Unique ID that identifies the discount only within this order.
    */
    'uid'?: string;
    /**
    * The catalog object id referencing `CatalogDiscount`.
    */
    'catalogObjectId'?: string;
    /**
    * The discount's name.
    */
    'name'?: string;
    /**
    * The type of the discount.  Discounts that don't reference a catalog object ID must have a type of `FIXED_PERCENTAGE` or `FIXED_AMOUNT`. See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
    */
    'type'?: string;
    /**
    * The percentage of the discount, as a string representation of a decimal number. A value of `7.25` corresponds to a percentage of 7.25%.  `percentage` is not set for amount-based discounts.
    */
    'percentage'?: string;
    /**
    * The total declared monetary amount of the discount.  `amount_money` is not set for percentage-based discounts.
    */
    'amountMoney'?: Money;
    /**
    * The amount of discount actually applied to the line item.  Represents the amount of money applied as a line item-scoped discount. When an amount-based discount is scoped to the entire order, the value of `applied_money` is different from `amount_money` because the total amount of the discount is distributed across all line items.
    */
    'appliedMoney'?: Money;
    /**
    * Application-defined data attached to this discount. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };
    /**
    * Indicates the level at which the discount applies. For `ORDER` scoped discounts, Square generates references in `applied_discounts` on all order line items that do not have them. For `LINE_ITEM` scoped discounts, the discount only applies to line items with a discount reference in their `applied_discounts` field.  This field is immutable. To change the scope of a discount you must delete the discount and re-add it as a new discount. See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
    */
    'scope'?: string;
    /**
    * The reward identifiers corresponding to this discount. The application and specification of discounts that have `reward_ids` are completely controlled by the backing criteria corresponding to the reward tiers of the rewards that are added to the order through the Loyalty API. To manually unapply discounts that are the result of added rewards, the rewards must be removed from the order through the Loyalty API.
    */
    'rewardIds'?: Array<string>;
    /**
    * The object identifier of a `pricing rule` to be applied automatically to this discount. The specification and application of the discounts, to which a `pricing_rule_id` is assigned, are completely controlled by the corresponding pricing rule.
    */
    'pricingRuleId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        },
        {
            "name": "rewardIds",
            "baseName": "reward_ids",
            "type": "Array<string>"
        },
        {
            "name": "pricingRuleId",
            "baseName": "pricing_rule_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItemDiscount.attributeTypeMap;
    }
}

/**
* Indicates whether this is a line item or order level discount.
*/
export class OrderLineItemDiscountScope {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderLineItemDiscountScope.attributeTypeMap;
    }
}

/**
* Indicates how the discount is applied to the associated line item or order.
*/
export class OrderLineItemDiscountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderLineItemDiscountType.attributeTypeMap;
    }
}

/**
* A [CatalogModifier](#type-catalogmodifier).
*/
export class OrderLineItemModifier {
    /**
    * Unique ID that identifies the modifier only within this order.
    */
    'uid'?: string;
    /**
    * The catalog object id referencing `CatalogModifier`.
    */
    'catalogObjectId'?: string;
    /**
    * The name of the item modifier.
    */
    'name'?: string;
    /**
    * The base price for the modifier.  `base_price_money` is required for ad hoc modifiers. If both `catalog_object_id` and `base_price_money` are set, `base_price_money` will override the predefined `CatalogModifier` price.
    */
    'basePriceMoney'?: Money;
    /**
    * The total price of the item modifier for its line item. This is the modifier's `base_price_money` multiplied by the line item's quantity.
    */
    'totalPriceMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "basePriceMoney",
            "baseName": "base_price_money",
            "type": "Money"
        },
        {
            "name": "totalPriceMoney",
            "baseName": "total_price_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItemModifier.attributeTypeMap;
    }
}

/**
* Represents a tax that applies to one or more line item in the order.  Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals. The amount distributed to each line item is relative to the amount the item contributes to the order subtotal.
*/
export class OrderLineItemTax {
    /**
    * Unique ID that identifies the tax only within this order.
    */
    'uid'?: string;
    /**
    * The catalog object id referencing `CatalogTax`.
    */
    'catalogObjectId'?: string;
    /**
    * The tax's name.
    */
    'name'?: string;
    /**
    * Indicates the calculation method used to apply the tax. See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
    */
    'type'?: string;
    /**
    * The percentage of the tax, as a string representation of a decimal number. For example, a value of `\"7.25\"` corresponds to a percentage of 7.25%.
    */
    'percentage'?: string;
    /**
    * Application-defined data attached to this tax. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };
    /**
    * The amount of the money applied by the tax in the order.
    */
    'appliedMoney'?: Money;
    /**
    * Indicates the level at which the tax applies. For `ORDER` scoped taxes, Square generates references in `applied_taxes` on all order line items that do not have them. For `LINE_ITEM` scoped taxes, the tax will only apply to line items with references in their `applied_taxes` field.  This field is immutable. To change the scope, you must delete the tax and re-add it as a new tax. See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
    */
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderLineItemTax.attributeTypeMap;
    }
}

/**
* Indicates whether this is a line item or order level tax.
*/
export class OrderLineItemTaxScope {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderLineItemTaxScope.attributeTypeMap;
    }
}

/**
* Indicates how the tax is applied to the associated line item or order.
*/
export class OrderLineItemTaxType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderLineItemTaxType.attributeTypeMap;
    }
}

/**
* A collection of various money amounts.
*/
export class OrderMoneyAmounts {
    /**
    * Total money.
    */
    'totalMoney'?: Money;
    /**
    * Money associated with taxes.
    */
    'taxMoney'?: Money;
    /**
    * Money associated with discounts.
    */
    'discountMoney'?: Money;
    /**
    * Money associated with tips.
    */
    'tipMoney'?: Money;
    /**
    * Money associated with service charges.
    */
    'serviceChargeMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        },
        {
            "name": "taxMoney",
            "baseName": "tax_money",
            "type": "Money"
        },
        {
            "name": "discountMoney",
            "baseName": "discount_money",
            "type": "Money"
        },
        {
            "name": "tipMoney",
            "baseName": "tip_money",
            "type": "Money"
        },
        {
            "name": "serviceChargeMoney",
            "baseName": "service_charge_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderMoneyAmounts.attributeTypeMap;
    }
}

/**
* Pricing options for an order. The options affect how the order's price is calculated. They can be used, for example, to apply automatic price adjustments that are based on pre-configured [pricing rules](/reference/square/objects/CatalogPricingRule).
*/
export class OrderPricingOptions {
    /**
    * The option to determine whether or not pricing rule-based discounts are automatically applied to an order.
    */
    'autoApplyDiscounts'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoApplyDiscounts",
            "baseName": "auto_apply_discounts",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderPricingOptions.attributeTypeMap;
    }
}

/**
* Contains the measurement unit for a quantity and a precision which specifies the number of digits after the decimal point for decimal quantities.
*/
export class OrderQuantityUnit {
    /**
    * A `MeasurementUnit` that represents the unit of measure for the quantity.
    */
    'measurementUnit'?: MeasurementUnit;
    /**
    * For non-integer quantities, represents the number of digits after the decimal point that are recorded for this quantity.  For example, a precision of 1 allows quantities like `\"1.0\"` and `\"1.1\"`, but not `\"1.01\"`.  Min: 0. Max: 5.
    */
    'precision'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "measurementUnit",
            "baseName": "measurement_unit",
            "type": "MeasurementUnit"
        },
        {
            "name": "precision",
            "baseName": "precision",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderQuantityUnit.attributeTypeMap;
    }
}

/**
* The set of line items, service charges, taxes, discounts, tips, etc. being returned in an Order.
*/
export class OrderReturn {
    /**
    * Unique ID that identifies the return only within this order.
    */
    'uid'?: string;
    /**
    * Order which contains the original sale of these returned line items. This will be unset for unlinked returns.
    */
    'sourceOrderId'?: string;
    /**
    * Collection of line items which are being returned.
    */
    'returnLineItems'?: Array<OrderReturnLineItem>;
    /**
    * Collection of service charges which are being returned.
    */
    'returnServiceCharges'?: Array<OrderReturnServiceCharge>;
    /**
    * Collection of references to taxes being returned for an order, including the total applied tax amount to be returned. The taxes must reference a top-level tax ID from the source order.
    */
    'returnTaxes'?: Array<OrderReturnTax>;
    /**
    * Collection of references to discounts being returned for an order, including the total applied discount amount to be returned. The discounts must reference a top-level discount ID from the source order.
    */
    'returnDiscounts'?: Array<OrderReturnDiscount>;
    /**
    * A positive or negative rounding adjustment to the total value being returned. Commonly used to apply Cash Rounding when the minimum unit of account is smaller than the lowest physical denomination of currency.
    */
    'roundingAdjustment'?: OrderRoundingAdjustment;
    /**
    * Aggregate monetary value being returned by this Return entry.
    */
    'returnAmounts'?: OrderMoneyAmounts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceOrderId",
            "baseName": "source_order_id",
            "type": "string"
        },
        {
            "name": "returnLineItems",
            "baseName": "return_line_items",
            "type": "Array<OrderReturnLineItem>"
        },
        {
            "name": "returnServiceCharges",
            "baseName": "return_service_charges",
            "type": "Array<OrderReturnServiceCharge>"
        },
        {
            "name": "returnTaxes",
            "baseName": "return_taxes",
            "type": "Array<OrderReturnTax>"
        },
        {
            "name": "returnDiscounts",
            "baseName": "return_discounts",
            "type": "Array<OrderReturnDiscount>"
        },
        {
            "name": "roundingAdjustment",
            "baseName": "rounding_adjustment",
            "type": "OrderRoundingAdjustment"
        },
        {
            "name": "returnAmounts",
            "baseName": "return_amounts",
            "type": "OrderMoneyAmounts"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturn.attributeTypeMap;
    }
}

/**
* Represents a discount being returned that applies to one or more return line items in an order.  Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals. The amount distributed to each return line item is relative to that itemâ€™s contribution to the order subtotal.
*/
export class OrderReturnDiscount {
    /**
    * Unique ID that identifies the return discount only within this order.
    */
    'uid'?: string;
    /**
    * `uid` of the Discount from the Order which contains the original application of this discount.
    */
    'sourceDiscountUid'?: string;
    /**
    * The catalog object id referencing `CatalogDiscount`.
    */
    'catalogObjectId'?: string;
    /**
    * The discount's name.
    */
    'name'?: string;
    /**
    * The type of the discount. If it is created by API, it would be either `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.  Discounts that don't reference a catalog object ID must have a type of `FIXED_PERCENTAGE` or `FIXED_AMOUNT`. See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
    */
    'type'?: string;
    /**
    * The percentage of the tax, as a string representation of a decimal number. A value of `7.25` corresponds to a percentage of 7.25%.  `percentage` is not set for amount-based discounts.
    */
    'percentage'?: string;
    /**
    * The total declared monetary amount of the discount.  `amount_money` is not set for percentage-based discounts.
    */
    'amountMoney'?: Money;
    /**
    * The amount of discount actually applied to this line item. When an amount-based discount is at order-level, this value is different from `amount_money` because the discount is distributed across the line items.
    */
    'appliedMoney'?: Money;
    /**
    * Indicates the level at which the `OrderReturnDiscount` applies. For `ORDER` scoped discounts, the server will generate references in `applied_discounts` on all `OrderReturnLineItem`s. For `LINE_ITEM` scoped discounts, the discount will only apply to `OrderReturnLineItem`s with references in their `applied_discounts` field. See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
    */
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceDiscountUid",
            "baseName": "source_discount_uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturnDiscount.attributeTypeMap;
    }
}

/**
* The line item being returned in an Order.
*/
export class OrderReturnLineItem {
    /**
    * Unique identifier for this return line item entry.
    */
    'uid'?: string;
    /**
    * `uid` of the LineItem in the original sale Order.
    */
    'sourceLineItemUid'?: string;
    /**
    * The name of the line item.
    */
    'name'?: string;
    /**
    * The quantity returned, formatted as a decimal number. For example: `\"3\"`.  Line items with a `quantity_unit` can have non-integer quantities. For example: `\"1.70000\"`.
    */
    'quantity': string;
    /**
    * The unit and precision that this return line item's quantity is measured in.
    */
    'quantityUnit'?: OrderQuantityUnit;
    /**
    * The note of the returned line item.
    */
    'note'?: string;
    /**
    * The `CatalogItemVariation` id applied to this returned line item.
    */
    'catalogObjectId'?: string;
    /**
    * The name of the variation applied to this returned line item.
    */
    'variationName'?: string;
    /**
    * The `CatalogModifier`s applied to this line item.
    */
    'returnModifiers'?: Array<OrderReturnLineItemModifier>;
    /**
    * The list of references to `OrderReturnTax` entities applied to the returned line item. Each `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level `OrderReturnTax` applied to the returned line item. On reads, the amount applied is populated.
    */
    'appliedTaxes'?: Array<OrderLineItemAppliedTax>;
    /**
    * The list of references to `OrderReturnDiscount` entities applied to the returned line item. Each `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level `OrderReturnDiscount` applied to the returned line item. On reads, the amount applied is populated.
    */
    'appliedDiscounts'?: Array<OrderLineItemAppliedDiscount>;
    /**
    * The base price for a single unit of the line item.
    */
    'basePriceMoney'?: Money;
    /**
    * The total price of all item variations returned in this line item. Calculated as `base_price_money` multiplied by `quantity`. Does not include modifiers.
    */
    'variationTotalPriceMoney'?: Money;
    /**
    * The gross return amount of money calculated as (item base price + modifiers price) * quantity.
    */
    'grossReturnMoney'?: Money;
    /**
    * The total tax amount of money to return for the line item.
    */
    'totalTaxMoney'?: Money;
    /**
    * The total discount amount of money to return for the line item.
    */
    'totalDiscountMoney'?: Money;
    /**
    * The total amount of money to return for this line item.
    */
    'totalMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceLineItemUid",
            "baseName": "source_line_item_uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "string"
        },
        {
            "name": "quantityUnit",
            "baseName": "quantity_unit",
            "type": "OrderQuantityUnit"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "variationName",
            "baseName": "variation_name",
            "type": "string"
        },
        {
            "name": "returnModifiers",
            "baseName": "return_modifiers",
            "type": "Array<OrderReturnLineItemModifier>"
        },
        {
            "name": "appliedTaxes",
            "baseName": "applied_taxes",
            "type": "Array<OrderLineItemAppliedTax>"
        },
        {
            "name": "appliedDiscounts",
            "baseName": "applied_discounts",
            "type": "Array<OrderLineItemAppliedDiscount>"
        },
        {
            "name": "basePriceMoney",
            "baseName": "base_price_money",
            "type": "Money"
        },
        {
            "name": "variationTotalPriceMoney",
            "baseName": "variation_total_price_money",
            "type": "Money"
        },
        {
            "name": "grossReturnMoney",
            "baseName": "gross_return_money",
            "type": "Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "Money"
        },
        {
            "name": "totalDiscountMoney",
            "baseName": "total_discount_money",
            "type": "Money"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturnLineItem.attributeTypeMap;
    }
}

/**
* A line item modifier being returned.
*/
export class OrderReturnLineItemModifier {
    /**
    * Unique ID that identifies the return modifier only within this order.
    */
    'uid'?: string;
    /**
    * `uid` of the Modifier from the LineItem from the Order which contains the original sale of this line item modifier.
    */
    'sourceModifierUid'?: string;
    /**
    * The catalog object id referencing `CatalogModifier`.
    */
    'catalogObjectId'?: string;
    /**
    * The name of the item modifier.
    */
    'name'?: string;
    /**
    * The base price for the modifier.  `base_price_money` is required for ad hoc modifiers. If both `catalog_object_id` and `base_price_money` are set, `base_price_money` will override the predefined `CatalogModifier` price.
    */
    'basePriceMoney'?: Money;
    /**
    * The total price of the item modifier for its line item. This is the modifier's `base_price_money` multiplied by the line item's quantity.
    */
    'totalPriceMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceModifierUid",
            "baseName": "source_modifier_uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "basePriceMoney",
            "baseName": "base_price_money",
            "type": "Money"
        },
        {
            "name": "totalPriceMoney",
            "baseName": "total_price_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturnLineItemModifier.attributeTypeMap;
    }
}

/**
* Represents the service charge applied to the original order.
*/
export class OrderReturnServiceCharge {
    /**
    * Unique ID that identifies the return service charge only within this order.
    */
    'uid'?: string;
    /**
    * `uid` of the Service Charge from the Order containing the original charge of the service charge. `source_service_charge_uid` is `null` for unlinked returns.
    */
    'sourceServiceChargeUid'?: string;
    /**
    * The name of the service charge.
    */
    'name'?: string;
    /**
    * The catalog object ID of the associated `CatalogServiceCharge`.
    */
    'catalogObjectId'?: string;
    /**
    * The percentage of the service charge, as a string representation of a decimal number. For example, a value of `\"7.25\"` corresponds to a percentage of 7.25%.  Exactly one of `percentage` or `amount_money` should be set.
    */
    'percentage'?: string;
    /**
    * The amount of a non-percentage based service charge.  Exactly one of `percentage` or `amount_money` should be set.
    */
    'amountMoney'?: Money;
    /**
    * The amount of money applied to the order by the service charge, including any inclusive tax amounts, as calculated by Square.  - For fixed-amount service charges, `applied_money` is equal to `amount_money`. - For percentage-based service charges, `applied_money` is the money calculated using the percentage.
    */
    'appliedMoney'?: Money;
    /**
    * The total amount of money to collect for the service charge.  __NOTE__: if an inclusive tax is applied to the service charge, `total_money` does not equal `applied_money` plus `total_tax_money` since the inclusive tax amount will already be included in both `applied_money` and `total_tax_money`.
    */
    'totalMoney'?: Money;
    /**
    * The total amount of tax money to collect for the service charge.
    */
    'totalTaxMoney'?: Money;
    /**
    * The calculation phase after which to apply the service charge. See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
    */
    'calculationPhase'?: string;
    /**
    * Indicates whether the surcharge can be taxed. Service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
    */
    'taxable'?: boolean;
    /**
    * The list of references to `OrderReturnTax` entities applied to the `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level `OrderReturnTax` that is being applied to the `OrderReturnServiceCharge`. On reads, the amount applied is populated.
    */
    'appliedTaxes'?: Array<OrderLineItemAppliedTax>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceServiceChargeUid",
            "baseName": "source_service_charge_uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "Money"
        },
        {
            "name": "calculationPhase",
            "baseName": "calculation_phase",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "appliedTaxes",
            "baseName": "applied_taxes",
            "type": "Array<OrderLineItemAppliedTax>"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturnServiceCharge.attributeTypeMap;
    }
}

/**
* Represents a tax being returned that applies to one or more return line items in an order.  Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals. The amount distributed to each return line item is relative to that itemâ€™s contribution to the order subtotal.
*/
export class OrderReturnTax {
    /**
    * Unique ID that identifies the return tax only within this order.
    */
    'uid'?: string;
    /**
    * `uid` of the Tax from the Order which contains the original charge of this tax.
    */
    'sourceTaxUid'?: string;
    /**
    * The catalog object id referencing `CatalogTax`.
    */
    'catalogObjectId'?: string;
    /**
    * The tax's name.
    */
    'name'?: string;
    /**
    * Indicates the calculation method used to apply the tax. See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
    */
    'type'?: string;
    /**
    * The percentage of the tax, as a string representation of a decimal number. For example, a value of `\"7.25\"` corresponds to a percentage of 7.25%.
    */
    'percentage'?: string;
    /**
    * The amount of the money applied by the tax in an order.
    */
    'appliedMoney'?: Money;
    /**
    * Indicates the level at which the `OrderReturnTax` applies. For `ORDER` scoped taxes, Square generates references in `applied_taxes` on all `OrderReturnLineItem`s. For `LINE_ITEM` scoped taxes, the tax will only apply to `OrderReturnLineItem`s with references in their `applied_discounts` field. See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
    */
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "sourceTaxUid",
            "baseName": "source_tax_uid",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderReturnTax.attributeTypeMap;
    }
}

/**
* Represents a reward that may be applied to an order if the necessary reward tier criteria are met. Rewards are created through the Loyalty API.
*/
export class OrderReward {
    /**
    * The identifier of the reward.
    */
    'id': string;
    /**
    * The identifier of the reward tier corresponding to this reward.
    */
    'rewardTierId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "rewardTierId",
            "baseName": "reward_tier_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderReward.attributeTypeMap;
    }
}

/**
* A rounding adjustment of the money being returned. Commonly used to apply Cash Rounding when the minimum unit of account is smaller than the lowest physical denomination of currency.
*/
export class OrderRoundingAdjustment {
    /**
    * Unique ID that identifies the rounding adjustment only within this order.
    */
    'uid'?: string;
    /**
    * The name of the rounding adjustment from the original sale Order.
    */
    'name'?: string;
    /**
    * Actual rounding adjustment amount.
    */
    'amountMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return OrderRoundingAdjustment.attributeTypeMap;
    }
}

/**
* Represents a service charge applied to an order.
*/
export class OrderServiceCharge {
    /**
    * Unique ID that identifies the service charge only within this order.
    */
    'uid'?: string;
    /**
    * The name of the service charge.
    */
    'name'?: string;
    /**
    * The catalog object ID referencing the service charge `CatalogObject`.
    */
    'catalogObjectId'?: string;
    /**
    * The service charge percentage as a string representation of a decimal number. For example, `\"7.25\"` indicates a service charge of 7.25%.  Exactly 1 of `percentage` or `amount_money` should be set.
    */
    'percentage'?: string;
    /**
    * The amount of a non-percentage based service charge.  Exactly one of `percentage` or `amount_money` should be set.
    */
    'amountMoney'?: Money;
    /**
    * The amount of money applied to the order by the service charge, including any inclusive tax amounts, as calculated by Square.  - For fixed-amount service charges, `applied_money` is equal to `amount_money`. - For percentage-based service charges, `applied_money` is the money calculated using the percentage.
    */
    'appliedMoney'?: Money;
    /**
    * The total amount of money to collect for the service charge.  __Note__: if an inclusive tax is applied to the service charge, `total_money` __does not__ equal `applied_money` plus `total_tax_money` since the inclusive tax amount will already be included in both `applied_money` and `total_tax_money`.
    */
    'totalMoney'?: Money;
    /**
    * The total amount of tax money to collect for the service charge.
    */
    'totalTaxMoney'?: Money;
    /**
    * The calculation phase at which to apply the service charge. See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
    */
    'calculationPhase'?: string;
    /**
    * Indicates whether the service charge can be taxed. If set to `true`, order-level taxes automatically apply to the service charge. Note that service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
    */
    'taxable'?: boolean;
    /**
    * The list of references to taxes applied to this service charge. Each `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied is populated.  An `OrderLineItemAppliedTax` will be automatically created on every taxable service charge for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable service charge.  Taxable service charges have the `taxable` field set to true and calculated in the `SUBTOTAL_PHASE`.  To change the amount of a tax, modify the referenced top-level tax.
    */
    'appliedTaxes'?: Array<OrderLineItemAppliedTax>;
    /**
    * Application-defined data attached to this service charge. Metadata fields are intended to store descriptive references or associations with an entity in another system or store brief information about the object. Square does not process this field; it only stores and returns it in relevant API calls. Do not use metadata to store any sensitive information (personally identifiable information, card details, etc.).  Keys written by applications must be 60 characters or less and must be in the character set `[a-zA-Z0-9_-]`. Entries may also include metadata generated by Square. These keys are prefixed with a namespace, separated from the key with a ':' character.  Values have a max length of 255 characters.  An application may have up to 10 entries per metadata field.  Entries written by applications are private and can only be read or modified by the same application.  See [Metadata](https://developer.squareup.com/docs/build-basics/metadata) for more information.
    */
    'metadata'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "catalogObjectId",
            "baseName": "catalog_object_id",
            "type": "string"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "Money"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "Money"
        },
        {
            "name": "calculationPhase",
            "baseName": "calculation_phase",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "appliedTaxes",
            "baseName": "applied_taxes",
            "type": "Array<OrderLineItemAppliedTax>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return OrderServiceCharge.attributeTypeMap;
    }
}

/**
* Represents a phase in the process of calculating order totals. Service charges are applied __after__ the indicated phase.  [Read more about how order totals are calculated.](https://developer.squareup.com/docs/docs/orders-api/how-it-works#how-totals-are-calculated)
*/
export class OrderServiceChargeCalculationPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderServiceChargeCalculationPhase.attributeTypeMap;
    }
}

/**
* Represents the origination details of an order.
*/
export class OrderSource {
    /**
    * The name used to identify the place (physical or digital) that an order originates. If unset, the name defaults to the name of the application that created the order.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderSource.attributeTypeMap;
    }
}

/**
* The state of the order.
*/
export class OrderState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OrderState.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderUpdated {
    /**
    * The order's unique ID.
    */
    'orderId'?: string;
    /**
    * Version number which is incremented each time an update is committed to the order. Orders that were not created through the API will not include a version and thus cannot be updated.  [Read more about working with versions](https://developer.squareup.com/docs/docs/orders-api/manage-orders#update-orders)
    */
    'version'?: number;
    /**
    * The ID of the merchant location this order is associated with.
    */
    'locationId'?: string;
    /**
    * The state of the order. See [OrderState](#type-orderstate) for possible values
    */
    'state'?: string;
    /**
    * Timestamp for when the order was created in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Timestamp for when the order was last updated in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderUpdated.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderUpdatedObject {
    /**
    * Information about the updated order.
    */
    'orderUpdated'?: OrderUpdated;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderUpdated",
            "baseName": "order_updated",
            "type": "OrderUpdated"
        }    ];

    static getAttributeTypeMap() {
        return OrderUpdatedObject.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the [PayOrder](#endpoint-payorder) endpoint.
*/
export class PayOrderRequest {
    /**
    * A value you specify that uniquely identifies this request among requests you've sent. If you're unsure whether a particular payment request was completed successfully, you can reattempt it with the same idempotency key without worrying about duplicate payments.  See [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * The version of the order being paid. If not supplied, the latest version will be paid.
    */
    'orderVersion'?: number;
    /**
    * The IDs of the `payments` to collect. The payment total must match the order total.
    */
    'paymentIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "orderVersion",
            "baseName": "order_version",
            "type": "number"
        },
        {
            "name": "paymentIds",
            "baseName": "payment_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PayOrderRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [PayOrder](#endpoint-payorder) endpoint.
*/
export class PayOrderResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The paid, updated `order`.
    */
    'order'?: Order;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return PayOrderResponse.attributeTypeMap;
    }
}

/**
* Represents a payment processed by the Square API.
*/
export class Payment {
    /**
    * Unique ID for the payment.
    */
    'id'?: string;
    /**
    * Timestamp of when the payment was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Timestamp of when the payment was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;
    /**
    * The amount of money processed for this payment, not including `tip_money`. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. For more information, see [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
    */
    'amountMoney'?: Money;
    /**
    * The amount designated as a tip. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.
    */
    'tipMoney'?: Money;
    /**
    * The total money for the payment, including `amount_money` and `tip_money`. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.
    */
    'totalMoney'?: Money;
    /**
    * The amount of money the developer is taking as a fee for facilitating the payment on behalf of the seller. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.  For more information, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).  Cannot be more than 90% of the `total_money` value.
    */
    'appFeeMoney'?: Money;
    /**
    * Processing fees and fee adjustments assessed by Square on this payment.
    */
    'processingFee'?: Array<ProcessingFee>;
    /**
    * Total amount of the payment refunded to-date. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.
    */
    'refundedMoney'?: Money;
    /**
    * Indicates whether the payment is `APPROVED`, `COMPLETED`, `CANCELED`, or `FAILED`.
    */
    'status'?: string;
    /**
    * The duration of time after the payment's creation when Square automatically applies the `delay_action` to the payment. This automatic `delay_action` applies only to payments that don't reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration` time period.  This field is specified as a time duration, in RFC 3339 format.  Notes: This feature is only supported for card payments.  Default:  - Card Present payments: \"PT36H\" (36 hours) from the creation time. - Card Not Present payments: \"P7D\" (7 days) from the creation time.
    */
    'delayDuration'?: string;
    /**
    * The action to be applied to the payment when the `delay_duration` has elapsed. This field is read only.  Current values include: `CANCEL`
    */
    'delayAction'?: string;
    /**
    * Read only timestamp of when the `delay_action` will automatically be applied, in RFC 3339 format.  Note that this field is calculated by summing the payment's `delay_duration` and `created_at` fields. The `created_at` field is generated by Square and may not exactly match the time on your local machine.
    */
    'delayedUntil'?: string;
    /**
    * The source type for this payment  Current values include: `CARD`.
    */
    'sourceType'?: string;
    /**
    * Non-confidential details about the source. Only populated if the `source_type` is `CARD`.
    */
    'cardDetails'?: CardPaymentDetails;
    /**
    * ID of the location associated with the payment.
    */
    'locationId'?: string;
    /**
    * ID of the order associated with this payment.
    */
    'orderId'?: string;
    /**
    * An optional ID that associates this payment with an entity in another system.
    */
    'referenceId'?: string;
    /**
    * The `Customer` ID of the customer associated with the payment.
    */
    'customerId'?: string;
    /**
    * An optional ID of the employee associated with taking this payment.
    */
    'employeeId'?: string;
    /**
    * List of `refund_id`s identifying refunds for this payment.
    */
    'refundIds'?: Array<string>;
    /**
    * The buyer's e-mail address
    */
    'buyerEmailAddress'?: string;
    /**
    * The buyer's billing address
    */
    'billingAddress'?: Address;
    /**
    * The buyer's shipping address
    */
    'shippingAddress'?: Address;
    /**
    * An optional note to include when creating a payment
    */
    'note'?: string;
    /**
    * Additional payment information that gets added on the customer's card statement as part of the statement description.  Note that the `statement_description_identifier` may get truncated on the statement description to fit the required information including the Square identifier (SQ *) and name of the merchant taking the payment.
    */
    'statementDescriptionIdentifier'?: string;
    /**
    * The payment's receipt number. The field will be missing if a payment is CANCELED
    */
    'receiptNumber'?: string;
    /**
    * The URL for the payment's receipt. The field will only be populated for COMPLETED payments.
    */
    'receiptUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "tipMoney",
            "baseName": "tip_money",
            "type": "Money"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "Money"
        },
        {
            "name": "appFeeMoney",
            "baseName": "app_fee_money",
            "type": "Money"
        },
        {
            "name": "processingFee",
            "baseName": "processing_fee",
            "type": "Array<ProcessingFee>"
        },
        {
            "name": "refundedMoney",
            "baseName": "refunded_money",
            "type": "Money"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "delayDuration",
            "baseName": "delay_duration",
            "type": "string"
        },
        {
            "name": "delayAction",
            "baseName": "delay_action",
            "type": "string"
        },
        {
            "name": "delayedUntil",
            "baseName": "delayed_until",
            "type": "string"
        },
        {
            "name": "sourceType",
            "baseName": "source_type",
            "type": "string"
        },
        {
            "name": "cardDetails",
            "baseName": "card_details",
            "type": "CardPaymentDetails"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "refundIds",
            "baseName": "refund_ids",
            "type": "Array<string>"
        },
        {
            "name": "buyerEmailAddress",
            "baseName": "buyer_email_address",
            "type": "string"
        },
        {
            "name": "billingAddress",
            "baseName": "billing_address",
            "type": "Address"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "statementDescriptionIdentifier",
            "baseName": "statement_description_identifier",
            "type": "string"
        },
        {
            "name": "receiptNumber",
            "baseName": "receipt_number",
            "type": "string"
        },
        {
            "name": "receiptUrl",
            "baseName": "receipt_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Payment.attributeTypeMap;
    }
}

/**
* 
*/
export class PaymentOptions {
    /**
    * Indicates whether the Payment objects created from this `TerminalCheckout` will automatically be COMPLETED or left in an APPROVED state for later modification.
    */
    'autocomplete'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autocomplete",
            "baseName": "autocomplete",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentOptions.attributeTypeMap;
    }
}

/**
* Represents a refund of a payment made using Square. Contains information on the original payment and the amount of money refunded.
*/
export class PaymentRefund {
    /**
    * Unique ID for this refund, generated by Square.
    */
    'id': string;
    /**
    * The refund's status: - `PENDING` - awaiting approval - `COMPLETED` - successfully completed - `REJECTED` - the refund was rejected - `FAILED` - an error occurred
    */
    'status'?: string;
    /**
    * Location ID associated with the payment this refund is attached to.
    */
    'locationId'?: string;
    /**
    * The amount of money refunded, specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.
    */
    'amountMoney': Money;
    /**
    * Amount of money the app developer contributed to help cover the refunded amount. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.
    */
    'appFeeMoney'?: Money;
    /**
    * Processing fees and fee adjustments assessed by Square on this refund.
    */
    'processingFee'?: Array<ProcessingFee>;
    /**
    * The ID of the payment assocated with this refund.
    */
    'paymentId'?: string;
    /**
    * The ID of the order associated with the refund.
    */
    'orderId'?: string;
    /**
    * The reason for the refund.
    */
    'reason'?: string;
    /**
    * Timestamp of when the refund was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * Timestamp of when the refund was last updated, in RFC 3339 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appFeeMoney",
            "baseName": "app_fee_money",
            "type": "Money"
        },
        {
            "name": "processingFee",
            "baseName": "processing_fee",
            "type": "Array<ProcessingFee>"
        },
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentRefund.attributeTypeMap;
    }
}

/**
* Represents Square processing fee.
*/
export class ProcessingFee {
    /**
    * Timestamp of when the fee takes effect, in RFC 3339 format.
    */
    'effectiveAt'?: string;
    /**
    * The type of fee assessed or adjusted. Can be one of: `INITIAL`, `ADJUSTMENT`.
    */
    'type'?: string;
    /**
    * The fee amount assessed or adjusted by Square. May be negative.  Positive values represent funds being assessed, while negative values represent funds being returned.
    */
    'amountMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "effectiveAt",
            "baseName": "effective_at",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return ProcessingFee.attributeTypeMap;
    }
}

/**
* Indicates the Square product used to generate an inventory change.
*/
export class Product {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Product.attributeTypeMap;
    }
}

/**
* 
*/
export class ProductType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ProductType.attributeTypeMap;
    }
}

/**
* Describes a `PublishInvoice` request.
*/
export class PublishInvoiceRequest {
    /**
    * The version of the `Invoice` to publish. This must match the current version of the invoice, otherwise the request is rejected.
    */
    'version': number;
    /**
    * A unique string that identifies the `PublishInvoice` request. If you do not  provide `idempotency_key` (or provide an empty string as the value), the endpoint  treats each request as independent.  For more information, see [Idempotency](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PublishInvoiceRequest.attributeTypeMap;
    }
}

/**
* Describes a `PublishInvoice` response.
*/
export class PublishInvoiceResponse {
    /**
    * The published invoice.
    */
    'invoice'?: Invoice;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return PublishInvoiceResponse.attributeTypeMap;
    }
}

/**
* The range of a number value between the specified lower and upper bounds.
*/
export class Range {
    /**
    * The lower bound of the number range.
    */
    'min'?: string;
    /**
    * The upper bound of the number range.
    */
    'max'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "min",
            "baseName": "min",
            "type": "string"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

/**
* A request to redeem a loyalty reward.
*/
export class RedeemLoyaltyRewardRequest {
    /**
    * A unique string that identifies this `RedeemLoyaltyReward` request.  Keys can be any valid string, but must be unique for every request.
    */
    'idempotencyKey': string;
    /**
    * The ID of the `location` where the reward is redeemed.
    */
    'locationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RedeemLoyaltyRewardRequest.attributeTypeMap;
    }
}

/**
* A response that includes the `LoyaltyEvent` published for redeeming the reward.
*/
export class RedeemLoyaltyRewardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The `LoyaltyEvent` for redeeming the reward.
    */
    'event'?: LoyaltyEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "LoyaltyEvent"
        }    ];

    static getAttributeTypeMap() {
        return RedeemLoyaltyRewardResponse.attributeTypeMap;
    }
}

/**
* Represents a refund processed for a Square transaction.
*/
export class Refund {
    /**
    * The refund's unique ID.
    */
    'id': string;
    /**
    * The ID of the refund's associated location.
    */
    'locationId': string;
    /**
    * The ID of the transaction that the refunded tender is part of.
    */
    'transactionId': string;
    /**
    * The ID of the refunded tender.
    */
    'tenderId': string;
    /**
    * The timestamp for when the refund was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The reason for the refund being issued.
    */
    'reason': string;
    /**
    * The amount of money refunded to the buyer.
    */
    'amountMoney': Money;
    /**
    * The current status of the refund (`PENDING`, `APPROVED`, `REJECTED`, or `FAILED`). See [RefundStatus](#type-refundstatus) for possible values
    */
    'status': string;
    /**
    * The amount of Square processing fee money refunded to the *merchant*.
    */
    'processingFeeMoney'?: Money;
    /**
    * Additional recipients (other than the merchant) receiving a portion of this refund. For example, fees assessed on a refund of a purchase by a third party integration.
    */
    'additionalRecipients'?: Array<AdditionalRecipient>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "tenderId",
            "baseName": "tender_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processingFeeMoney",
            "baseName": "processing_fee_money",
            "type": "Money"
        },
        {
            "name": "additionalRecipients",
            "baseName": "additional_recipients",
            "type": "Array<AdditionalRecipient>"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

/**
* Refunds a payment.
*/
export class RefundPaymentRequest {
    /**
    *  A unique string that identifies this RefundPayment request. Key can be any valid string but must be unique for every RefundPayment request.  For more information, see [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency).
    */
    'idempotencyKey': string;
    /**
    * The amount of money to refund.  Cannot be more than the `total_money` value of the payment minus the total amount of all previously completed refunds for this payment.  Must be specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents. See [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.  The currency code must match the currency associated with the business that is charging the card.
    */
    'amountMoney': Money;
    /**
    * Amount of money the developer will contribute to help cover the refunded amount. Specified in the smallest denomination of the applicable currency. For example, US dollar amounts are specified in cents.  Value cannot be more than the `amount_money`.  You can specify this parameter in a refund request only if the same parameter was also included when taking the payment. This is part of the application fee  scenario the API supports. For more information, see [Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees)
    */
    'appFeeMoney'?: Money;
    /**
    * Unique ID of the payment being refunded.
    */
    'paymentId': string;
    /**
    * A description of the reason for the refund.
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "appFeeMoney",
            "baseName": "app_fee_money",
            "type": "Money"
        },
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefundPaymentRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [RefundPayment](#endpoint-refunds-refundpayment) endpoint.  Note: if there are errors processing the request, the refund field may not be present, or it may be present in a FAILED state.
*/
export class RefundPaymentResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The successfully created `PaymentRefund`.
    */
    'refund'?: PaymentRefund;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "refund",
            "baseName": "refund",
            "type": "PaymentRefund"
        }    ];

    static getAttributeTypeMap() {
        return RefundPaymentResponse.attributeTypeMap;
    }
}

/**
* Indicates a refund's current status.
*/
export class RefundStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RefundStatus.attributeTypeMap;
    }
}

/**
* Defines the parameters that can be included in the body of a request to the [RegisterDomain](#endpoint-registerdomain) endpoint.
*/
export class RegisterDomainRequest {
    /**
    * A domain name as described in RFC-1034 that will be registered with ApplePay
    */
    'domainName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domainName",
            "baseName": "domain_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RegisterDomainRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [RegisterDomain](#endpoint-registerdomain) endpoint.  Either `errors` or `status` will be present in a given response (never both).
*/
export class RegisterDomainResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * Status of the domain registration.  See `RegisterDomainResponseStatus` for possible values. See [RegisterDomainResponseStatus](#type-registerdomainresponsestatus) for possible values
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RegisterDomainResponse.attributeTypeMap;
    }
}

/**
* The status of domain registration.
*/
export class RegisterDomainResponseStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RegisterDomainResponseStatus.attributeTypeMap;
    }
}

/**
* Defines parameters for a RemoveDisputeEvidence request.
*/
export class RemoveDisputeEvidenceRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RemoveDisputeEvidenceRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a RemoveDisputeEvidence response.
*/
export class RemoveDisputeEvidenceResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RemoveDisputeEvidenceResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the request body of a request to the [RemoveGroupFromCustomer](#endpoint-removegroupfromcustomer) endpoint.
*/
export class RemoveGroupFromCustomerRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RemoveGroupFromCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [RemoveGroupFromCustomer](#endpoint-removegroupfromcustomer) endpoint.
*/
export class RemoveGroupFromCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RemoveGroupFromCustomerResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RenewTokenRequest {
    /**
    * The token you want to renew.
    */
    'accessToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RenewTokenRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RenewTokenResponse {
    /**
    * The renewed access token. This value might be different from the `access_token` you provided in your request. You provide this token in a header with every request to Connect API endpoints. See [Request and response headers](https://developer.squareup.com/docs/api/connect/v2/#requestandresponseheaders) for the format of this header.
    */
    'accessToken'?: string;
    /**
    * This value is always _bearer_.
    */
    'tokenType'?: string;
    /**
    * The date when access_token expires, in [ISO 8601](http://www.iso.org/iso/home/standards/iso8601.htm) format.
    */
    'expiresAt'?: string;
    /**
    * The ID of the authorizing merchant's business.
    */
    'merchantId'?: string;
    /**
    * __LEGACY FIELD__. The ID of the merchant subscription associated with the authorization. Only present if the merchant signed up for a subscription during authorization..
    */
    'subscriptionId'?: string;
    /**
    * __LEGACY FIELD__. The ID of the subscription plan the merchant signed up for. Only present if the merchant signed up for a subscription during authorization.
    */
    'planId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "token_type",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "subscriptionId",
            "baseName": "subscription_id",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "plan_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RenewTokenResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveCashDrawerShiftRequest {
    /**
    * The ID of the location to retrieve cash drawer shifts from.
    */
    'locationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCashDrawerShiftRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveCashDrawerShiftResponse {
    /**
    * The cash drawer shift queried for.
    */
    'cashDrawerShift'?: CashDrawerShift;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cashDrawerShift",
            "baseName": "cash_drawer_shift",
            "type": "CashDrawerShift"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCashDrawerShiftResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveCatalogObjectRequest {
    /**
    * If `true`, the response will include additional objects that are related to the requested object, as follows:  If the `object` field of the response contains a CatalogItem, its associated CatalogCategory, CatalogTax objects, CatalogImages and CatalogModifierLists will be returned in the `related_objects` field of the response. If the `object` field of the response contains a CatalogItemVariation, its parent CatalogItem will be returned in the `related_objects` field of the response.  Default value: `false`
    */
    'includeRelatedObjects'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "includeRelatedObjects",
            "baseName": "include_related_objects",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCatalogObjectRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveCatalogObjectResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The CatalogObjects returned.
    */
    'object'?: CatalogObject;
    /**
    * A list of CatalogObjects referenced by the object in the `object` field.
    */
    'relatedObjects'?: Array<CatalogObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "CatalogObject"
        },
        {
            "name": "relatedObjects",
            "baseName": "related_objects",
            "type": "Array<CatalogObject>"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCatalogObjectResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that can be provided in a request to the [RetrieveCustomerGroup](#endpoint-retrievecustomergroup) endpoint.
*/
export class RetrieveCustomerGroupRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerGroupRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [RetrieveCustomerGroup](#endpoint-retrievecustomergroup) endpoint.  One of `errors` or `group` is present in a given response (never both).
*/
export class RetrieveCustomerGroupResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The retrieved customer group.
    */
    'group'?: CustomerGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "CustomerGroup"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerGroupResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the RetrieveCustomer endpoint.
*/
export class RetrieveCustomerRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the RetrieveCustomer endpoint.  One of `errors` or `customer` is present in a given response (never both).
*/
export class RetrieveCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested customer.
    */
    'customer'?: Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerResponse.attributeTypeMap;
    }
}

/**
* Defines the valid parameters for requests to __RetrieveCustomerSegmentRequest__.
*/
export class RetrieveCustomerSegmentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerSegmentRequest.attributeTypeMap;
    }
}

/**
* Defines the fields included in the response body for requests to __RetrieveCustomerSegment__.  One of `errors` or `segment` is present in a given response (never both).
*/
export class RetrieveCustomerSegmentResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The retrieved customer segment.
    */
    'segment'?: CustomerSegment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "segment",
            "baseName": "segment",
            "type": "CustomerSegment"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveCustomerSegmentResponse.attributeTypeMap;
    }
}

/**
* Defines parameters for a RetrieveDisputeEvidence request.
*/
export class RetrieveDisputeEvidenceRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveDisputeEvidenceRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a RetrieveDisputeEvidence response.
*/
export class RetrieveDisputeEvidenceResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * Metadata about the dispute evidence file.
    */
    'evidence'?: DisputeEvidence;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "evidence",
            "baseName": "evidence",
            "type": "DisputeEvidence"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveDisputeEvidenceResponse.attributeTypeMap;
    }
}

/**
* Defines request parameters for the RetrieveDispute endpoint.
*/
export class RetrieveDisputeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveDisputeRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a RetrieveDispute response.
*/
export class RetrieveDisputeResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * Details about the requested `Dispute`.
    */
    'dispute'?: Dispute;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "dispute",
            "baseName": "dispute",
            "type": "Dispute"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveDisputeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveEmployeeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveEmployeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveEmployeeResponse {
    /**
    * 
    */
    'employee'?: Employee;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employee",
            "baseName": "employee",
            "type": "Employee"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveEmployeeResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryAdjustmentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryAdjustmentRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryAdjustmentResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `InventoryAdjustment`.
    */
    'adjustment'?: InventoryAdjustment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "adjustment",
            "baseName": "adjustment",
            "type": "InventoryAdjustment"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryAdjustmentResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryChangesRequest {
    /**
    * The `Location` IDs to look up as a comma-separated list. An empty list queries all locations.
    */
    'locationIds'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryChangesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryChangesResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The set of inventory changes for the requested object and locations.
    */
    'changes'?: Array<InventoryChange>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "changes",
            "baseName": "changes",
            "type": "Array<InventoryChange>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryChangesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryCountRequest {
    /**
    * The `Location` IDs to look up as a comma-separated list. An empty list queries all locations.
    */
    'locationIds'?: string;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "string"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryCountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryCountResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The current calculated inventory counts for the requested object and locations.
    */
    'counts'?: Array<InventoryCount>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response.  See the [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) guide for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "counts",
            "baseName": "counts",
            "type": "Array<InventoryCount>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryCountResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryPhysicalCountRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryPhysicalCountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveInventoryPhysicalCountResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `InventoryPhysicalCount`.
    */
    'count'?: InventoryPhysicalCount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "InventoryPhysicalCount"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveInventoryPhysicalCountResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the request body for the __RetrieveLocation__ endpoint.
*/
export class RetrieveLocationRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveLocationRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that the [RetrieveLocation](#endpoint-retrievelocation) endpoint returns in a response.
*/
export class RetrieveLocationResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested location.
    */
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveLocationResponse.attributeTypeMap;
    }
}

/**
* A request to retrieve a loyalty account.
*/
export class RetrieveLoyaltyAccountRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveLoyaltyAccountRequest.attributeTypeMap;
    }
}

/**
* A response that includes the loyalty account.
*/
export class RetrieveLoyaltyAccountResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty account.
    */
    'loyaltyAccount'?: LoyaltyAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "loyaltyAccount",
            "baseName": "loyalty_account",
            "type": "LoyaltyAccount"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveLoyaltyAccountResponse.attributeTypeMap;
    }
}

/**
* A request to retrieve a loyalty reward.
*/
export class RetrieveLoyaltyRewardRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveLoyaltyRewardRequest.attributeTypeMap;
    }
}

/**
* A response that includes the loyalty reward.
*/
export class RetrieveLoyaltyRewardResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty reward retrieved.
    */
    'reward'?: LoyaltyReward;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "reward",
            "baseName": "reward",
            "type": "LoyaltyReward"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveLoyaltyRewardResponse.attributeTypeMap;
    }
}

/**
* Request object for the [RetrieveMerchant](#endpoint-retrievemerchant) endpoint.
*/
export class RetrieveMerchantRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveMerchantRequest.attributeTypeMap;
    }
}

/**
* The response object returned by the [RetrieveMerchant](#endpoint-retrieveMerchant) endpoint.
*/
export class RetrieveMerchantResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested `Merchant` object.
    */
    'merchant'?: Merchant;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "Merchant"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveMerchantResponse.attributeTypeMap;
    }
}

/**
* Defines parameters in a  [RetrieveSubscription](#endpoint-subscriptions-retrievesubscription) endpoint request.
*/
export class RetrieveSubscriptionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveSubscriptionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response from the [RetrieveSubscription](#endpoint-subscriptions-retrievesubscription) endpoint.
*/
export class RetrieveSubscriptionResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The subscription retrieved.
    */
    'subscription'?: Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveSubscriptionResponse.attributeTypeMap;
    }
}

/**
* Represents a retrieve request for a `TeamMember` object.
*/
export class RetrieveTeamMemberRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveTeamMemberRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a retrieve request, containing a `TeamMember` object or error messages.
*/
export class RetrieveTeamMemberResponse {
    /**
    * The successfully retrieved `TeamMember` object.
    */
    'teamMember'?: TeamMember;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMember",
            "baseName": "team_member",
            "type": "TeamMember"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveTeamMemberResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RetrieveTransactionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveTransactionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [RetrieveTransaction](#endpont-retrievetransaction) endpoint.  One of `errors` or `transaction` is present in a given response (never both).
*/
export class RetrieveTransactionResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested transaction.
    */
    'transaction'?: Transaction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveTransactionResponse.attributeTypeMap;
    }
}

/**
* Represents a retrieve request for the wage setting of a team member
*/
export class RetrieveWageSettingRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RetrieveWageSettingRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a retrieve request, containing the specified `WageSetting` object or error messages.
*/
export class RetrieveWageSettingResponse {
    /**
    * The successfully retrieved `WageSetting` object.
    */
    'wageSetting'?: WageSetting;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wageSetting",
            "baseName": "wage_setting",
            "type": "WageSetting"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return RetrieveWageSettingResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RevokeTokenRequest {
    /**
    * The Square issued ID for your application, available from the [application dashboard](https://connect.squareup.com/apps).
    */
    'clientId'?: string;
    /**
    * The access token of the merchant whose token you want to revoke. Do not provide a value for merchant_id if you provide this parameter.
    */
    'accessToken'?: string;
    /**
    * The ID of the merchant whose token you want to revoke. Do not provide a value for access_token if you provide this parameter.
    */
    'merchantId'?: string;
    /**
    * If `true`, terminate the given single access token, but do not terminate the entire authorization. Default: `false`
    */
    'revokeOnlyAccessToken'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "revokeOnlyAccessToken",
            "baseName": "revoke_only_access_token",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RevokeTokenRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RevokeTokenResponse {
    /**
    * If the request is successful, this is true.
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RevokeTokenResponse.attributeTypeMap;
    }
}

/**
* Defines the request body for the [SearchCatalogItems](#endpoint-Catalog-SearchCatalogItems) endpoint.
*/
export class SearchCatalogItemsRequest {
    /**
    * The text filter expression to return items or item variations containing specified text in the `name`, `description`, or `abbreviation` attribute value of an item, or in the `name`, `sku`, or `upc` attribute value of an item variation.
    */
    'textFilter'?: string;
    /**
    * The category id query expression to return items containing the specified category IDs.
    */
    'categoryIds'?: Array<string>;
    /**
    * The stock-level query expression to return item variations with the specified stock levels. See [SearchCatalogItemsRequestStockLevel](#type-searchcatalogitemsrequeststocklevel) for possible values
    */
    'stockLevels'?: Array<string>;
    /**
    * The enabled-location query expression to return items and item variations having specified enabled locations.
    */
    'enabledLocationIds'?: Array<string>;
    /**
    * The pagination token, returned in the previous response, used to fetch the next batch of pending results.
    */
    'cursor'?: string;
    /**
    * The maximum number of results to return per page. The default value is 100.
    */
    'limit'?: number;
    /**
    * The order to sort the resutls. The default sort order is ascending (`ASC`). See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;
    /**
    * The product types query expression to return items or item variations having the specified product types. See [CatalogItemProductType](#type-catalogitemproducttype) for possible values
    */
    'productTypes'?: Array<string>;
    /**
    * The customer-attribute filter to return items or item variations matching the specified custom attribute expressions. A maximum number of 10 custom attribute expressions are supported in a single call to the `SearchCatalogItems` endpoint.
    */
    'customAttributeFilters'?: Array<CustomAttributeFilter>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "textFilter",
            "baseName": "text_filter",
            "type": "string"
        },
        {
            "name": "categoryIds",
            "baseName": "category_ids",
            "type": "Array<string>"
        },
        {
            "name": "stockLevels",
            "baseName": "stock_levels",
            "type": "Array<string>"
        },
        {
            "name": "enabledLocationIds",
            "baseName": "enabled_location_ids",
            "type": "Array<string>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        },
        {
            "name": "productTypes",
            "baseName": "product_types",
            "type": "Array<string>"
        },
        {
            "name": "customAttributeFilters",
            "baseName": "custom_attribute_filters",
            "type": "Array<CustomAttributeFilter>"
        }    ];

    static getAttributeTypeMap() {
        return SearchCatalogItemsRequest.attributeTypeMap;
    }
}

/**
* Defines supported stock levels of the item inventory.
*/
export class SearchCatalogItemsRequestStockLevel {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SearchCatalogItemsRequestStockLevel.attributeTypeMap;
    }
}

/**
* Defines the response body returned from the [SearchCatalogItems](#endpoint-Catalog-SearchCatalogItems) endpoint.
*/
export class SearchCatalogItemsResponse {
    /**
    * Errors detected when the call to `SearchCatalogItems` endpoint fails.
    */
    'errors'?: Array<Error>;
    /**
    * Returned items matching the specified query expressions.
    */
    'items'?: Array<CatalogObject>;
    /**
    * Pagination token used in the next request to return more of the search result.
    */
    'cursor'?: string;
    /**
    * Ids of returned item variations matching the specified query expression.
    */
    'matchedVariationIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "matchedVariationIds",
            "baseName": "matched_variation_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchCatalogItemsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class SearchCatalogObjectsRequest {
    /**
    * The pagination cursor returned in the previous response. Leave unset for an initial request. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * The desired set of object types to appear in the search results. The legal values are taken from the CatalogObjectType enum: `\"ITEM\"`, `\"ITEM_VARIATION\"`, `\"CATEGORY\"`, `\"DISCOUNT\"`, `\"TAX\"`, `\"MODIFIER\"`, or `\"MODIFIER_LIST\"`. See [CatalogObjectType](#type-catalogobjecttype) for possible values
    */
    'objectTypes'?: Array<string>;
    /**
    * If `true`, deleted objects will be included in the results. Deleted objects will have their `is_deleted` field set to `true`.
    */
    'includeDeletedObjects'?: boolean;
    /**
    * If `true`, the response will include additional objects that are related to the requested object, as follows:  If a CatalogItem is returned in the object field of the response, its associated CatalogCategory, CatalogTax objects, CatalogImage objects and CatalogModifierList objects will be included in the `related_objects` field of the response.  If a CatalogItemVariation is returned in the object field of the response, its parent CatalogItem will be included in the `related_objects` field of the response.
    */
    'includeRelatedObjects'?: boolean;
    /**
    * Return objects modified after this [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`. The timestamp is exclusive - objects with a timestamp equal to `begin_time` will not be included in the response.
    */
    'beginTime'?: string;
    /**
    * A query to be used to filter or sort the results. If no query is specified, the entire catalog will be returned.
    */
    'query'?: CatalogQuery;
    /**
    * A limit on the number of results to be returned in a single page. The limit is advisory - the implementation may return more or fewer results. If the supplied limit is negative, zero, or is higher than the maximum limit of 1,000, it will be ignored.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "objectTypes",
            "baseName": "object_types",
            "type": "Array<string>"
        },
        {
            "name": "includeDeletedObjects",
            "baseName": "include_deleted_objects",
            "type": "boolean"
        },
        {
            "name": "includeRelatedObjects",
            "baseName": "include_related_objects",
            "type": "boolean"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "CatalogQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchCatalogObjectsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class SearchCatalogObjectsResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * The CatalogObjects returned.
    */
    'objects'?: Array<CatalogObject>;
    /**
    * A list of CatalogObjects referenced by the objects in the `objects` field.
    */
    'relatedObjects'?: Array<CatalogObject>;
    /**
    * When the associated product catalog was last updated. Will match the value for `end_time` or `cursor` if either field is included in the `SearchCatalog` request.
    */
    'latestTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "objects",
            "baseName": "objects",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "relatedObjects",
            "baseName": "related_objects",
            "type": "Array<CatalogObject>"
        },
        {
            "name": "latestTime",
            "baseName": "latest_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCatalogObjectsResponse.attributeTypeMap;
    }
}

/**
* Defines the fields included in the request body for the SearchCustomers endpoint.
*/
export class SearchCustomersRequest {
    /**
    * Include the pagination cursor in subsequent calls to this endpoint to retrieve the next set of results associated with the original query.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * A limit on the number of results to be returned in a single page. The limit is advisory - the implementation may return more or fewer results. If the supplied limit is negative, zero, or is higher than the maximum limit of 100, it will be ignored.
    */
    'limit'?: number;
    /**
    * Query customers based on the given conditions and sort order. Calling SearchCustomers without an explicit query parameter will return all customers ordered alphabetically based on `given_name` and `family_name`.
    */
    'query'?: CustomerQuery;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "CustomerQuery"
        }    ];

    static getAttributeTypeMap() {
        return SearchCustomersRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the SearchCustomers endpoint.  One of `errors` or `customers` is present in a given response (never both).
*/
export class SearchCustomersResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * An array of `Customer` objects that match a query.
    */
    'customers'?: Array<Customer>;
    /**
    * A pagination cursor that can be used during subsequent calls to SearchCustomers to retrieve the next set of results associated with the original query. Pagination cursors are only present when a request succeeds and additional results are available.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<Customer>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCustomersResponse.attributeTypeMap;
    }
}

/**
* Describes a `SearchInvoices` request.
*/
export class SearchInvoicesRequest {
    /**
    * Describes the query criteria for searching invoices.
    */
    'query': InvoiceQuery;
    /**
    * The maximum number of invoices to return (200 is the maximum `limit`).  If not provided, the server  uses a default limit of 100 invoices.
    */
    'limit'?: number;
    /**
    * A pagination cursor returned by a previous call to this endpoint.  Provide this cursor to retrieve the next set of results for your original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "InvoiceQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchInvoicesRequest.attributeTypeMap;
    }
}

/**
* Describes a `SearchInvoices` response.
*/
export class SearchInvoicesResponse {
    /**
    * The list of invoices returned by the search.
    */
    'invoices'?: Array<Invoice>;
    /**
    * When a response is truncated, it includes a cursor that you can use in a  subsequent request to fetch the next set of invoices. If empty, this is the final  response.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoices",
            "baseName": "invoices",
            "type": "Array<Invoice>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return SearchInvoicesResponse.attributeTypeMap;
    }
}

/**
* A request to search for loyalty accounts.
*/
export class SearchLoyaltyAccountsRequest {
    /**
    * The search criteria for the request.
    */
    'query'?: SearchLoyaltyAccountsRequestLoyaltyAccountQuery;
    /**
    * The maximum number of results to include in the response.
    */
    'limit'?: number;
    /**
    * A pagination cursor returned by a previous call to  this endpoint. Provide this to retrieve the next set of  results for the original query.  For more information,  see [Pagination](https://developer.squareup.com/docs/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "SearchLoyaltyAccountsRequestLoyaltyAccountQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyAccountsRequest.attributeTypeMap;
    }
}

/**
* The search criteria for the loyalty accounts.
*/
export class SearchLoyaltyAccountsRequestLoyaltyAccountQuery {
    /**
    * The set of mappings to use in the loyalty account search.
    */
    'mappings'?: Array<LoyaltyAccountMapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mappings",
            "baseName": "mappings",
            "type": "Array<LoyaltyAccountMapping>"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyAccountsRequestLoyaltyAccountQuery.attributeTypeMap;
    }
}

/**
* A response that includes loyalty accounts that satisfy the search criteria.
*/
export class SearchLoyaltyAccountsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty accounts that met the search criteria,   in order of creation date.
    */
    'loyaltyAccounts'?: Array<LoyaltyAccount>;
    /**
    * The pagination cursor to use in a subsequent  request. If empty, this is the final response. For more information,  see [Pagination](https://developer.squareup.com/docs/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "loyaltyAccounts",
            "baseName": "loyalty_accounts",
            "type": "Array<LoyaltyAccount>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyAccountsResponse.attributeTypeMap;
    }
}

/**
* A request to search for loyalty events.
*/
export class SearchLoyaltyEventsRequest {
    /**
    * A set of one or more predefined query filters to apply when  searching for loyalty events. The endpoint performs a logical AND to  evaluate multiple filters and performs a logical OR on arrays   that specifies multiple field values.
    */
    'query'?: LoyaltyEventQuery;
    /**
    * The maximum number of results to include in the response.  The last page might contain fewer events.  The default is 30 events.
    */
    'limit'?: number;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query. For more information, see [Pagination](https://developer.squareup.com/docs/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "LoyaltyEventQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyEventsRequest.attributeTypeMap;
    }
}

/**
* A response that contains loyalty events that satisfy the search  criteria, in order by the `created_at` date.
*/
export class SearchLoyaltyEventsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty events that satisfy the search criteria.
    */
    'events'?: Array<LoyaltyEvent>;
    /**
    * The pagination cursor to be used in a subsequent  request. If empty, this is the final response.  For more information,  see [Pagination](https://developer.squareup.com/docs/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<LoyaltyEvent>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyEventsResponse.attributeTypeMap;
    }
}

/**
* A request to search for loyalty rewards.
*/
export class SearchLoyaltyRewardsRequest {
    /**
    * The search criteria for the request.  If empty, the endpoint retrieves all loyalty rewards in the loyalty program.
    */
    'query'?: SearchLoyaltyRewardsRequestLoyaltyRewardQuery;
    /**
    * The maximum number of results to return in the response.
    */
    'limit'?: number;
    /**
    * A pagination cursor returned by a previous call to  this endpoint. Provide this to retrieve the next set of  results for the original query. For more information,  see [Pagination](https://developer.squareup.com/docs/docs/basics/api101/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "SearchLoyaltyRewardsRequestLoyaltyRewardQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyRewardsRequest.attributeTypeMap;
    }
}

/**
* The set of search requirements.
*/
export class SearchLoyaltyRewardsRequestLoyaltyRewardQuery {
    /**
    * The ID of the `loyalty account` to which the loyalty reward belongs.
    */
    'loyaltyAccountId': string;
    /**
    * The status of the loyalty reward. See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loyaltyAccountId",
            "baseName": "loyalty_account_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyRewardsRequestLoyaltyRewardQuery.attributeTypeMap;
    }
}

/**
* A response that includes the loyalty rewards satisfying the search criteria.
*/
export class SearchLoyaltyRewardsResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The loyalty rewards that satisfy the search criteria. These are returned in descending order by `updated_at`.
    */
    'rewards'?: Array<LoyaltyReward>;
    /**
    * The pagination cursor to be used in a subsequent  request. If empty, this is the final response.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "rewards",
            "baseName": "rewards",
            "type": "Array<LoyaltyReward>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchLoyaltyRewardsResponse.attributeTypeMap;
    }
}

/**
* Filter based on Order `customer_id` and any Tender `customer_id` associated with the Order. Does not filter based on the [FulfillmentRecipient](#type-orderfulfillmentrecipient) `customer_id`.
*/
export class SearchOrdersCustomerFilter {
    /**
    * List of customer IDs to filter by.  Max: 10 customer IDs.
    */
    'customerIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerIds",
            "baseName": "customer_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersCustomerFilter.attributeTypeMap;
    }
}

/**
* Filter for `Order` objects based on whether their `CREATED_AT`, `CLOSED_AT` or `UPDATED_AT` timestamps fall within a specified time range. You can specify the time range and which timestamp to filter for. You can filter for only one time range at a time.  For each time range, the start time and end time are inclusive. If the end time is absent, it defaults to the time of the first request for the cursor.  __Important:__ If you use the DateTimeFilter in a SearchOrders query, you must also set the `sort_field` in [OrdersSort](#type-searchorderordersort) to the same field you filter for. For example, if you set the `CLOSED_AT` field in DateTimeFilter, you must also set the `sort_field` in SearchOrdersSort to `CLOSED_AT`. Otherwise, SearchOrders will throw an error. [Learn more about filtering orders by time range](/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range).
*/
export class SearchOrdersDateTimeFilter {
    /**
    * Time range for filtering on the `created_at` timestamp. If you use this value, you must also set the `sort_field` in the OrdersSearchSort object to `CREATED_AT`.
    */
    'createdAt'?: TimeRange;
    /**
    * Time range for filtering on the `updated_at` timestamp. If you use this value, you must also set the `sort_field` in the OrdersSearchSort object to `UPDATED_AT`.
    */
    'updatedAt'?: TimeRange;
    /**
    * Time range for filtering on the `closed_at` timestamp. If you use this value, you must also set the `sort_field` in the OrdersSearchSort object to `CLOSED_AT`.
    */
    'closedAt'?: TimeRange;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "TimeRange"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "TimeRange"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "TimeRange"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersDateTimeFilter.attributeTypeMap;
    }
}

/**
* Filtering criteria to use for a SearchOrders request. Multiple filters will be ANDed together.
*/
export class SearchOrdersFilter {
    /**
    * Filter by ``OrderState``.
    */
    'stateFilter'?: SearchOrdersStateFilter;
    /**
    * Filter for results within a time range.  __Important:__ If you filter for orders by time range, you must set SearchOrdersSort to sort by the same field. [Learn more about filtering orders by time range](https://developer.squareup.com/docs/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range)
    */
    'dateTimeFilter'?: SearchOrdersDateTimeFilter;
    /**
    * Filter by fulfillment type or state.
    */
    'fulfillmentFilter'?: SearchOrdersFulfillmentFilter;
    /**
    * Filter by source of order.
    */
    'sourceFilter'?: SearchOrdersSourceFilter;
    /**
    * Filter by customers associated with the order.
    */
    'customerFilter'?: SearchOrdersCustomerFilter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stateFilter",
            "baseName": "state_filter",
            "type": "SearchOrdersStateFilter"
        },
        {
            "name": "dateTimeFilter",
            "baseName": "date_time_filter",
            "type": "SearchOrdersDateTimeFilter"
        },
        {
            "name": "fulfillmentFilter",
            "baseName": "fulfillment_filter",
            "type": "SearchOrdersFulfillmentFilter"
        },
        {
            "name": "sourceFilter",
            "baseName": "source_filter",
            "type": "SearchOrdersSourceFilter"
        },
        {
            "name": "customerFilter",
            "baseName": "customer_filter",
            "type": "SearchOrdersCustomerFilter"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersFilter.attributeTypeMap;
    }
}

/**
* Filter based on [Order Fulfillment](#type-orderfulfillment) information.
*/
export class SearchOrdersFulfillmentFilter {
    /**
    * List of `fulfillment types` to filter for. Will return orders if any of its fulfillments match any of the fulfillment types listed in this field. See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
    */
    'fulfillmentTypes'?: Array<string>;
    /**
    * List of `fulfillment states` to filter for. Will return orders if any of its fulfillments match any of the fulfillment states listed in this field. See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
    */
    'fulfillmentStates'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fulfillmentTypes",
            "baseName": "fulfillment_types",
            "type": "Array<string>"
        },
        {
            "name": "fulfillmentStates",
            "baseName": "fulfillment_states",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersFulfillmentFilter.attributeTypeMap;
    }
}

/**
* Contains query criteria for the search.
*/
export class SearchOrdersQuery {
    /**
    * Criteria to filter results by.
    */
    'filter'?: SearchOrdersFilter;
    /**
    * Criteria to sort results by.
    */
    'sort'?: SearchOrdersSort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "SearchOrdersFilter"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "SearchOrdersSort"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersQuery.attributeTypeMap;
    }
}

/**
* The request does not have any required fields. When given no query criteria, SearchOrders will return all results for all of the merchantâ€™s locations. When fetching additional pages using a `cursor`, the `query` must be equal to the `query` used to fetch the first page of results.
*/
export class SearchOrdersRequest {
    /**
    * The location IDs for the orders to query. All locations must belong to the same merchant.  Min: 1 location IDs.  Max: 10 location IDs.
    */
    'locationIds'?: Array<string>;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * Query conditions used to filter or sort the results. Note that when fetching additional pages using a cursor, the query must be equal to the query used to fetch the first page of results.
    */
    'query'?: SearchOrdersQuery;
    /**
    * Maximum number of results to be returned in a single page. It is possible to receive fewer results than the specified limit on a given page.  Default: `500`
    */
    'limit'?: number;
    /**
    * Boolean that controls the format of the search results. If `true`, SearchOrders will return ``OrderEntry`` objects. If `false`, SearchOrders will return complete Order objects.  Default: `false`.
    */
    'returnEntries'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "SearchOrdersQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "returnEntries",
            "baseName": "return_entries",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersRequest.attributeTypeMap;
    }
}

/**
* Only one of `order_entries` or `orders` fields will be set, depending on whether `return_entries` was set on the [SearchOrdersRequest](#type-searchorderrequest).
*/
export class SearchOrdersResponse {
    /**
    * List of `OrderEntries` that fit the query conditions. Populated only if `return_entries` was set to `true` in the request.
    */
    'orderEntries'?: Array<OrderEntry>;
    /**
    * List of `Order` objects that match query conditions. Populated only if `return_entries` in the request is set to `false`.
    */
    'orders'?: Array<Order>;
    /**
    * The pagination cursor to be used in a subsequent request. If unset, this is the final response. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;
    /**
    * `Errors` encountered during the search.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderEntries",
            "baseName": "order_entries",
            "type": "Array<OrderEntry>"
        },
        {
            "name": "orders",
            "baseName": "orders",
            "type": "Array<Order>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersResponse.attributeTypeMap;
    }
}

/**
* Sorting criteria for a SearchOrders request. Results can only be sorted by a timestamp field.
*/
export class SearchOrdersSort {
    /**
    * The field to sort by.  __Important:__ When using a `DateTimeFilter`, `sort_field` must match the timestamp field that the DateTimeFilter uses to filter. For example, If you set your `sort_field` to `CLOSED_AT` and you use a DateTimeFilter, your DateTimeFilter must filter for orders by their `CLOSED_AT` date. If this field does not match the timestamp field in `DateTimeFilter`, SearchOrders will return an error.  Default: `CREATED_AT`. See [SearchOrdersSortField](#type-searchorderssortfield) for possible values
    */
    'sortField': string;
    /**
    * The chronological order in which results are returned. Defaults to `DESC`. See [SortOrder](#type-sortorder) for possible values
    */
    'sortOrder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sortField",
            "baseName": "sort_field",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersSort.attributeTypeMap;
    }
}

/**
* Specifies which timestamp to use to sort SearchOrder results.
*/
export class SearchOrdersSortField {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SearchOrdersSortField.attributeTypeMap;
    }
}

/**
* Filter based on order `source` information.
*/
export class SearchOrdersSourceFilter {
    /**
    * Filters by `Source` `name`. Will return any orders with with a `source.name` that matches any of the listed source names.  Max: 10 source names.
    */
    'sourceNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceNames",
            "baseName": "source_names",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersSourceFilter.attributeTypeMap;
    }
}

/**
* Filter by current Order `state`.
*/
export class SearchOrdersStateFilter {
    /**
    * States to filter for. See [OrderState](#type-orderstate) for possible values
    */
    'states': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchOrdersStateFilter.attributeTypeMap;
    }
}

/**
* A request for a filtered and sorted set of `Shift` objects.
*/
export class SearchShiftsRequest {
    /**
    * Query filters.
    */
    'query'?: ShiftQuery;
    /**
    * number of resources in a page (200 by default).
    */
    'limit'?: number;
    /**
    * opaque cursor for fetching the next page.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "ShiftQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchShiftsRequest.attributeTypeMap;
    }
}

/**
* The response to a request for `Shift` objects. Contains the requested `Shift` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class SearchShiftsResponse {
    /**
    * Shifts
    */
    'shifts'?: Array<Shift>;
    /**
    * Opaque cursor for fetching the next page.
    */
    'cursor'?: string;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shifts",
            "baseName": "shifts",
            "type": "Array<Shift>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return SearchShiftsResponse.attributeTypeMap;
    }
}

/**
* Represents a set of SearchSubscriptionsQuery filters used to limit the set of Subscriptions returned by SearchSubscriptions.
*/
export class SearchSubscriptionsFilter {
    /**
    * A filter to select subscriptions based on the customer.
    */
    'customerIds'?: Array<string>;
    /**
    * A filter to select subscriptions based the location.
    */
    'locationIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerIds",
            "baseName": "customer_ids",
            "type": "Array<string>"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchSubscriptionsFilter.attributeTypeMap;
    }
}

/**
* Represents a query (including filtering criteria) used to search for subscriptions.
*/
export class SearchSubscriptionsQuery {
    /**
    * A list of filtering criteria.
    */
    'filter'?: SearchSubscriptionsFilter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "SearchSubscriptionsFilter"
        }    ];

    static getAttributeTypeMap() {
        return SearchSubscriptionsQuery.attributeTypeMap;
    }
}

/**
* Defines parameters in a [SearchSubscriptions](#endpoint-subscriptions-searchsubscriptions) endpoint  request.
*/
export class SearchSubscriptionsRequest {
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;
    /**
    * The upper limit on the number of subscriptions to return  in the response.   Default: `200`
    */
    'limit'?: number;
    /**
    * Query subscriptions based on the given conditions and sort order. Calling SearchSubscriptions without an explicit query parameter will return all subscriptions.
    */
    'query'?: SearchSubscriptionsQuery;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "SearchSubscriptionsQuery"
        }    ];

    static getAttributeTypeMap() {
        return SearchSubscriptionsRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response from the [SearchSubscriptions](#endpoint-subscriptions-searchsubscriptions) endpoint.
*/
export class SearchSubscriptionsResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The search result.
    */
    'subscriptions'?: Array<Subscription>;
    /**
    * When a response is truncated, it includes a cursor that you can  use in a subsequent request to fetch the next set of subscriptions.  If empty, this is the final response.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscriptions",
            "baseName": "subscriptions",
            "type": "Array<Subscription>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchSubscriptionsResponse.attributeTypeMap;
    }
}

/**
* Represents a filter used in a search for `TeamMember` objects. `AND` logic is applied between the individual fields, and `OR` logic is applied within list-based fields. For example, setting this filter value, ``` filter = (locations_ids = [\"A\", \"B\"], status = ACTIVE) ``` returns only active team members assigned to either location \"A\" or \"B\".
*/
export class SearchTeamMembersFilter {
    /**
    * When present, filter by team members assigned to the specified locations. When empty, include team members assigned to any location.
    */
    'locationIds'?: Array<string>;
    /**
    * When present, filter by team members who match the given status. When empty, include team members of all statuses. See [TeamMemberStatus](#type-teammemberstatus) for possible values
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchTeamMembersFilter.attributeTypeMap;
    }
}

/**
* Represents the parameters in a search for `TeamMember` objects.
*/
export class SearchTeamMembersQuery {
    /**
    * The options to filter by.
    */
    'filter'?: SearchTeamMembersFilter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "SearchTeamMembersFilter"
        }    ];

    static getAttributeTypeMap() {
        return SearchTeamMembersQuery.attributeTypeMap;
    }
}

/**
* Represents a search request for a filtered list of `TeamMember` objects.
*/
export class SearchTeamMembersRequest {
    /**
    * The query parameters.
    */
    'query'?: SearchTeamMembersQuery;
    /**
    * The maximum number of `TeamMember` objects in a page (25 by default).
    */
    'limit'?: number;
    /**
    * The opaque cursor for fetching the next page. Read about [pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) with Square APIs for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "SearchTeamMembersQuery"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchTeamMembersRequest.attributeTypeMap;
    }
}

/**
* Represents a response from a search request, containing a filtered list of `TeamMember` objects.
*/
export class SearchTeamMembersResponse {
    /**
    * The filtered list of `TeamMember` objects.
    */
    'teamMembers'?: Array<TeamMember>;
    /**
    * The opaque cursor for fetching the next page. Read about [pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) with Square APIs for more information.
    */
    'cursor'?: string;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMembers",
            "baseName": "team_members",
            "type": "Array<TeamMember>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return SearchTeamMembersResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class SearchTerminalCheckoutsRequest {
    /**
    * Query the terminal checkouts based on given conditions and sort order. Calling SearchTerminalCheckouts without an explicitly query parameter will return all available checkouts with the default sort order.
    */
    'query'?: TerminalCheckoutQuery;
    /**
    * A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.
    */
    'cursor'?: string;
    /**
    * Limit the number of results returned for a single request.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "TerminalCheckoutQuery"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchTerminalCheckoutsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class SearchTerminalCheckoutsResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The requested search result of `TerminalCheckout`s.
    */
    'checkouts'?: Array<TerminalCheckout>;
    /**
    * The pagination cursor to be used in a subsequent request. If empty, this is the final response.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
    */
    'cursor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "checkouts",
            "baseName": "checkouts",
            "type": "Array<TerminalCheckout>"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchTerminalCheckoutsResponse.attributeTypeMap;
    }
}

/**
* A record of the hourly rate, start, and end times for a single work shift for an employee. May include a record of the start and end times for breaks taken during the shift.
*/
export class Shift {
    /**
    * UUID for this object
    */
    'id'?: string;
    /**
    * The ID of the employee this shift belongs to. DEPRECATED at version 2020-08-26. Use `team_member_id` instead
    */
    'employeeId'?: string;
    /**
    * The ID of the location this shift occurred at. Should be based on where the employee clocked in.
    */
    'locationId'?: string;
    /**
    * Read-only convenience value that is calculated from the location based on `location_id`. Format: the IANA Timezone Database identifier for the location timezone.
    */
    'timezone'?: string;
    /**
    * RFC 3339; shifted to location timezone + offset. Precision up to the minute is respected; seconds are truncated.
    */
    'startAt': string;
    /**
    * RFC 3339; shifted to timezone + offset. Precision up to the minute is respected; seconds are truncated.
    */
    'endAt'?: string;
    /**
    * Job and pay related information. If wage is not set on create, will default to a wage of zero money. If title is not set on create, will default to the name of the role the employee is assigned to, if any.
    */
    'wage'?: ShiftWage;
    /**
    * A list of any paid or unpaid breaks that were taken during this shift.
    */
    'breaks'?: Array<ModelBreak>;
    /**
    * Describes working state of the current `Shift`. See [ShiftStatus](#type-shiftstatus) for possible values
    */
    'status'?: string;
    /**
    * Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If not provided, Square executes a blind write; potentially overwriting data from another write.
    */
    'version'?: number;
    /**
    * A read-only timestamp in RFC 3339 format; presented in UTC.
    */
    'createdAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format; presented in UTC.
    */
    'updatedAt'?: string;
    /**
    * The ID of the team member this shift belongs to. Replaced `employee_id` at version \"2020-08-26\"
    */
    'teamMemberId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startAt",
            "baseName": "start_at",
            "type": "string"
        },
        {
            "name": "endAt",
            "baseName": "end_at",
            "type": "string"
        },
        {
            "name": "wage",
            "baseName": "wage",
            "type": "ShiftWage"
        },
        {
            "name": "breaks",
            "baseName": "breaks",
            "type": "Array<ModelBreak>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "teamMemberId",
            "baseName": "team_member_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Shift.attributeTypeMap;
    }
}

/**
* Defines a filter used in a search for `Shift` records. `AND` logic is used by Square's servers to apply each filter property specified.
*/
export class ShiftFilter {
    /**
    * Fetch shifts for the specified location.
    */
    'locationIds': Array<string>;
    /**
    * Fetch shifts for the specified employees. DEPRECATED at version 2020-08-26. Use `team_member_ids` instead
    */
    'employeeIds'?: Array<string>;
    /**
    * Fetch a `Shift` instance by `Shift.status`. See [ShiftFilterStatus](#type-shiftfilterstatus) for possible values
    */
    'status'?: string;
    /**
    * Fetch `Shift`s that start in the time range - Inclusive.
    */
    'start'?: TimeRange;
    /**
    * Fetch the `Shift`s that end in the time range - Inclusive.
    */
    'end'?: TimeRange;
    /**
    * Fetch the `Shift`s based on workday date range.
    */
    'workday'?: ShiftWorkday;
    /**
    * Fetch shifts for the specified team members. Replaced `employee_ids` at version \"2020-08-26\"
    */
    'teamMemberIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        },
        {
            "name": "employeeIds",
            "baseName": "employee_ids",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "TimeRange"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "TimeRange"
        },
        {
            "name": "workday",
            "baseName": "workday",
            "type": "ShiftWorkday"
        },
        {
            "name": "teamMemberIds",
            "baseName": "team_member_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ShiftFilter.attributeTypeMap;
    }
}

/**
* Specifies the `status` of `Shift` records to be returned.
*/
export class ShiftFilterStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ShiftFilterStatus.attributeTypeMap;
    }
}

/**
* The parameters of a `Shift` search query. Includes filter and sort options.
*/
export class ShiftQuery {
    /**
    * Query filter options
    */
    'filter'?: ShiftFilter;
    /**
    * Sort order details
    */
    'sort'?: ShiftSort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "ShiftFilter"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "ShiftSort"
        }    ];

    static getAttributeTypeMap() {
        return ShiftQuery.attributeTypeMap;
    }
}

/**
* Sets the sort order of search results.
*/
export class ShiftSort {
    /**
    * The field to sort on. See [ShiftSortField](#type-shiftsortfield) for possible values
    */
    'field'?: string;
    /**
    * The order in which results are returned. Defaults to DESC. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShiftSort.attributeTypeMap;
    }
}

/**
* Enumerates the `Shift` fields to sort on.
*/
export class ShiftSortField {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ShiftSortField.attributeTypeMap;
    }
}

/**
* Enumerates the possible status of a `Shift`
*/
export class ShiftStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ShiftStatus.attributeTypeMap;
    }
}

/**
* The hourly wage rate used to compensate an employee for this shift.
*/
export class ShiftWage {
    /**
    * The name of the job performed during this shift. Square labor-reporting UIs may group shifts together by title.
    */
    'title'?: string;
    /**
    * Can be a custom-set hourly wage or the calculated effective hourly wage based on annual wage and hours worked per week.
    */
    'hourlyRate'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "hourlyRate",
            "baseName": "hourly_rate",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return ShiftWage.attributeTypeMap;
    }
}

/**
* A `Shift` search query filter parameter that sets a range of days that a `Shift` must start or end in before passing the filter condition.
*/
export class ShiftWorkday {
    /**
    * Dates for fetching the shifts
    */
    'dateRange'?: DateRange;
    /**
    * The strategy on which the dates are applied. See [ShiftWorkdayMatcher](#type-shiftworkdaymatcher) for possible values
    */
    'matchShiftsBy'?: string;
    /**
    * Location-specific timezones convert workdays to datetime filters. Every location included in the query must have a timezone, or this field must be provided as a fallback. Format: the IANA timezone database identifier for the relevant timezone.
    */
    'defaultTimezone'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dateRange",
            "baseName": "date_range",
            "type": "DateRange"
        },
        {
            "name": "matchShiftsBy",
            "baseName": "match_shifts_by",
            "type": "string"
        },
        {
            "name": "defaultTimezone",
            "baseName": "default_timezone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShiftWorkday.attributeTypeMap;
    }
}

/**
* Defines the logic used to apply a workday filter.
*/
export class ShiftWorkdayMatcher {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ShiftWorkdayMatcher.attributeTypeMap;
    }
}

/**
* The order (e.g., chronological or alphabetical) in which results from a request are returned.
*/
export class SortOrder {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SortOrder.attributeTypeMap;
    }
}

/**
* Provides information about the application used to generate a change.
*/
export class SourceApplication {
    /**
    * Read-only `Product` type for the application. See [Product](#type-product) for possible values
    */
    'product'?: string;
    /**
    * Read-only Square ID assigned to the application. Only used for `Product` type `EXTERNAL_API`.
    */
    'applicationId'?: string;
    /**
    * Read-only display name assigned to the application (e.g. `\"Custom Application\"`, `\"Square POS 4.74 for Android\"`).
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "product",
            "baseName": "product",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "application_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SourceApplication.attributeTypeMap;
    }
}

/**
* Contains the name and abbreviation for standard measurement unit.
*/
export class StandardUnitDescription {
    /**
    * Identifies the measurement unit being described.
    */
    'unit'?: MeasurementUnit;
    /**
    * UI display name of the measurement unit. For example, 'Pound'.
    */
    'name'?: string;
    /**
    * UI display abbreviation for the measurement unit. For example, 'lb'.
    */
    'abbreviation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "unit",
            "baseName": "unit",
            "type": "MeasurementUnit"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "abbreviation",
            "baseName": "abbreviation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StandardUnitDescription.attributeTypeMap;
    }
}

/**
* Group of standard measurement units.
*/
export class StandardUnitDescriptionGroup {
    /**
    * List of standard (non-custom) measurement units in this description group.
    */
    'standardUnitDescriptions'?: Array<StandardUnitDescription>;
    /**
    * IETF language tag.
    */
    'languageCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "standardUnitDescriptions",
            "baseName": "standard_unit_descriptions",
            "type": "Array<StandardUnitDescription>"
        },
        {
            "name": "languageCode",
            "baseName": "language_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StandardUnitDescriptionGroup.attributeTypeMap;
    }
}

/**
* Defines parameters for a SubmitEvidence request.
*/
export class SubmitEvidenceRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SubmitEvidenceRequest.attributeTypeMap;
    }
}

/**
* Defines fields in a SubmitEvidence response.
*/
export class SubmitEvidenceResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The `Dispute` for which evidence was submitted.
    */
    'dispute'?: Dispute;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "dispute",
            "baseName": "dispute",
            "type": "Dispute"
        }    ];

    static getAttributeTypeMap() {
        return SubmitEvidenceResponse.attributeTypeMap;
    }
}

/**
* Represents a customer subscription to a subscription plan. For an overview of the `Subscription` type, see  [Subscription object](/docs/subscriptions-api/overview#subscription-object-overview).
*/
export class Subscription {
    /**
    * The Square-assigned ID of the subscription.
    */
    'id'?: string;
    /**
    * The ID of the location associated with the subscription.
    */
    'locationId'?: string;
    /**
    * The ID of the associated `subscription plan`.
    */
    'planId'?: string;
    /**
    * The ID of the associated `customer` profile.
    */
    'customerId'?: string;
    /**
    * The start date of the subscription, in YYYY-MM-DD format (for example, 2013-01-15).
    */
    'startDate'?: string;
    /**
    * The subscription cancellation date, in YYYY-MM-DD format (for example, 2013-01-15). On this date, the subscription status changes  to `CANCELED` and the subscription billing stops.  If you don't set this field, the subscription plan dictates if and  when subscription ends.   You cannot update this field, you can only clear it.
    */
    'canceledDate'?: string;
    /**
    * The current status of the subscription. See [SubscriptionStatus](#type-subscriptionstatus) for possible values
    */
    'status'?: string;
    /**
    * The tax amount applied when billing the subscription. The percentage is expressed in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign. For example, a value of `7.5` corresponds to 7.5%.
    */
    'taxPercentage'?: string;
    /**
    * The IDs of the `invoices` created for the  subscription, listed in order when the invoices were created  (oldest invoices appear first).
    */
    'invoiceIds'?: Array<string>;
    /**
    * A custom price to apply for the subscription. If specified,  it overrides the price configured by the subscription plan.
    */
    'priceOverrideMoney'?: Money;
    /**
    * The version of the object. When updating an object, the version supplied must match the version in the database, otherwise the write will be rejected as conflicting.
    */
    'version'?: number;
    /**
    * The timestamp when the subscription was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The ID of the `customer](#type-customer) [card` that is charged for the subscription.
    */
    'cardId'?: string;
    /**
    * The date up to which the customer is invoiced for the subscription, in YYYY-MM-DD format (for example, 2013-01-15).  After the invoice is paid for a given billing period, this date will be the last day of the billing period. For example, suppose for the month of May a customer gets an invoice (or charged the card) on May 1. For the monthly billing scenario, this date is then set to May 31.
    */
    'paidUntilDate'?: string;
    /**
    * Timezone that will be used in date calculations for the subscription. Defaults to the timezone of the location based on `location_id`. Format: the IANA Timezone Database identifier for the location timezone (for example, `America/Los_Angeles`).
    */
    'timezone'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "plan_id",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "canceledDate",
            "baseName": "canceled_date",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "taxPercentage",
            "baseName": "tax_percentage",
            "type": "string"
        },
        {
            "name": "invoiceIds",
            "baseName": "invoice_ids",
            "type": "Array<string>"
        },
        {
            "name": "priceOverrideMoney",
            "baseName": "price_override_money",
            "type": "Money"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "cardId",
            "baseName": "card_id",
            "type": "string"
        },
        {
            "name": "paidUntilDate",
            "baseName": "paid_until_date",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

/**
* Determines the billing cadence of a `Subscription`
*/
export class SubscriptionCadence {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SubscriptionCadence.attributeTypeMap;
    }
}

/**
* Describes changes to subscription and billing states.
*/
export class SubscriptionEvent {
    /**
    * The ID of the subscription event.
    */
    'id': string;
    /**
    * Type of the subscription event. See [SubscriptionEventSubscriptionEventType](#type-subscriptioneventsubscriptioneventtype) for possible values
    */
    'subscriptionEventType': string;
    /**
    * The date, in YYYY-MM-DD format (for example, 2013-01-15), when the subscription event went into effect.
    */
    'effectiveDate': string;
    /**
    * The ID of the subscription plan associated with the subscription.
    */
    'planId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "subscriptionEventType",
            "baseName": "subscription_event_type",
            "type": "string"
        },
        {
            "name": "effectiveDate",
            "baseName": "effective_date",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "plan_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionEvent.attributeTypeMap;
    }
}

/**
* The possible subscription event types.
*/
export class SubscriptionEventSubscriptionEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SubscriptionEventSubscriptionEventType.attributeTypeMap;
    }
}

/**
* Describes a phase in a subscription plan. For more information, see [Set Up and Manage a Subscription Plan](/docs/subscriptions-api/setup-plan).
*/
export class SubscriptionPhase {
    /**
    * The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
    */
    'uid'?: string;
    /**
    * The billing cadence of the phase. For example, weekly or monthly. This field cannot be changed after a `SubscriptionPhase` is created. See [SubscriptionCadence](#type-subscriptioncadence) for possible values
    */
    'cadence': string;
    /**
    * The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
    */
    'periods'?: number;
    /**
    * The amount to bill for each `cadence`.
    */
    'recurringPriceMoney': Money;
    /**
    * The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
    */
    'ordinal'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "cadence",
            "baseName": "cadence",
            "type": "string"
        },
        {
            "name": "periods",
            "baseName": "periods",
            "type": "number"
        },
        {
            "name": "recurringPriceMoney",
            "baseName": "recurring_price_money",
            "type": "Money"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPhase.attributeTypeMap;
    }
}

/**
* Possible subscription status values.
*/
export class SubscriptionStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SubscriptionStatus.attributeTypeMap;
    }
}

/**
* When to calculate the taxes due on a cart.
*/
export class TaxCalculationPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TaxCalculationPhase.attributeTypeMap;
    }
}

/**
* Whether to the tax amount should be additional to or included in the CatalogItem price.
*/
export class TaxInclusionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TaxInclusionType.attributeTypeMap;
    }
}

/**
* A record representing an individual team member for a business.
*/
export class TeamMember {
    /**
    * The unique ID for the team member.
    */
    'id'?: string;
    /**
    * A second ID used to associate the team member with an entity in another system.
    */
    'referenceId'?: string;
    /**
    * Whether the team member is the owner of the Square account.
    */
    'isOwner'?: boolean;
    /**
    * Describes the status of the team member. See [TeamMemberStatus](#type-teammemberstatus) for possible values
    */
    'status'?: string;
    /**
    * The given (i.e., first) name associated with the team member.
    */
    'givenName'?: string;
    /**
    * The family (i.e., last) name associated with the team member.
    */
    'familyName'?: string;
    /**
    * The email address associated with the team member.
    */
    'emailAddress'?: string;
    /**
    * The team member's phone number in E.164 format. Examples: +14155552671 - the country code is 1 for US +551155256325 - the country code is 55 for BR
    */
    'phoneNumber'?: string;
    /**
    * The timestamp in RFC 3339 format describing when the team member was created. Ex: \"2018-10-04T04:00:00-07:00\" or \"2019-02-05T12:00:00Z\"
    */
    'createdAt'?: string;
    /**
    * The timestamp in RFC 3339 format describing when the team member was last updated. Ex: \"2018-10-04T04:00:00-07:00\" or \"2019-02-05T12:00:00Z\"
    */
    'updatedAt'?: string;
    /**
    * Describes the team member's assigned locations.
    */
    'assignedLocations'?: TeamMemberAssignedLocations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "isOwner",
            "baseName": "is_owner",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "givenName",
            "baseName": "given_name",
            "type": "string"
        },
        {
            "name": "familyName",
            "baseName": "family_name",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "assignedLocations",
            "baseName": "assigned_locations",
            "type": "TeamMemberAssignedLocations"
        }    ];

    static getAttributeTypeMap() {
        return TeamMember.attributeTypeMap;
    }
}

/**
* An object that represents a team member's assignment to locations.
*/
export class TeamMemberAssignedLocations {
    /**
    * The current assignment type of the team member. See [TeamMemberAssignedLocationsAssignmentType](#type-teammemberassignedlocationsassignmenttype) for possible values
    */
    'assignmentType'?: string;
    /**
    * The locations that the team member is assigned to.
    */
    'locationIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignmentType",
            "baseName": "assignment_type",
            "type": "string"
        },
        {
            "name": "locationIds",
            "baseName": "location_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TeamMemberAssignedLocations.attributeTypeMap;
    }
}

/**
* Enumerates the possible assignment types the team member can have
*/
export class TeamMemberAssignedLocationsAssignmentType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TeamMemberAssignedLocationsAssignmentType.attributeTypeMap;
    }
}

/**
* Enumerates the possible statuses the team member can have within a business.
*/
export class TeamMemberStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TeamMemberStatus.attributeTypeMap;
    }
}

/**
* The hourly wage rate that a team member will earn on a `Shift` for doing the job specified by the `title` property of this object.
*/
export class TeamMemberWage {
    /**
    * UUID for this object.
    */
    'id'?: string;
    /**
    * The `Team Member` that this wage is assigned to.
    */
    'teamMemberId'?: string;
    /**
    * The job title that this wage relates to.
    */
    'title'?: string;
    /**
    * Can be a custom-set hourly wage or the calculated effective hourly wage based on annual wage and hours worked per week.
    */
    'hourlyRate'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "teamMemberId",
            "baseName": "team_member_id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "hourlyRate",
            "baseName": "hourly_rate",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return TeamMemberWage.attributeTypeMap;
    }
}

/**
* Represents a tender (i.e., a method of payment) used in a Square transaction.
*/
export class Tender {
    /**
    * The tender's unique ID.
    */
    'id'?: string;
    /**
    * The ID of the transaction's associated location.
    */
    'locationId'?: string;
    /**
    * The ID of the tender's associated transaction.
    */
    'transactionId'?: string;
    /**
    * The timestamp for when the tender was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * An optional note associated with the tender at the time of payment.
    */
    'note'?: string;
    /**
    * The total amount of the tender, including `tip_money`. If the tender has a `payment_id`, the `total_money` of the corresponding `Payment` will be equal to the `amount_money` of the tender.
    */
    'amountMoney'?: Money;
    /**
    * The tip's amount of the tender.
    */
    'tipMoney'?: Money;
    /**
    * The amount of any Square processing fees applied to the tender.  This field is not immediately populated when a new transaction is created. It is usually available after about ten seconds.
    */
    'processingFeeMoney'?: Money;
    /**
    * If the tender is associated with a customer or represents a customer's card on file, this is the ID of the associated customer.
    */
    'customerId'?: string;
    /**
    * The type of tender, such as `CARD` or `CASH`. See [TenderType](#type-tendertype) for possible values
    */
    'type': string;
    /**
    * The details of the card tender.  This value is present only if the value of `type` is `CARD`.
    */
    'cardDetails'?: TenderCardDetails;
    /**
    * The details of the cash tender.  This value is present only if the value of `type` is `CASH`.
    */
    'cashDetails'?: TenderCashDetails;
    /**
    * The details of the bank transfer tender.  This value is present only if the value of `type` is `BANK_TRANSFER`.
    */
    'bankTransferDetails'?: TenderBankTransferDetails;
    /**
    * Additional recipients (other than the merchant) receiving a portion of this tender. For example, fees assessed on the purchase by a third party integration.
    */
    'additionalRecipients'?: Array<AdditionalRecipient>;
    /**
    * The ID of the `Payment` that corresponds to this tender. This value is only present for payments created with the v2 Payments API.
    */
    'paymentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "tipMoney",
            "baseName": "tip_money",
            "type": "Money"
        },
        {
            "name": "processingFeeMoney",
            "baseName": "processing_fee_money",
            "type": "Money"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "cardDetails",
            "baseName": "card_details",
            "type": "TenderCardDetails"
        },
        {
            "name": "cashDetails",
            "baseName": "cash_details",
            "type": "TenderCashDetails"
        },
        {
            "name": "bankTransferDetails",
            "baseName": "bank_transfer_details",
            "type": "TenderBankTransferDetails"
        },
        {
            "name": "additionalRecipients",
            "baseName": "additional_recipients",
            "type": "Array<AdditionalRecipient>"
        },
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tender.attributeTypeMap;
    }
}

/**
* Represents the details of a tender with `type` `BANK_TRANSFER`.  See [PaymentBankTransferDetails](#type-paymentbanktransferdetails) for more exposed details of a bank transfer payment.
*/
export class TenderBankTransferDetails {
    /**
    * The bank transfer's current state.  See `TenderBankTransferDetailsStatus` for possible values. See [TenderBankTransferDetailsStatus](#type-tenderbanktransferdetailsstatus) for possible values
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TenderBankTransferDetails.attributeTypeMap;
    }
}

/**
* Indicates the bank transfer's current status.
*/
export class TenderBankTransferDetailsStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TenderBankTransferDetailsStatus.attributeTypeMap;
    }
}

/**
* Represents additional details of a tender with `type` `CARD` or `SQUARE_GIFT_CARD`
*/
export class TenderCardDetails {
    /**
    * The credit card payment's current state (such as `AUTHORIZED` or `CAPTURED`). See `TenderCardDetailsStatus` for possible values. See [TenderCardDetailsStatus](#type-tendercarddetailsstatus) for possible values
    */
    'status'?: string;
    /**
    * The credit card's non-confidential details.
    */
    'card'?: Card;
    /**
    * The method used to enter the card's details for the transaction. See [TenderCardDetailsEntryMethod](#type-tendercarddetailsentrymethod) for possible values
    */
    'entryMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "entryMethod",
            "baseName": "entry_method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TenderCardDetails.attributeTypeMap;
    }
}

/**
* Indicates the method used to enter the card's details.
*/
export class TenderCardDetailsEntryMethod {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TenderCardDetailsEntryMethod.attributeTypeMap;
    }
}

/**
* Indicates the card transaction's current status.
*/
export class TenderCardDetailsStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TenderCardDetailsStatus.attributeTypeMap;
    }
}

/**
* Represents the details of a tender with `type` `CASH`.
*/
export class TenderCashDetails {
    /**
    * The total amount of cash provided by the buyer, before change is given.
    */
    'buyerTenderedMoney'?: Money;
    /**
    * The amount of change returned to the buyer.
    */
    'changeBackMoney'?: Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "buyerTenderedMoney",
            "baseName": "buyer_tendered_money",
            "type": "Money"
        },
        {
            "name": "changeBackMoney",
            "baseName": "change_back_money",
            "type": "Money"
        }    ];

    static getAttributeTypeMap() {
        return TenderCashDetails.attributeTypeMap;
    }
}

/**
* Indicates a tender's type.
*/
export class TenderType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TenderType.attributeTypeMap;
    }
}

/**
* 
*/
export class TerminalCheckout {
    /**
    * A unique ID for this `TerminalCheckout`
    */
    'id'?: string;
    /**
    * The amount of money (including tax amount) that the Square Terminal device should try to collect.
    */
    'amountMoney': Money;
    /**
    * An optional user-defined reference ID which can be used to associate this TerminalCheckout to another entity in an external system. For example, an order ID generated by a third-party shopping cart. Will also be associated with any payments used to complete the checkout.
    */
    'referenceId'?: string;
    /**
    * An optional note to associate with the checkout, as well any payments used to complete the checkout.
    */
    'note'?: string;
    /**
    * Options to control the display and behavior of the Square Terminal device.
    */
    'deviceOptions': DeviceCheckoutOptions;
    /**
    * The duration as an RFC 3339 duration, after which the checkout will be automatically canceled. TerminalCheckouts that are PENDING will be automatically CANCELED and have a cancellation reason of â€œTIMED\\_OUTâ€.  Default: 5 minutes from creation  Maximum: 5 minutes
    */
    'deadlineDuration'?: string;
    /**
    * The status of the `TerminalCheckout`. Options: PENDING, IN\\_PROGRESS, CANCELED, COMPLETED
    */
    'status'?: string;
    /**
    * Present if the status is CANCELED. See [ActionCancelReason](#type-actioncancelreason) for possible values
    */
    'cancelReason'?: string;
    /**
    * A list of payments created by this `TerminalCheckout`.
    */
    'paymentIds'?: Array<string>;
    /**
    * The time when the `TerminalCheckout` was created as an RFC 3339 timestamp.
    */
    'createdAt'?: string;
    /**
    * The time when the `TerminalCheckout` was last updated as an RFC 3339 timestamp.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "Money"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "deviceOptions",
            "baseName": "device_options",
            "type": "DeviceCheckoutOptions"
        },
        {
            "name": "deadlineDuration",
            "baseName": "deadline_duration",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "cancelReason",
            "baseName": "cancel_reason",
            "type": "string"
        },
        {
            "name": "paymentIds",
            "baseName": "payment_ids",
            "type": "Array<string>"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TerminalCheckout.attributeTypeMap;
    }
}

/**
* 
*/
export class TerminalCheckoutQuery {
    /**
    * Options for filtering returned `TerminalCheckout`s
    */
    'filter'?: TerminalCheckoutQueryFilter;
    /**
    * Option for sorting returned `TerminalCheckout`s
    */
    'sort'?: TerminalCheckoutQuerySort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "TerminalCheckoutQueryFilter"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "TerminalCheckoutQuerySort"
        }    ];

    static getAttributeTypeMap() {
        return TerminalCheckoutQuery.attributeTypeMap;
    }
}

/**
* 
*/
export class TerminalCheckoutQueryFilter {
    /**
    * `TerminalCheckout`s associated with a specific device. If no device is specified then all `TerminalCheckout`s for the merchant will be displayed.
    */
    'deviceId'?: string;
    /**
    * Time range for the beginning of the reporting period. Inclusive. Default: The current time minus one day.
    */
    'createdAt'?: TimeRange;
    /**
    * Filtered results with the desired status of the `TerminalCheckout` Options: PENDING, IN\\_PROGRESS, CANCELED, COMPLETED
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "device_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "TimeRange"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TerminalCheckoutQueryFilter.attributeTypeMap;
    }
}

/**
* 
*/
export class TerminalCheckoutQuerySort {
    /**
    * The order in which results are listed. - `ASC` - oldest to newest - `DESC` - newest to oldest (default).
    */
    'sortOrder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TerminalCheckoutQuerySort.attributeTypeMap;
    }
}

/**
* Represents a generic time range. The start and end values are represented in RFC 3339 format. Time ranges are customized to be inclusive or exclusive based on the needs of a particular endpoint. Refer to the relevant endpoint-specific documentation to determine how time ranges are handled.
*/
export class TimeRange {
    /**
    * A datetime value in RFC 3339 format indicating when the time range starts.
    */
    'startAt'?: string;
    /**
    * A datetime value in RFC 3339 format indicating when the time range ends.
    */
    'endAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startAt",
            "baseName": "start_at",
            "type": "string"
        },
        {
            "name": "endAt",
            "baseName": "end_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TimeRange.attributeTypeMap;
    }
}

/**
* 
*/
export class TipSettings {
    /**
    * Indicates whether tipping is enabled for this checkout. Defaults to false.
    */
    'allowTipping'?: boolean;
    /**
    * Indicates whether tip options should be presented on their own screen before presenting the signature screen during card payment. Defaults to false.
    */
    'separateTipScreen'?: boolean;
    /**
    * Indicates whether custom tip amounts are allowed during the checkout flow. Defaults to false.
    */
    'customTipField'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowTipping",
            "baseName": "allow_tipping",
            "type": "boolean"
        },
        {
            "name": "separateTipScreen",
            "baseName": "separate_tip_screen",
            "type": "boolean"
        },
        {
            "name": "customTipField",
            "baseName": "custom_tip_field",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TipSettings.attributeTypeMap;
    }
}

/**
* Represents a transaction processed with Square, either with the Connect API or with Square Point of Sale.  The `tenders` field of this object lists all methods of payment used to pay in the transaction.
*/
export class Transaction {
    /**
    * The transaction's unique ID, issued by Square payments servers.
    */
    'id'?: string;
    /**
    * The ID of the transaction's associated location.
    */
    'locationId'?: string;
    /**
    * The timestamp for when the transaction was created, in RFC 3339 format.
    */
    'createdAt'?: string;
    /**
    * The tenders used to pay in the transaction.
    */
    'tenders'?: Array<Tender>;
    /**
    * Refunds that have been applied to any tender in the transaction.
    */
    'refunds'?: Array<Refund>;
    /**
    * If the transaction was created with the `Charge` endpoint, this value is the same as the value provided for the `reference_id` parameter in the request to that endpoint. Otherwise, it is not set.
    */
    'referenceId'?: string;
    /**
    * The Square product that processed the transaction. See [TransactionProduct](#type-transactionproduct) for possible values
    */
    'product'?: string;
    /**
    * If the transaction was created in the Square Point of Sale app, this value is the ID generated for the transaction by Square Point of Sale.  This ID has no relationship to the transaction's canonical `id`, which is generated by Square's backend servers. This value is generated for bookkeeping purposes, in case the transaction cannot immediately be completed (for example, if the transaction is processed in offline mode).  It is not currently possible with the Connect API to perform a transaction lookup by this value.
    */
    'clientId'?: string;
    /**
    * The shipping address provided in the request, if any.
    */
    'shippingAddress'?: Address;
    /**
    * The order_id is an identifier for the order associated with this transaction, if any.
    */
    'orderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "tenders",
            "baseName": "tenders",
            "type": "Array<Tender>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<Refund>"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Transaction.attributeTypeMap;
    }
}

/**
* Indicates the Square product used to process a transaction.
*/
export class TransactionProduct {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TransactionProduct.attributeTypeMap;
    }
}

/**
* Transaction type used in the disputed payment.
*/
export class TransactionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TransactionType.attributeTypeMap;
    }
}

/**
* A request to update a `BreakType`
*/
export class UpdateBreakTypeRequest {
    /**
    * The updated `BreakType`.
    */
    'breakType': BreakType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "breakType",
            "baseName": "break_type",
            "type": "BreakType"
        }    ];

    static getAttributeTypeMap() {
        return UpdateBreakTypeRequest.attributeTypeMap;
    }
}

/**
* A response to a request to update a `BreakType`. Contains the requested `BreakType` objects. May contain a set of `Error` objects if the request resulted in errors.
*/
export class UpdateBreakTypeResponse {
    /**
    * The response object.
    */
    'breakType'?: BreakType;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "breakType",
            "baseName": "break_type",
            "type": "BreakType"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateBreakTypeResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be provided in a request to the [UpdateCustomerGroup](#endpoint-updatecustomergroup) endpoint.
*/
export class UpdateCustomerGroupRequest {
    /**
    * The `CustomerGroup` object including all the updates you want to make.
    */
    'group': CustomerGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "group",
            "baseName": "group",
            "type": "CustomerGroup"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomerGroupRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [UpdateCustomerGroup](#endpoint-updatecustomergroup) endpoint.  One of `errors` or `group` is present in a given response (never both).
*/
export class UpdateCustomerGroupResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The successfully updated customer group.
    */
    'group'?: CustomerGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "CustomerGroup"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomerGroupResponse.attributeTypeMap;
    }
}

/**
* Defines the body parameters that can be provided in a request to the UpdateCustomer endpoint.
*/
export class UpdateCustomerRequest {
    /**
    * The given (i.e., first) name associated with the customer profile.
    */
    'givenName'?: string;
    /**
    * The family (i.e., last) name associated with the customer profile.
    */
    'familyName'?: string;
    /**
    * A business name associated with the customer profile.
    */
    'companyName'?: string;
    /**
    * A nickname for the customer profile.
    */
    'nickname'?: string;
    /**
    * The email address associated with the customer profile.
    */
    'emailAddress'?: string;
    /**
    * The physical address associated with the customer profile.
    */
    'address'?: Address;
    /**
    * The 11-digit phone number associated with the customer profile.
    */
    'phoneNumber'?: string;
    /**
    * An optional, second ID used to associate the customer profile with an entity in another system.
    */
    'referenceId'?: string;
    /**
    * A custom note associated with the customer profile.
    */
    'note'?: string;
    /**
    * The birthday associated with the customer profile, in RFC-3339 format. Year is optional, timezone and times are not allowed. For example: `0000-09-01T00:00:00-00:00` indicates a birthday on September 1st. `1998-09-01T00:00:00-00:00` indications a birthday on September 1st __1998__.
    */
    'birthday'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "givenName",
            "baseName": "given_name",
            "type": "string"
        },
        {
            "name": "familyName",
            "baseName": "family_name",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "birthday",
            "baseName": "birthday",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomerRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the UpdateCustomer endpoint.  One of `errors` or `customer` is present in a given response (never both).
*/
export class UpdateCustomerResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The updated customer.
    */
    'customer'?: Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomerResponse.attributeTypeMap;
    }
}

/**
* Describes a `UpdateInvoice` request.
*/
export class UpdateInvoiceRequest {
    /**
    * The invoice fields to update. You need to only specify the fields you want to change. The current invoice version must be specified in the version field. For more information, see [Update an invoice](invoices-api/overview#update-an-invoice).
    */
    'invoice': Invoice;
    /**
    * A unique string that identifies the `UpdateInvoice` request. If you do not provide `idempotency_key` (or provide an empty string as the value), the endpoint treats each request as independent.  For more information, see [Idempotency](https://developer.squareup.com/docs/docs/working-with-apis/idempotency).
    */
    'idempotencyKey'?: string;
    /**
    * List of fields to clear. For examples, see [Update an invoice](https://developer.squareup.com/docs/docs/invoices-api/overview#update-an-invoice).
    */
    'fieldsToClear'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "fieldsToClear",
            "baseName": "fields_to_clear",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceRequest.attributeTypeMap;
    }
}

/**
* Describes a `UpdateInvoice` response.
*/
export class UpdateInvoiceResponse {
    /**
    * The updated invoice.
    */
    'invoice'?: Invoice;
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class UpdateItemModifierListsRequest {
    /**
    * The IDs of the catalog items associated with the CatalogModifierList objects being updated.
    */
    'itemIds': Array<string>;
    /**
    * The IDs of the CatalogModifierList objects to enable for the CatalogItem.
    */
    'modifierListsToEnable'?: Array<string>;
    /**
    * The IDs of the CatalogModifierList objects to disable for the CatalogItem.
    */
    'modifierListsToDisable'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemIds",
            "baseName": "item_ids",
            "type": "Array<string>"
        },
        {
            "name": "modifierListsToEnable",
            "baseName": "modifier_lists_to_enable",
            "type": "Array<string>"
        },
        {
            "name": "modifierListsToDisable",
            "baseName": "modifier_lists_to_disable",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateItemModifierListsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class UpdateItemModifierListsResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * 
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateItemModifierListsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class UpdateItemTaxesRequest {
    /**
    * IDs for the CatalogItems associated with the CatalogTax objects being updated.
    */
    'itemIds': Array<string>;
    /**
    * IDs of the CatalogTax objects to enable.
    */
    'taxesToEnable'?: Array<string>;
    /**
    * IDs of the CatalogTax objects to disable.
    */
    'taxesToDisable'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemIds",
            "baseName": "item_ids",
            "type": "Array<string>"
        },
        {
            "name": "taxesToEnable",
            "baseName": "taxes_to_enable",
            "type": "Array<string>"
        },
        {
            "name": "taxesToDisable",
            "baseName": "taxes_to_disable",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateItemTaxesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class UpdateItemTaxesResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this update in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateItemTaxesResponse.attributeTypeMap;
    }
}

/**
* Request object for the [UpdateLocation](#endpoint-updatelocation) endpoint.
*/
export class UpdateLocationRequest {
    /**
    * The `Location` object with only the fields to update.
    */
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLocationRequest.attributeTypeMap;
    }
}

/**
* Response object returned by the [UpdateLocation](#endpoint-updatelocation) endpoint.
*/
export class UpdateLocationResponse {
    /**
    * Information on errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The updated `Location`.
    */
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLocationResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in requests to the [UpdateOrder](#endpoint-orders-updateorder) endpoint.
*/
export class UpdateOrderRequest {
    /**
    * The [sparse order](https://developer.squareup.com/docs/orders-api/manage-orders#sparse-order-objects) containing only the fields to update and the version the update is being applied to.
    */
    'order'?: Order;
    /**
    * The [dot notation paths](https://developer.squareup.com/docs/orders-api/manage-orders#on-dot-notation) fields to clear. For example, `line_items[uid].note` [Read more about Deleting fields](https://developer.squareup.com/docs/orders-api/manage-orders#delete-fields).
    */
    'fieldsToClear'?: Array<string>;
    /**
    * A value you specify that uniquely identifies this update request  If you're unsure whether a particular update was applied to an order successfully, you can reattempt it with the same idempotency key without worrying about creating duplicate updates to the order. The latest order version will be returned.  See [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "fieldsToClear",
            "baseName": "fields_to_clear",
            "type": "Array<string>"
        },
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateOrderRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [UpdateOrder](#endpoint-orders-updateorder) endpoint.
*/
export class UpdateOrderResponse {
    /**
    * The updated Order.
    */
    'order'?: Order;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateOrderResponse.attributeTypeMap;
    }
}

/**
* A request to update a `Shift` object.
*/
export class UpdateShiftRequest {
    /**
    * The updated `Shift` object.
    */
    'shift': Shift;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shift",
            "baseName": "shift",
            "type": "Shift"
        }    ];

    static getAttributeTypeMap() {
        return UpdateShiftRequest.attributeTypeMap;
    }
}

/**
* The response to a request to update a `Shift`. Contains the updated `Shift` object. May contain a set of `Error` objects if the request resulted in errors.
*/
export class UpdateShiftResponse {
    /**
    * The updated `Shift`.
    */
    'shift'?: Shift;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shift",
            "baseName": "shift",
            "type": "Shift"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateShiftResponse.attributeTypeMap;
    }
}

/**
* Defines parameters in a [UpdateSubscription](#endpoint-subscriptions-updatesubscription) endpoint  request.
*/
export class UpdateSubscriptionRequest {
    /**
    * The subscription object containing the current version, and fields to update. Unset fields will be left at their current server values, and JSON `null` values will be treated as a request to clear the relevant data.
    */
    'subscription'?: Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSubscriptionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response from the [UpdateSubscription](#endpoint-subscriptions-updatesubscription) endpoint.
*/
export class UpdateSubscriptionResponse {
    /**
    * Information about errors encountered during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The modified `Subscription` object.
    */
    'subscription'?: Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSubscriptionResponse.attributeTypeMap;
    }
}

/**
* Represents an update request for a `TeamMember` object.
*/
export class UpdateTeamMemberRequest {
    /**
    * The data which will be used to update the `TeamMember` object.
    */
    'teamMember'?: TeamMember;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMember",
            "baseName": "team_member",
            "type": "TeamMember"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTeamMemberRequest.attributeTypeMap;
    }
}

/**
* Represents a response from an update request, containing the updated `TeamMember` object or error messages.
*/
export class UpdateTeamMemberResponse {
    /**
    * The successfully updated `TeamMember` object.
    */
    'teamMember'?: TeamMember;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMember",
            "baseName": "team_member",
            "type": "TeamMember"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTeamMemberResponse.attributeTypeMap;
    }
}

/**
* Represents an update request for the `WageSetting` object describing a `TeamMember`.
*/
export class UpdateWageSettingRequest {
    /**
    * The new `WageSetting` object that will completely replace the existing one.
    */
    'wageSetting': WageSetting;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wageSetting",
            "baseName": "wage_setting",
            "type": "WageSetting"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWageSettingRequest.attributeTypeMap;
    }
}

/**
* Represents a response from an update request, containing the updated `WageSetting` object or error messages.
*/
export class UpdateWageSettingResponse {
    /**
    * The successfully updated `WageSetting` object.
    */
    'wageSetting'?: WageSetting;
    /**
    * The errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wageSetting",
            "baseName": "wage_setting",
            "type": "WageSetting"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWageSettingResponse.attributeTypeMap;
    }
}

/**
* A request to update a `WorkweekConfig` object
*/
export class UpdateWorkweekConfigRequest {
    /**
    * The updated `WorkweekConfig` object.
    */
    'workweekConfig': WorkweekConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "workweekConfig",
            "baseName": "workweek_config",
            "type": "WorkweekConfig"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWorkweekConfigRequest.attributeTypeMap;
    }
}

/**
* The response to a request to update a `WorkweekConfig` object. Contains the updated `WorkweekConfig` object. May contain a set of `Error` objects if the request resulted in errors.
*/
export class UpdateWorkweekConfigResponse {
    /**
    * The response object.
    */
    'workweekConfig'?: WorkweekConfig;
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "workweekConfig",
            "baseName": "workweek_config",
            "type": "WorkweekConfig"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWorkweekConfigResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class UpsertCatalogObjectRequest {
    /**
    * A value you specify that uniquely identifies this request among all your requests. A common way to create a valid idempotency key is to use a Universally unique identifier (UUID).  If you're unsure whether a particular request was successful, you can reattempt it with the same idempotency key without worrying about creating duplicate objects.  See [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency) for more information.
    */
    'idempotencyKey': string;
    /**
    * A CatalogObject to be created or updated.  - For updates, the object must be active (the `is_deleted` field is not `true`). - For creates, the object ID must start with `#`. The provided ID is replaced with a server-generated ID.
    */
    'object': CatalogObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "idempotencyKey",
            "baseName": "idempotency_key",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "CatalogObject"
        }    ];

    static getAttributeTypeMap() {
        return UpsertCatalogObjectRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class UpsertCatalogObjectResponse {
    /**
    * Information on any errors encountered.
    */
    'errors'?: Array<Error>;
    /**
    * The successfully created or updated CatalogObject.
    */
    'catalogObject'?: CatalogObject;
    /**
    * The mapping between client and server IDs for this upsert.
    */
    'idMappings'?: Array<CatalogIdMapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "catalogObject",
            "baseName": "catalog_object",
            "type": "CatalogObject"
        },
        {
            "name": "idMappings",
            "baseName": "id_mappings",
            "type": "Array<CatalogIdMapping>"
        }    ];

    static getAttributeTypeMap() {
        return UpsertCatalogObjectResponse.attributeTypeMap;
    }
}

/**
* V1AdjustInventoryRequest
*/
export class V1AdjustInventoryRequest {
    /**
    * The number to adjust the variation's quantity by.
    */
    'quantityDelta'?: number;
    /**
    * The reason for the inventory adjustment. See [V1AdjustInventoryRequestAdjustmentType](#type-v1adjustinventoryrequestadjustmenttype) for possible values
    */
    'adjustmentType'?: string;
    /**
    * A note about the inventory adjustment.
    */
    'memo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quantityDelta",
            "baseName": "quantity_delta",
            "type": "number"
        },
        {
            "name": "adjustmentType",
            "baseName": "adjustment_type",
            "type": "string"
        },
        {
            "name": "memo",
            "baseName": "memo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1AdjustInventoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1AdjustInventoryRequestAdjustmentType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1AdjustInventoryRequestAdjustmentType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ApplyFeeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ApplyFeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ApplyModifierListRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ApplyModifierListRequest.attributeTypeMap;
    }
}

/**
* V1BankAccount
*/
export class V1BankAccount {
    /**
    * The bank account's Square-issued ID.
    */
    'id'?: string;
    /**
    * The Square-issued ID of the merchant associated with the bank account.
    */
    'merchantId'?: string;
    /**
    * The name of the bank that manages the account.
    */
    'bankName'?: string;
    /**
    * The name associated with the bank account.
    */
    'name'?: string;
    /**
    * The bank account's routing number.
    */
    'routingNumber'?: string;
    /**
    * The last few digits of the bank account number.
    */
    'accountNumberSuffix'?: string;
    /**
    * The currency code of the currency associated with the bank account, in ISO 4217 format. For example, the currency code for US dollars is USD.
    */
    'currencyCode'?: string;
    /**
    * The bank account's type (for example, savings or checking). See [V1BankAccountType](#type-v1bankaccounttype) for possible values
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routing_number",
            "type": "string"
        },
        {
            "name": "accountNumberSuffix",
            "baseName": "account_number_suffix",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1BankAccount.attributeTypeMap;
    }
}

/**
* 
*/
export class V1BankAccountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1BankAccountType.attributeTypeMap;
    }
}

/**
* V1CashDrawerEvent
*/
export class V1CashDrawerEvent {
    /**
    * The event's unique ID.
    */
    'id'?: string;
    /**
    * The ID of the employee that created the event.
    */
    'employeeId'?: string;
    /**
    * The type of event that occurred. See [V1CashDrawerEventEventType](#type-v1cashdrawereventeventtype) for possible values
    */
    'eventType'?: string;
    /**
    * The amount of money that was added to or removed from the cash drawer because of the event. This value can be positive (for added money) or negative (for removed money).
    */
    'eventMoney'?: V1Money;
    /**
    * The time when the event occurred, in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * An optional description of the event, entered by the employee that created it.
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "eventType",
            "baseName": "event_type",
            "type": "string"
        },
        {
            "name": "eventMoney",
            "baseName": "event_money",
            "type": "V1Money"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1CashDrawerEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CashDrawerEventEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1CashDrawerEventEventType.attributeTypeMap;
    }
}

/**
* Contains details for a single cash drawer shift.
*/
export class V1CashDrawerShift {
    /**
    * The shift's unique ID.
    */
    'id'?: string;
    /**
    * The shift's current state. See [V1CashDrawerShiftEventType](#type-v1cashdrawershifteventtype) for possible values
    */
    'eventType'?: string;
    /**
    * The time when the shift began, in ISO 8601 format.
    */
    'openedAt'?: string;
    /**
    * The time when the shift ended, in ISO 8601 format.
    */
    'endedAt'?: string;
    /**
    * The time when the shift was closed, in ISO 8601 format.
    */
    'closedAt'?: string;
    /**
    * The IDs of all employees that were logged into Square Register at some point during the cash drawer shift.
    */
    'employeeIds'?: Array<string>;
    /**
    * The ID of the employee that started the cash drawer shift.
    */
    'openingEmployeeId'?: string;
    /**
    * The ID of the employee that ended the cash drawer shift.
    */
    'endingEmployeeId'?: string;
    /**
    * The ID of the employee that closed the cash drawer shift by auditing the cash drawer's contents.
    */
    'closingEmployeeId'?: string;
    /**
    * A description of the cash drawer shift.
    */
    'description'?: string;
    /**
    * The amount of money in the cash drawer at the start of the shift.
    */
    'startingCashMoney'?: V1Money;
    /**
    * The amount of money added to the cash drawer from cash payments.
    */
    'cashPaymentMoney'?: V1Money;
    /**
    * The amount of money removed from the cash drawer from cash refunds. This value is always negative or zero.
    */
    'cashRefundsMoney'?: V1Money;
    /**
    * The amount of money added to the cash drawer for reasons other than cash payments.
    */
    'cashPaidInMoney'?: V1Money;
    /**
    * The amount of money removed from the cash drawer for reasons other than cash refunds.
    */
    'cashPaidOutMoney'?: V1Money;
    /**
    * The amount of money that should be in the cash drawer at the end of the shift, based on the shift's other money amounts.
    */
    'expectedCashMoney'?: V1Money;
    /**
    * The amount of money found in the cash drawer at the end of the shift by an auditing employee.
    */
    'closedCashMoney'?: V1Money;
    /**
    * The device running Square Register that was connected to the cash drawer.
    */
    'device'?: Device;
    /**
    * All of the events (payments, refunds, and so on) that involved the cash drawer during the shift.
    */
    'events'?: Array<V1CashDrawerEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "eventType",
            "baseName": "event_type",
            "type": "string"
        },
        {
            "name": "openedAt",
            "baseName": "opened_at",
            "type": "string"
        },
        {
            "name": "endedAt",
            "baseName": "ended_at",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "employeeIds",
            "baseName": "employee_ids",
            "type": "Array<string>"
        },
        {
            "name": "openingEmployeeId",
            "baseName": "opening_employee_id",
            "type": "string"
        },
        {
            "name": "endingEmployeeId",
            "baseName": "ending_employee_id",
            "type": "string"
        },
        {
            "name": "closingEmployeeId",
            "baseName": "closing_employee_id",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "startingCashMoney",
            "baseName": "starting_cash_money",
            "type": "V1Money"
        },
        {
            "name": "cashPaymentMoney",
            "baseName": "cash_payment_money",
            "type": "V1Money"
        },
        {
            "name": "cashRefundsMoney",
            "baseName": "cash_refunds_money",
            "type": "V1Money"
        },
        {
            "name": "cashPaidInMoney",
            "baseName": "cash_paid_in_money",
            "type": "V1Money"
        },
        {
            "name": "cashPaidOutMoney",
            "baseName": "cash_paid_out_money",
            "type": "V1Money"
        },
        {
            "name": "expectedCashMoney",
            "baseName": "expected_cash_money",
            "type": "V1Money"
        },
        {
            "name": "closedCashMoney",
            "baseName": "closed_cash_money",
            "type": "V1Money"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "Device"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<V1CashDrawerEvent>"
        }    ];

    static getAttributeTypeMap() {
        return V1CashDrawerShift.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CashDrawerShiftEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1CashDrawerShiftEventType.attributeTypeMap;
    }
}

/**
* V1Category
*/
export class V1Category {
    /**
    * The category's unique ID.
    */
    'id'?: string;
    /**
    * The category's name.
    */
    'name'?: string;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Category.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateCategoryRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Category;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Category"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateCategoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateDiscountRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Discount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Discount"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateDiscountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateEmployeeRoleRequest {
    /**
    * An EmployeeRole object with a name and permissions, and an optional owner flag.
    */
    'employeeRole'?: V1EmployeeRole;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "employeeRole",
            "baseName": "employee_role",
            "type": "V1EmployeeRole"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateEmployeeRoleRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateFeeRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Fee;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Fee"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateFeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateItemRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Item;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Item"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateItemRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateModifierListRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1ModifierList;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1ModifierList"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateModifierListRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateModifierOptionRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1ModifierOption;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1ModifierOption"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateModifierOptionRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreatePageRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Page;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Page"
        }    ];

    static getAttributeTypeMap() {
        return V1CreatePageRequest.attributeTypeMap;
    }
}

/**
* V1CreateRefundRequest
*/
export class V1CreateRefundRequest {
    /**
    * The ID of the payment to refund. If you are creating a `PARTIAL` refund for a split tender payment, instead provide the id of the particular tender you want to refund.
    */
    'paymentId': string;
    /**
    * TThe type of refund (FULL or PARTIAL). See [V1CreateRefundRequestType](#type-v1createrefundrequesttype) for possible values
    */
    'type': string;
    /**
    * The reason for the refund.
    */
    'reason': string;
    /**
    * The amount of money to refund. Required only for PARTIAL refunds.
    */
    'refundedMoney'?: V1Money;
    /**
    * An optional key to ensure idempotence if you issue the same PARTIAL refund request more than once.
    */
    'requestIdempotenceKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "refundedMoney",
            "baseName": "refunded_money",
            "type": "V1Money"
        },
        {
            "name": "requestIdempotenceKey",
            "baseName": "request_idempotence_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateRefundRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateRefundRequestType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1CreateRefundRequestType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1CreateVariationRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body'?: V1Variation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Variation"
        }    ];

    static getAttributeTypeMap() {
        return V1CreateVariationRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteCategoryRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteCategoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteDiscountRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteDiscountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteFeeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteFeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteItemRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteItemRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteModifierListRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteModifierListRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteModifierOptionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteModifierOptionRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeletePageCellRequest {
    /**
    * The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
    */
    'row'?: string;
    /**
    * The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
    */
    'column'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "row",
            "baseName": "row",
            "type": "string"
        },
        {
            "name": "column",
            "baseName": "column",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1DeletePageCellRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeletePageRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeletePageRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteTimecardRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteTimecardRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteTimecardResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteTimecardResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DeleteVariationRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DeleteVariationRequest.attributeTypeMap;
    }
}

/**
* V1Discount
*/
export class V1Discount {
    /**
    * The discount's unique ID.
    */
    'id'?: string;
    /**
    * The discount's name.
    */
    'name'?: string;
    /**
    * The rate of the discount, as a string representation of a decimal number. A value of 0.07 corresponds to a rate of 7%. This rate is 0 if discount_type is VARIABLE_PERCENTAGE.
    */
    'rate'?: string;
    /**
    * The amount of the discount. This amount is 0 if discount_type is VARIABLE_AMOUNT. This field is not included for rate-based discounts.
    */
    'amountMoney'?: V1Money;
    /**
    * Indicates whether the discount is a FIXED value or entered at the time of sale. See [V1DiscountDiscountType](#type-v1discountdiscounttype) for possible values
    */
    'discountType'?: string;
    /**
    * Indicates whether a mobile staff member needs to enter their PIN to apply the discount to a payment.
    */
    'pinRequired'?: boolean;
    /**
    * The color of the discount's display label in Square Point of Sale, if not the default color. The default color is 9da2a6. See [V1DiscountColor](#type-v1discountcolor) for possible values
    */
    'color'?: string;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "V1Money"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "string"
        },
        {
            "name": "pinRequired",
            "baseName": "pin_required",
            "type": "boolean"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Discount.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DiscountColor {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DiscountColor.attributeTypeMap;
    }
}

/**
* 
*/
export class V1DiscountDiscountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1DiscountDiscountType.attributeTypeMap;
    }
}

/**
* Represents one of a business's employees.
*/
export class V1Employee {
    /**
    * The employee's unique ID.
    */
    'id'?: string;
    /**
    * The employee's first name.
    */
    'firstName': string;
    /**
    * The employee's last name.
    */
    'lastName': string;
    /**
    * The ids of the employee's associated roles. Currently, you can specify only one or zero roles per employee.
    */
    'roleIds'?: Array<string>;
    /**
    * The IDs of the locations the employee is allowed to clock in at.
    */
    'authorizedLocationIds'?: Array<string>;
    /**
    * The employee's email address.
    */
    'email'?: string;
    /**
    * CWhether the employee is ACTIVE or INACTIVE. Inactive employees cannot sign in to Square Register.Merchants update this field from the Square Dashboard. See [V1EmployeeStatus](#type-v1employeestatus) for possible values
    */
    'status'?: string;
    /**
    * An ID the merchant can set to associate the employee with an entity in another system.
    */
    'externalId'?: string;
    /**
    * The time when the employee entity was created, in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * The time when the employee entity was most recently updated, in ISO 8601 format.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "roleIds",
            "baseName": "role_ids",
            "type": "Array<string>"
        },
        {
            "name": "authorizedLocationIds",
            "baseName": "authorized_location_ids",
            "type": "Array<string>"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Employee.attributeTypeMap;
    }
}

/**
* V1EmployeeRole
*/
export class V1EmployeeRole {
    /**
    * The role's unique ID, Can only be set by Square.
    */
    'id'?: string;
    /**
    * The role's merchant-defined name.
    */
    'name': string;
    /**
    * The role's permissions. See [V1EmployeeRolePermissions](#type-v1employeerolepermissions) for possible values
    */
    'permissions': Array<string>;
    /**
    * If true, employees with this role have all permissions, regardless of the values indicated in permissions.
    */
    'isOwner'?: boolean;
    /**
    * The time when the employee entity was created, in ISO 8601 format. Is set by Square when the Role is created.
    */
    'createdAt'?: string;
    /**
    * The time when the employee entity was most recently updated, in ISO 8601 format. Is set by Square when the Role updated.
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Array<string>"
        },
        {
            "name": "isOwner",
            "baseName": "is_owner",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1EmployeeRole.attributeTypeMap;
    }
}

/**
* 
*/
export class V1EmployeeRolePermissions {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1EmployeeRolePermissions.attributeTypeMap;
    }
}

/**
* 
*/
export class V1EmployeeStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1EmployeeStatus.attributeTypeMap;
    }
}

/**
* V1Fee
*/
export class V1Fee {
    /**
    * The fee's unique ID.
    */
    'id'?: string;
    /**
    * The fee's name.
    */
    'name'?: string;
    /**
    * The rate of the fee, as a string representation of a decimal number. A value of 0.07 corresponds to a rate of 7%.
    */
    'rate'?: string;
    /**
    * Forthcoming See [V1FeeCalculationPhase](#type-v1feecalculationphase) for possible values
    */
    'calculationPhase'?: string;
    /**
    * The type of adjustment the fee applies to a payment. Currently, this value is TAX for all fees. See [V1FeeAdjustmentType](#type-v1feeadjustmenttype) for possible values
    */
    'adjustmentType'?: string;
    /**
    * If true, the fee applies to custom amounts entered into Square Point of Sale that are not associated with a particular item.
    */
    'appliesToCustomAmounts'?: boolean;
    /**
    * If true, the fee is applied to all appropriate items. If false, the fee is not applied at all.
    */
    'enabled'?: boolean;
    /**
    * Whether the fee is ADDITIVE or INCLUSIVE. See [V1FeeInclusionType](#type-v1feeinclusiontype) for possible values
    */
    'inclusionType'?: string;
    /**
    * In countries with multiple classifications for sales taxes, indicates which classification the fee falls under. Currently relevant only to Canadian merchants. See [V1FeeType](#type-v1feetype) for possible values
    */
    'type'?: string;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "calculationPhase",
            "baseName": "calculation_phase",
            "type": "string"
        },
        {
            "name": "adjustmentType",
            "baseName": "adjustment_type",
            "type": "string"
        },
        {
            "name": "appliesToCustomAmounts",
            "baseName": "applies_to_custom_amounts",
            "type": "boolean"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "inclusionType",
            "baseName": "inclusion_type",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Fee.attributeTypeMap;
    }
}

/**
* 
*/
export class V1FeeAdjustmentType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1FeeAdjustmentType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1FeeCalculationPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1FeeCalculationPhase.attributeTypeMap;
    }
}

/**
* 
*/
export class V1FeeInclusionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1FeeInclusionType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1FeeType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1FeeType.attributeTypeMap;
    }
}

/**
* V1InventoryEntry
*/
export class V1InventoryEntry {
    /**
    * The variation that the entry corresponds to.
    */
    'variationId'?: string;
    /**
    * The current available quantity of the item variation.
    */
    'quantityOnHand'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variationId",
            "baseName": "variation_id",
            "type": "string"
        },
        {
            "name": "quantityOnHand",
            "baseName": "quantity_on_hand",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V1InventoryEntry.attributeTypeMap;
    }
}

/**
* V1Item
*/
export class V1Item {
    /**
    * The item's ID. Must be unique among all entity IDs ever provided on behalf of the merchant. You can never reuse an ID. This value can include alphanumeric characters, dashes (-), and underscores (_).
    */
    'id'?: string;
    /**
    * The item's name.
    */
    'name'?: string;
    /**
    * The item's description.
    */
    'description'?: string;
    /**
    * The item's type. This value is NORMAL for almost all items. See [V1ItemType](#type-v1itemtype) for possible values
    */
    'type'?: string;
    /**
    * The color of the discount's display label in Square Point of Sale, if not the default color. The default color is 9da2a6. See [V1ItemColor](#type-v1itemcolor) for possible values
    */
    'color'?: string;
    /**
    * The text of the item's display label in Square Point of Sale. Only up to the first five characters of the string are used.
    */
    'abbreviation'?: string;
    /**
    * Indicates whether the item is viewable from the merchant's online store (PUBLIC) or PRIVATE. See [V1ItemVisibility](#type-v1itemvisibility) for possible values
    */
    'visibility'?: string;
    /**
    * If true, the item can be added to shipping orders from the merchant's online store.
    */
    'availableOnline'?: boolean;
    /**
    * The item's master image, if any.
    */
    'masterImage'?: V1ItemImage;
    /**
    * The category the item belongs to, if any.
    */
    'category'?: V1Category;
    /**
    * The item's variations. You must specify at least one variation.
    */
    'variations'?: Array<V1Variation>;
    /**
    * The modifier lists that apply to the item, if any.
    */
    'modifierLists'?: Array<V1ModifierList>;
    /**
    * The fees that apply to the item, if any.
    */
    'fees'?: Array<V1Fee>;
    /**
    * Deprecated. This field is not used.
    */
    'taxable'?: boolean;
    /**
    * The ID of the item's category, if any.
    */
    'categoryId'?: string;
    /**
    * If true, the item can be added to pickup orders from the merchant's online store. Default value: false
    */
    'availableForPickup'?: boolean;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "abbreviation",
            "baseName": "abbreviation",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        },
        {
            "name": "availableOnline",
            "baseName": "available_online",
            "type": "boolean"
        },
        {
            "name": "masterImage",
            "baseName": "master_image",
            "type": "V1ItemImage"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "V1Category"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<V1Variation>"
        },
        {
            "name": "modifierLists",
            "baseName": "modifier_lists",
            "type": "Array<V1ModifierList>"
        },
        {
            "name": "fees",
            "baseName": "fees",
            "type": "Array<V1Fee>"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "string"
        },
        {
            "name": "availableForPickup",
            "baseName": "available_for_pickup",
            "type": "boolean"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Item.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ItemColor {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ItemColor.attributeTypeMap;
    }
}

/**
* V1ItemImage
*/
export class V1ItemImage {
    /**
    * The image's unique ID.
    */
    'id'?: string;
    /**
    * The image's publicly accessible URL.
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ItemImage.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ItemType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ItemType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ItemVisibility {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ItemVisibility.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListBankAccountsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListBankAccountsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListBankAccountsResponse {
    /**
    * 
    */
    'items'?: Array<V1BankAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1BankAccount>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListBankAccountsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListCashDrawerShiftsRequest {
    /**
    * The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
    */
    'beginTime'?: string;
    /**
    * The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
    */
    'endTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListCashDrawerShiftsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListCashDrawerShiftsResponse {
    /**
    * 
    */
    'items'?: Array<V1CashDrawerShift>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1CashDrawerShift>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListCashDrawerShiftsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListCategoriesRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListCategoriesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListCategoriesResponse {
    /**
    * 
    */
    'items'?: Array<V1Category>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Category>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListCategoriesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListDiscountsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListDiscountsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListDiscountsResponse {
    /**
    * 
    */
    'items'?: Array<V1Discount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Discount>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListDiscountsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListEmployeeRolesRequest {
    /**
    * The order in which employees are listed in the response, based on their created_at field.Default value: ASC See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListEmployeeRolesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListEmployeeRolesResponse {
    /**
    * 
    */
    'items'?: Array<V1EmployeeRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1EmployeeRole>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListEmployeeRolesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListEmployeesRequest {
    /**
    * The order in which employees are listed in the response, based on their created_at field.      Default value: ASC See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
    */
    'beginUpdatedAt'?: string;
    /**
    * If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
    */
    'endUpdatedAt'?: string;
    /**
    * If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
    */
    'beginCreatedAt'?: string;
    /**
    * If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
    */
    'endCreatedAt'?: string;
    /**
    * If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE). See [V1ListEmployeesRequestStatus](#type-v1listemployeesrequeststatus) for possible values
    */
    'status'?: string;
    /**
    * If provided, the endpoint returns only employee entities with the specified external_id.
    */
    'externalId'?: string;
    /**
    * The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "beginUpdatedAt",
            "baseName": "begin_updated_at",
            "type": "string"
        },
        {
            "name": "endUpdatedAt",
            "baseName": "end_updated_at",
            "type": "string"
        },
        {
            "name": "beginCreatedAt",
            "baseName": "begin_created_at",
            "type": "string"
        },
        {
            "name": "endCreatedAt",
            "baseName": "end_created_at",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListEmployeesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListEmployeesRequestStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListEmployeesRequestStatus.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListEmployeesResponse {
    /**
    * 
    */
    'items'?: Array<V1Employee>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Employee>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListEmployeesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListFeesRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListFeesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListFeesResponse {
    /**
    * 
    */
    'items'?: Array<V1Fee>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Fee>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListFeesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListInventoryRequest {
    /**
    * The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListInventoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListInventoryResponse {
    /**
    * 
    */
    'items'?: Array<V1InventoryEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1InventoryEntry>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListInventoryResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListItemsRequest {
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListItemsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListItemsResponse {
    /**
    * 
    */
    'items'?: Array<V1Item>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Item>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListItemsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListLocationsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListLocationsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListLocationsResponse {
    /**
    * 
    */
    'items'?: Array<V1Merchant>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Merchant>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListLocationsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListModifierListsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListModifierListsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListModifierListsResponse {
    /**
    * 
    */
    'items'?: Array<V1ModifierList>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1ModifierList>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListModifierListsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListOrdersRequest {
    /**
    * TThe order in which payments are listed in the response. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The maximum number of payments to return in a single response. This value cannot exceed 200.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListOrdersRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListOrdersResponse {
    /**
    * 
    */
    'items'?: Array<V1Order>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Order>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListOrdersResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListPagesRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListPagesRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListPagesResponse {
    /**
    * 
    */
    'items'?: Array<V1Page>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Page>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListPagesResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListPaymentsRequest {
    /**
    * The order in which payments are listed in the response. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
    */
    'endTime'?: string;
    /**
    * The maximum number of payments to return in a single response. This value cannot exceed 200.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;
    /**
    * Indicates whether or not to include partial payments in the response. Partial payments will have the tenders collected so far, but the itemizations will be empty until the payment is completed.
    */
    'includePartial'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        },
        {
            "name": "includePartial",
            "baseName": "include_partial",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V1ListPaymentsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListPaymentsResponse {
    /**
    * 
    */
    'items'?: Array<V1Payment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Payment>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListPaymentsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListRefundsRequest {
    /**
    * TThe order in which payments are listed in the response. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
    */
    'endTime'?: string;
    /**
    * The approximate number of refunds to return in a single response. Default: 100. Max: 200. Response may contain more results than the prescribed limit when refunds are made simultaneously to multiple tenders in a payment or when refunds are generated in an exchange to account for the value of returned goods.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListRefundsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListRefundsResponse {
    /**
    * 
    */
    'items'?: Array<V1Refund>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Refund>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListRefundsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListSettlementsRequest {
    /**
    * The order in which settlements are listed in the response. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
    */
    'beginTime'?: string;
    /**
    * The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
    */
    'endTime'?: string;
    /**
    * The maximum number of settlements to return in a single response. This value cannot exceed 200.
    */
    'limit'?: number;
    /**
    * Provide this parameter to retrieve only settlements with a particular status (SENT or FAILED). See [V1ListSettlementsRequestStatus](#type-v1listsettlementsrequeststatus) for possible values
    */
    'status'?: string;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "beginTime",
            "baseName": "begin_time",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListSettlementsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListSettlementsRequestStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListSettlementsRequestStatus.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListSettlementsResponse {
    /**
    * 
    */
    'items'?: Array<V1Settlement>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Settlement>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListSettlementsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListTimecardEventsRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ListTimecardEventsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListTimecardEventsResponse {
    /**
    * 
    */
    'items'?: Array<V1TimecardEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1TimecardEvent>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListTimecardEventsResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListTimecardsRequest {
    /**
    * The order in which timecards are listed in the response, based on their created_at field. See [SortOrder](#type-sortorder) for possible values
    */
    'order'?: string;
    /**
    * If provided, the endpoint returns only timecards for the employee with the specified ID.
    */
    'employeeId'?: string;
    /**
    * If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
    */
    'beginClockinTime'?: string;
    /**
    * If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
    */
    'endClockinTime'?: string;
    /**
    * If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
    */
    'beginClockoutTime'?: string;
    /**
    * If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
    */
    'endClockoutTime'?: string;
    /**
    * If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
    */
    'beginUpdatedAt'?: string;
    /**
    * If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
    */
    'endUpdatedAt'?: string;
    /**
    * If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don't provide this parameter, both valid and deleted timecards are returned.
    */
    'deleted'?: boolean;
    /**
    * The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
    */
    'limit'?: number;
    /**
    * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
    */
    'batchToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "beginClockinTime",
            "baseName": "begin_clockin_time",
            "type": "string"
        },
        {
            "name": "endClockinTime",
            "baseName": "end_clockin_time",
            "type": "string"
        },
        {
            "name": "beginClockoutTime",
            "baseName": "begin_clockout_time",
            "type": "string"
        },
        {
            "name": "endClockoutTime",
            "baseName": "end_clockout_time",
            "type": "string"
        },
        {
            "name": "beginUpdatedAt",
            "baseName": "begin_updated_at",
            "type": "string"
        },
        {
            "name": "endUpdatedAt",
            "baseName": "end_updated_at",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "batchToken",
            "baseName": "batch_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ListTimecardsRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ListTimecardsResponse {
    /**
    * 
    */
    'items'?: Array<V1Timecard>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<V1Timecard>"
        }    ];

    static getAttributeTypeMap() {
        return V1ListTimecardsResponse.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the **RetrieveBusiness** endpoint.
*/
export class V1Merchant {
    /**
    * The merchant account's unique identifier.
    */
    'id'?: string;
    /**
    * The name associated with the merchant account.
    */
    'name'?: string;
    /**
    * The email address associated with the merchant account.
    */
    'email'?: string;
    /**
    * Indicates whether the merchant account corresponds to a single-location account (LOCATION) or a business account (BUSINESS). This value is almost always LOCATION. See [V1MerchantAccountType](#type-v1merchantaccounttype) for possible values
    */
    'accountType'?: string;
    /**
    * Capabilities that are enabled for the merchant's Square account. Capabilities that are not listed in this array are not enabled for the account.
    */
    'accountCapabilities'?: Array<string>;
    /**
    * The country associated with the merchant account, in ISO 3166-1-alpha-2 format.
    */
    'countryCode'?: string;
    /**
    * The language associated with the merchant account, in BCP 47 format.
    */
    'languageCode'?: string;
    /**
    * The currency associated with the merchant account, in ISO 4217 format. For example, the currency code for US dollars is USD.
    */
    'currencyCode'?: string;
    /**
    * The name of the merchant's business.
    */
    'businessName'?: string;
    /**
    * The address of the merchant's business.
    */
    'businessAddress'?: Address;
    /**
    * The phone number of the merchant's business.
    */
    'businessPhone'?: V1PhoneNumber;
    /**
    * The type of business operated by the merchant. See [V1MerchantBusinessType](#type-v1merchantbusinesstype) for possible values
    */
    'businessType'?: string;
    /**
    * The merchant's shipping address.
    */
    'shippingAddress'?: Address;
    /**
    * Additional information for a single-location account specified by its associated business account, if it has one.
    */
    'locationDetails'?: V1MerchantLocationDetails;
    /**
    * The URL of the merchant's online store.
    */
    'marketUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "accountCapabilities",
            "baseName": "account_capabilities",
            "type": "Array<string>"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "language_code",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "business_name",
            "type": "string"
        },
        {
            "name": "businessAddress",
            "baseName": "business_address",
            "type": "Address"
        },
        {
            "name": "businessPhone",
            "baseName": "business_phone",
            "type": "V1PhoneNumber"
        },
        {
            "name": "businessType",
            "baseName": "business_type",
            "type": "string"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "locationDetails",
            "baseName": "location_details",
            "type": "V1MerchantLocationDetails"
        },
        {
            "name": "marketUrl",
            "baseName": "market_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Merchant.attributeTypeMap;
    }
}

/**
* 
*/
export class V1MerchantAccountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1MerchantAccountType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1MerchantBusinessType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1MerchantBusinessType.attributeTypeMap;
    }
}

/**
* Additional information for a single-location account specified by its associated business account, if it has one.
*/
export class V1MerchantLocationDetails {
    /**
    * The nickname assigned to the single-location account by the parent business. This value appears in the parent business's multi-location dashboard.
    */
    'nickname'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1MerchantLocationDetails.attributeTypeMap;
    }
}

/**
* V1ModifierList
*/
export class V1ModifierList {
    /**
    * The modifier list's unique ID.
    */
    'id'?: string;
    /**
    * The modifier list's name.
    */
    'name'?: string;
    /**
    * Indicates whether MULTIPLE options or a SINGLE option from the modifier list can be applied to a single item. See [V1ModifierListSelectionType](#type-v1modifierlistselectiontype) for possible values
    */
    'selectionType'?: string;
    /**
    * The options included in the modifier list.
    */
    'modifierOptions'?: Array<V1ModifierOption>;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "selectionType",
            "baseName": "selection_type",
            "type": "string"
        },
        {
            "name": "modifierOptions",
            "baseName": "modifier_options",
            "type": "Array<V1ModifierOption>"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ModifierList.attributeTypeMap;
    }
}

/**
* 
*/
export class V1ModifierListSelectionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1ModifierListSelectionType.attributeTypeMap;
    }
}

/**
* V1ModifierOption
*/
export class V1ModifierOption {
    /**
    * The modifier option's unique ID.
    */
    'id'?: string;
    /**
    * The modifier option's name.
    */
    'name'?: string;
    /**
    * The modifier option's price.
    */
    'priceMoney'?: V1Money;
    /**
    * If true, the modifier option is the default option in a modifier list for which selection_type is SINGLE.
    */
    'onByDefault'?: boolean;
    /**
    * Indicates the modifier option's list position when displayed in Square Point of Sale and the merchant dashboard. If more than one modifier option in the same modifier list has the same ordinal value, those options are displayed in alphabetical order.
    */
    'ordinal'?: number;
    /**
    * The ID of the modifier list the option belongs to.
    */
    'modifierListId'?: string;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priceMoney",
            "baseName": "price_money",
            "type": "V1Money"
        },
        {
            "name": "onByDefault",
            "baseName": "on_by_default",
            "type": "boolean"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "modifierListId",
            "baseName": "modifier_list_id",
            "type": "string"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1ModifierOption.attributeTypeMap;
    }
}

/**
* 
*/
export class V1Money {
    /**
    * Amount in the lowest denominated value of this Currency. E.g. in USD these are cents, in JPY they are Yen (which do not have a 'cent' concept).
    */
    'amount'?: number;
    /**
    *  See [Currency](#type-currency) for possible values
    */
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Money.attributeTypeMap;
    }
}

/**
* V1Order
*/
export class V1Order {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The order's unique identifier.
    */
    'id'?: string;
    /**
    * The email address of the order's buyer.
    */
    'buyerEmail'?: string;
    /**
    * The name of the order's buyer.
    */
    'recipientName'?: string;
    /**
    * The phone number to use for the order's delivery.
    */
    'recipientPhoneNumber'?: string;
    /**
    * Whether the tax is an ADDITIVE tax or an INCLUSIVE tax. See [V1OrderState](#type-v1orderstate) for possible values
    */
    'state'?: string;
    /**
    * The address to ship the order to.
    */
    'shippingAddress'?: Address;
    /**
    * The amount of all items purchased in the order, before taxes and shipping.
    */
    'subtotalMoney'?: V1Money;
    /**
    * The shipping cost for the order.
    */
    'totalShippingMoney'?: V1Money;
    /**
    * The total of all taxes applied to the order.
    */
    'totalTaxMoney'?: V1Money;
    /**
    * The total cost of the order.
    */
    'totalPriceMoney'?: V1Money;
    /**
    * The total of all discounts applied to the order.
    */
    'totalDiscountMoney'?: V1Money;
    /**
    * The time when the order was created, in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * The time when the order was last modified, in ISO 8601 format.
    */
    'updatedAt'?: string;
    /**
    * The time when the order expires if no action is taken, in ISO 8601 format.
    */
    'expiresAt'?: string;
    /**
    * The unique identifier of the payment associated with the order.
    */
    'paymentId'?: string;
    /**
    * A note provided by the buyer when the order was created, if any.
    */
    'buyerNote'?: string;
    /**
    * A note provided by the merchant when the order's state was set to COMPLETED, if any
    */
    'completedNote'?: string;
    /**
    * A note provided by the merchant when the order's state was set to REFUNDED, if any.
    */
    'refundedNote'?: string;
    /**
    * A note provided by the merchant when the order's state was set to CANCELED, if any.
    */
    'canceledNote'?: string;
    /**
    * The tender used to pay for the order.
    */
    'tender'?: V1Tender;
    /**
    * The history of actions associated with the order.
    */
    'orderHistory'?: Array<V1OrderHistoryEntry>;
    /**
    * The promo code provided by the buyer, if any.
    */
    'promoCode'?: string;
    /**
    * For Bitcoin transactions, the address that the buyer sent Bitcoin to.
    */
    'btcReceiveAddress'?: string;
    /**
    * For Bitcoin transactions, the price of the buyer's order in satoshi (100 million satoshi equals 1 BTC).
    */
    'btcPriceSatoshi'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "buyerEmail",
            "baseName": "buyer_email",
            "type": "string"
        },
        {
            "name": "recipientName",
            "baseName": "recipient_name",
            "type": "string"
        },
        {
            "name": "recipientPhoneNumber",
            "baseName": "recipient_phone_number",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "Address"
        },
        {
            "name": "subtotalMoney",
            "baseName": "subtotal_money",
            "type": "V1Money"
        },
        {
            "name": "totalShippingMoney",
            "baseName": "total_shipping_money",
            "type": "V1Money"
        },
        {
            "name": "totalTaxMoney",
            "baseName": "total_tax_money",
            "type": "V1Money"
        },
        {
            "name": "totalPriceMoney",
            "baseName": "total_price_money",
            "type": "V1Money"
        },
        {
            "name": "totalDiscountMoney",
            "baseName": "total_discount_money",
            "type": "V1Money"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "string"
        },
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "buyerNote",
            "baseName": "buyer_note",
            "type": "string"
        },
        {
            "name": "completedNote",
            "baseName": "completed_note",
            "type": "string"
        },
        {
            "name": "refundedNote",
            "baseName": "refunded_note",
            "type": "string"
        },
        {
            "name": "canceledNote",
            "baseName": "canceled_note",
            "type": "string"
        },
        {
            "name": "tender",
            "baseName": "tender",
            "type": "V1Tender"
        },
        {
            "name": "orderHistory",
            "baseName": "order_history",
            "type": "Array<V1OrderHistoryEntry>"
        },
        {
            "name": "promoCode",
            "baseName": "promo_code",
            "type": "string"
        },
        {
            "name": "btcReceiveAddress",
            "baseName": "btc_receive_address",
            "type": "string"
        },
        {
            "name": "btcPriceSatoshi",
            "baseName": "btc_price_satoshi",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V1Order.attributeTypeMap;
    }
}

/**
* V1OrderHistoryEntry
*/
export class V1OrderHistoryEntry {
    /**
    * The type of action performed on the order. See [V1OrderHistoryEntryAction](#type-v1orderhistoryentryaction) for possible values
    */
    'action'?: string;
    /**
    * The time when the action was performed, in ISO 8601 format.
    */
    'createdAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1OrderHistoryEntry.attributeTypeMap;
    }
}

/**
* 
*/
export class V1OrderHistoryEntryAction {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1OrderHistoryEntryAction.attributeTypeMap;
    }
}

/**
* 
*/
export class V1OrderState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1OrderState.attributeTypeMap;
    }
}

/**
* V1Page
*/
export class V1Page {
    /**
    * The page's unique identifier.
    */
    'id'?: string;
    /**
    * The page's name, if any.
    */
    'name'?: string;
    /**
    * The page's position in the merchant's list of pages. Always an integer between 0 and 6, inclusive.
    */
    'pageIndex'?: number;
    /**
    * The cells included on the page.
    */
    'cells'?: Array<V1PageCell>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pageIndex",
            "baseName": "page_index",
            "type": "number"
        },
        {
            "name": "cells",
            "baseName": "cells",
            "type": "Array<V1PageCell>"
        }    ];

    static getAttributeTypeMap() {
        return V1Page.attributeTypeMap;
    }
}

/**
* V1PageCell
*/
export class V1PageCell {
    /**
    * The unique identifier of the page the cell is included on.
    */
    'pageId'?: string;
    /**
    * The row of the cell. Always an integer between 0 and 4, inclusive.
    */
    'row'?: number;
    /**
    * The column of the cell. Always an integer between 0 and 4, inclusive.
    */
    'column'?: number;
    /**
    * The type of entity represented in the cell (ITEM, DISCOUNT, CATEGORY, or PLACEHOLDER). See [V1PageCellObjectType](#type-v1pagecellobjecttype) for possible values
    */
    'objectType'?: string;
    /**
    * The unique identifier of the entity represented in the cell. Not present for cells with an object_type of PLACEHOLDER.
    */
    'objectId'?: string;
    /**
    * For a cell with an object_type of PLACEHOLDER, this value indicates the cell's special behavior. See [V1PageCellPlaceholderType](#type-v1pagecellplaceholdertype) for possible values
    */
    'placeholderType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pageId",
            "baseName": "page_id",
            "type": "string"
        },
        {
            "name": "row",
            "baseName": "row",
            "type": "number"
        },
        {
            "name": "column",
            "baseName": "column",
            "type": "number"
        },
        {
            "name": "objectType",
            "baseName": "object_type",
            "type": "string"
        },
        {
            "name": "objectId",
            "baseName": "object_id",
            "type": "string"
        },
        {
            "name": "placeholderType",
            "baseName": "placeholder_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PageCell.attributeTypeMap;
    }
}

/**
* 
*/
export class V1PageCellObjectType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1PageCellObjectType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1PageCellPlaceholderType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1PageCellPlaceholderType.attributeTypeMap;
    }
}

/**
* A payment represents a paid transaction between a Square merchant and a customer. Payment details are usually available from Connect API endpoints within a few minutes after the transaction completes.  Each Payment object includes several fields that end in `_money`. These fields describe the various amounts of money that contribute to the payment total:  <ul> <li> Monetary values are <b>positive</b> if they represent an <em>increase</em> in the amount of money the merchant receives (e.g., <code>tax_money</code>, <code>tip_money</code>). </li> <li> Monetary values are <b>negative</b> if they represent an <em>decrease</em> in the amount of money the merchant receives (e.g., <code>discount_money</code>, <code>refunded_money</code>). </li> </ul>
*/
export class V1Payment {
    /**
    * The payment's unique identifier.
    */
    'id'?: string;
    /**
    * The unique identifier of the merchant that took the payment.
    */
    'merchantId'?: string;
    /**
    * The time when the payment was created, in ISO 8601 format. Reflects the time of the first payment if the object represents an incomplete partial payment, and the time of the last or complete payment otherwise.
    */
    'createdAt'?: string;
    /**
    * The unique identifier of the Square account that took the payment.
    */
    'creatorId'?: string;
    /**
    * The device that took the payment.
    */
    'device'?: Device;
    /**
    * The URL of the payment's detail page in the merchant dashboard. The merchant must be signed in to the merchant dashboard to view this page.
    */
    'paymentUrl'?: string;
    /**
    * The URL of the receipt for the payment. Note that for split tender payments, this URL corresponds to the receipt for the first tender listed in the payment's tender field. Each Tender object has its own receipt_url field you can use to get the other receipts associated with a split tender payment.
    */
    'receiptUrl'?: string;
    /**
    * The sum of all inclusive taxes associated with the payment.
    */
    'inclusiveTaxMoney'?: V1Money;
    /**
    * The sum of all additive taxes associated with the payment.
    */
    'additiveTaxMoney'?: V1Money;
    /**
    * The total of all taxes applied to the payment. This is always the sum of inclusive_tax_money and additive_tax_money.
    */
    'taxMoney'?: V1Money;
    /**
    * The total of all tips applied to the payment.
    */
    'tipMoney'?: V1Money;
    /**
    * The total of all discounts applied to the payment.
    */
    'discountMoney'?: V1Money;
    /**
    * The total of all discounts applied to the payment.
    */
    'totalCollectedMoney'?: V1Money;
    /**
    * The total of all processing fees collected by Square for the payment.
    */
    'processingFeeMoney'?: V1Money;
    /**
    * The amount to be deposited into the merchant's bank account for the payment.
    */
    'netTotalMoney'?: V1Money;
    /**
    * The total of all refunds applied to the payment.
    */
    'refundedMoney'?: V1Money;
    /**
    * The total of all sales, including any applicable taxes, rounded to the smallest legal unit of currency (e.g., the nearest penny in USD, the nearest nickel in CAD)
    */
    'swedishRoundingMoney'?: V1Money;
    /**
    * The total of all sales, including any applicable taxes.
    */
    'grossSalesMoney'?: V1Money;
    /**
    * The total of all sales, minus any applicable taxes.
    */
    'netSalesMoney'?: V1Money;
    /**
    * All of the inclusive taxes associated with the payment.
    */
    'inclusiveTax'?: Array<V1PaymentTax>;
    /**
    * All of the additive taxes associated with the payment.
    */
    'additiveTax'?: Array<V1PaymentTax>;
    /**
    * All of the tenders associated with the payment.
    */
    'tender'?: Array<V1Tender>;
    /**
    * All of the refunds applied to the payment. Note that the value of all refunds on a payment can exceed the value of all tenders if a merchant chooses to refund money to a tender after previously accepting returned goods as part of an exchange.
    */
    'refunds'?: Array<V1Refund>;
    /**
    * The items purchased in the payment.
    */
    'itemizations'?: Array<V1PaymentItemization>;
    /**
    * The total of all surcharges applied to the payment.
    */
    'surchargeMoney'?: V1Money;
    /**
    * A list of all surcharges associated with the payment.
    */
    'surcharges'?: Array<V1PaymentSurcharge>;
    /**
    * Indicates whether or not the payment is only partially paid for. If true, this payment will have the tenders collected so far, but the itemizations will be empty until the payment is completed.
    */
    'isPartial'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "string"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "Device"
        },
        {
            "name": "paymentUrl",
            "baseName": "payment_url",
            "type": "string"
        },
        {
            "name": "receiptUrl",
            "baseName": "receipt_url",
            "type": "string"
        },
        {
            "name": "inclusiveTaxMoney",
            "baseName": "inclusive_tax_money",
            "type": "V1Money"
        },
        {
            "name": "additiveTaxMoney",
            "baseName": "additive_tax_money",
            "type": "V1Money"
        },
        {
            "name": "taxMoney",
            "baseName": "tax_money",
            "type": "V1Money"
        },
        {
            "name": "tipMoney",
            "baseName": "tip_money",
            "type": "V1Money"
        },
        {
            "name": "discountMoney",
            "baseName": "discount_money",
            "type": "V1Money"
        },
        {
            "name": "totalCollectedMoney",
            "baseName": "total_collected_money",
            "type": "V1Money"
        },
        {
            "name": "processingFeeMoney",
            "baseName": "processing_fee_money",
            "type": "V1Money"
        },
        {
            "name": "netTotalMoney",
            "baseName": "net_total_money",
            "type": "V1Money"
        },
        {
            "name": "refundedMoney",
            "baseName": "refunded_money",
            "type": "V1Money"
        },
        {
            "name": "swedishRoundingMoney",
            "baseName": "swedish_rounding_money",
            "type": "V1Money"
        },
        {
            "name": "grossSalesMoney",
            "baseName": "gross_sales_money",
            "type": "V1Money"
        },
        {
            "name": "netSalesMoney",
            "baseName": "net_sales_money",
            "type": "V1Money"
        },
        {
            "name": "inclusiveTax",
            "baseName": "inclusive_tax",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "additiveTax",
            "baseName": "additive_tax",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "tender",
            "baseName": "tender",
            "type": "Array<V1Tender>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<V1Refund>"
        },
        {
            "name": "itemizations",
            "baseName": "itemizations",
            "type": "Array<V1PaymentItemization>"
        },
        {
            "name": "surchargeMoney",
            "baseName": "surcharge_money",
            "type": "V1Money"
        },
        {
            "name": "surcharges",
            "baseName": "surcharges",
            "type": "Array<V1PaymentSurcharge>"
        },
        {
            "name": "isPartial",
            "baseName": "is_partial",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V1Payment.attributeTypeMap;
    }
}

/**
* V1PaymentDiscount
*/
export class V1PaymentDiscount {
    /**
    * The discount's name.
    */
    'name'?: string;
    /**
    * The amount of money that this discount adds to the payment (note that this value is always negative or zero).
    */
    'appliedMoney'?: V1Money;
    /**
    * The ID of the applied discount, if available. Discounts applied in older versions of Square Register might not have an ID.
    */
    'discountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "V1Money"
        },
        {
            "name": "discountId",
            "baseName": "discount_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentDiscount.attributeTypeMap;
    }
}

/**
* V1PaymentItemDetail
*/
export class V1PaymentItemDetail {
    /**
    * The name of the item's merchant-defined category, if any.
    */
    'categoryName'?: string;
    /**
    *  The item's merchant-defined SKU, if any.
    */
    'sku'?: string;
    /**
    * The unique ID of the item purchased, if any.
    */
    'itemId'?: string;
    /**
    * The unique ID of the item variation purchased, if any.
    */
    'itemVariationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "itemVariationId",
            "baseName": "item_variation_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentItemDetail.attributeTypeMap;
    }
}

/**
* Payment include an` itemizations` field that lists the items purchased, along with associated fees, modifiers, and discounts. Each itemization has an `itemization_type` field that indicates which of the following the itemization represents:  <ul> <li>An item variation from the merchant's item library</li> <li>A custom monetary amount</li> <li> An action performed on a Square gift card, such as activating or reloading it. </li> </ul>  *Note**: itemization information included in a `Payment` object reflects details collected **at the time of the payment**. Details such as the name or price of items might have changed since the payment was processed.
*/
export class V1PaymentItemization {
    /**
    * The item's name.
    */
    'name'?: string;
    /**
    * The quantity of the item purchased. This can be a decimal value.
    */
    'quantity'?: number;
    /**
    * The type of purchase that the itemization represents, such as an ITEM or CUSTOM_AMOUNT See [V1PaymentItemizationItemizationType](#type-v1paymentitemizationitemizationtype) for possible values
    */
    'itemizationType'?: string;
    /**
    * Details of the item, including its unique identifier and the identifier of the item variation purchased.
    */
    'itemDetail'?: V1PaymentItemDetail;
    /**
    * Notes entered by the merchant about the item at the time of payment, if any.
    */
    'notes'?: string;
    /**
    * The name of the item variation purchased, if any.
    */
    'itemVariationName'?: string;
    /**
    * The total cost of the item, including all taxes and discounts.
    */
    'totalMoney'?: V1Money;
    /**
    * The cost of a single unit of this item.
    */
    'singleQuantityMoney'?: V1Money;
    /**
    * The total cost of the itemization and its modifiers, not including taxes or discounts.
    */
    'grossSalesMoney'?: V1Money;
    /**
    * The total of all discounts applied to the itemization. This value is always negative or zero.
    */
    'discountMoney'?: V1Money;
    /**
    * The sum of gross_sales_money and discount_money.
    */
    'netSalesMoney'?: V1Money;
    /**
    * All taxes applied to this itemization.
    */
    'taxes'?: Array<V1PaymentTax>;
    /**
    * All discounts applied to this itemization.
    */
    'discounts'?: Array<V1PaymentDiscount>;
    /**
    * All modifier options applied to this itemization.
    */
    'modifiers'?: Array<V1PaymentModifier>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "itemizationType",
            "baseName": "itemization_type",
            "type": "string"
        },
        {
            "name": "itemDetail",
            "baseName": "item_detail",
            "type": "V1PaymentItemDetail"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "itemVariationName",
            "baseName": "item_variation_name",
            "type": "string"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "V1Money"
        },
        {
            "name": "singleQuantityMoney",
            "baseName": "single_quantity_money",
            "type": "V1Money"
        },
        {
            "name": "grossSalesMoney",
            "baseName": "gross_sales_money",
            "type": "V1Money"
        },
        {
            "name": "discountMoney",
            "baseName": "discount_money",
            "type": "V1Money"
        },
        {
            "name": "netSalesMoney",
            "baseName": "net_sales_money",
            "type": "V1Money"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "discounts",
            "baseName": "discounts",
            "type": "Array<V1PaymentDiscount>"
        },
        {
            "name": "modifiers",
            "baseName": "modifiers",
            "type": "Array<V1PaymentModifier>"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentItemization.attributeTypeMap;
    }
}

/**
* 
*/
export class V1PaymentItemizationItemizationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1PaymentItemizationItemizationType.attributeTypeMap;
    }
}

/**
* V1PaymentModifier
*/
export class V1PaymentModifier {
    /**
    * The modifier option's name.
    */
    'name'?: string;
    /**
    * The amount of money that this modifier option adds to the payment.
    */
    'appliedMoney'?: V1Money;
    /**
    * TThe ID of the applied modifier option, if available. Modifier options applied in older versions of Square Register might not have an ID.
    */
    'modifierOptionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "V1Money"
        },
        {
            "name": "modifierOptionId",
            "baseName": "modifier_option_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentModifier.attributeTypeMap;
    }
}

/**
* V1PaymentSurcharge
*/
export class V1PaymentSurcharge {
    /**
    * The name of the surcharge.
    */
    'name'?: string;
    /**
    * The amount of money applied to the order as a result of the surcharge.
    */
    'appliedMoney'?: V1Money;
    /**
    * The amount of the surcharge as a percentage. The percentage is provided as a string representing the decimal equivalent of the percentage. For example, \"0.7\" corresponds to a 7% surcharge. Exactly one of rate or amount_money should be set.
    */
    'rate'?: string;
    /**
    * The amount of the surcharge as a Money object. Exactly one of rate or amount_money should be set.
    */
    'amountMoney'?: V1Money;
    /**
    * Indicates the source of the surcharge. For example, if it was applied as an automatic gratuity for a large group. See [V1PaymentSurchargeType](#type-v1paymentsurchargetype) for possible values
    */
    'type'?: string;
    /**
    * Indicates whether the surcharge is taxable.
    */
    'taxable'?: boolean;
    /**
    * The list of taxes that should be applied to the surcharge.
    */
    'taxes'?: Array<V1PaymentTax>;
    /**
    * A Square-issued unique identifier associated with the surcharge.
    */
    'surchargeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "V1Money"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "V1Money"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "surchargeId",
            "baseName": "surcharge_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentSurcharge.attributeTypeMap;
    }
}

/**
* 
*/
export class V1PaymentSurchargeType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1PaymentSurchargeType.attributeTypeMap;
    }
}

/**
* V1PaymentTax
*/
export class V1PaymentTax {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;
    /**
    * The merchant-defined name of the tax.
    */
    'name'?: string;
    /**
    * The amount of money that this tax adds to the payment.
    */
    'appliedMoney'?: V1Money;
    /**
    * The rate of the tax, as a string representation of a decimal number. A value of 0.07 corresponds to a rate of 7%.
    */
    'rate'?: string;
    /**
    * Whether the tax is an ADDITIVE tax or an INCLUSIVE tax. See [V1PaymentTaxInclusionType](#type-v1paymenttaxinclusiontype) for possible values
    */
    'inclusionType'?: string;
    /**
    * The ID of the tax, if available. Taxes applied in older versions of Square Register might not have an ID.
    */
    'feeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "appliedMoney",
            "baseName": "applied_money",
            "type": "V1Money"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "inclusionType",
            "baseName": "inclusion_type",
            "type": "string"
        },
        {
            "name": "feeId",
            "baseName": "fee_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PaymentTax.attributeTypeMap;
    }
}

/**
* 
*/
export class V1PaymentTaxInclusionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1PaymentTaxInclusionType.attributeTypeMap;
    }
}

/**
* Represents a phone number.
*/
export class V1PhoneNumber {
    /**
    * The phone number's international calling code. For US phone numbers, this value is +1.
    */
    'callingCode': string;
    /**
    * The phone number.
    */
    'number': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "callingCode",
            "baseName": "calling_code",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1PhoneNumber.attributeTypeMap;
    }
}

/**
* V1Refund
*/
export class V1Refund {
    /**
    * The type of refund See [V1RefundType](#type-v1refundtype) for possible values
    */
    'type'?: string;
    /**
    * The merchant-specified reason for the refund.
    */
    'reason'?: string;
    /**
    * The amount of money refunded. This amount is always negative.
    */
    'refundedMoney'?: V1Money;
    /**
    * The amount of processing fee money refunded. This amount is always positive.
    */
    'refundedProcessingFeeMoney'?: V1Money;
    /**
    * The total amount of tax money refunded. This amount is always negative.
    */
    'refundedTaxMoney'?: V1Money;
    /**
    * The amount of additive tax money refunded. This amount is always negative.
    */
    'refundedAdditiveTaxMoney'?: V1Money;
    /**
    * All of the additive taxes associated with the refund.
    */
    'refundedAdditiveTax'?: Array<V1PaymentTax>;
    /**
    * The amount of inclusive tax money refunded. This amount is always negative.
    */
    'refundedInclusiveTaxMoney'?: V1Money;
    /**
    * All of the inclusive taxes associated with the refund.
    */
    'refundedInclusiveTax'?: Array<V1PaymentTax>;
    /**
    * The amount of tip money refunded. This amount is always negative.
    */
    'refundedTipMoney'?: V1Money;
    /**
    * The amount of discount money refunded. This amount is always positive.
    */
    'refundedDiscountMoney'?: V1Money;
    /**
    * The amount of surcharge money refunded. This amount is always negative.
    */
    'refundedSurchargeMoney'?: V1Money;
    /**
    * A list of all surcharges associated with the refund.
    */
    'refundedSurcharges'?: Array<V1PaymentSurcharge>;
    /**
    * The time when the merchant initiated the refund for Square to process, in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * The time when Square processed the refund on behalf of the merchant, in ISO 8601 format.
    */
    'processedAt'?: string;
    /**
    * A Square-issued ID associated with the refund. For single-tender refunds, payment_id is the ID of the original payment ID. For split-tender refunds, payment_id is the ID of the original tender. For exchange-based refunds (is_exchange == true), payment_id is the ID of the original payment ID even if the payment includes other tenders.
    */
    'paymentId'?: string;
    /**
    * 
    */
    'merchantId'?: string;
    /**
    * Indicates whether or not the refund is associated with an exchange. If is_exchange is true, the refund reflects the value of goods returned in the exchange not the total money refunded.
    */
    'isExchange'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "refundedMoney",
            "baseName": "refunded_money",
            "type": "V1Money"
        },
        {
            "name": "refundedProcessingFeeMoney",
            "baseName": "refunded_processing_fee_money",
            "type": "V1Money"
        },
        {
            "name": "refundedTaxMoney",
            "baseName": "refunded_tax_money",
            "type": "V1Money"
        },
        {
            "name": "refundedAdditiveTaxMoney",
            "baseName": "refunded_additive_tax_money",
            "type": "V1Money"
        },
        {
            "name": "refundedAdditiveTax",
            "baseName": "refunded_additive_tax",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "refundedInclusiveTaxMoney",
            "baseName": "refunded_inclusive_tax_money",
            "type": "V1Money"
        },
        {
            "name": "refundedInclusiveTax",
            "baseName": "refunded_inclusive_tax",
            "type": "Array<V1PaymentTax>"
        },
        {
            "name": "refundedTipMoney",
            "baseName": "refunded_tip_money",
            "type": "V1Money"
        },
        {
            "name": "refundedDiscountMoney",
            "baseName": "refunded_discount_money",
            "type": "V1Money"
        },
        {
            "name": "refundedSurchargeMoney",
            "baseName": "refunded_surcharge_money",
            "type": "V1Money"
        },
        {
            "name": "refundedSurcharges",
            "baseName": "refunded_surcharges",
            "type": "Array<V1PaymentSurcharge>"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "processedAt",
            "baseName": "processed_at",
            "type": "string"
        },
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "isExchange",
            "baseName": "is_exchange",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V1Refund.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RefundType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RefundType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RemoveFeeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RemoveFeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RemoveModifierListRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RemoveModifierListRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveBankAccountRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveBankAccountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveBusinessRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveBusinessRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveCashDrawerShiftRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveCashDrawerShiftRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveEmployeeRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveEmployeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveEmployeeRoleRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveEmployeeRoleRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveItemRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveItemRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveModifierListRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveModifierListRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveOrderRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveOrderRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrievePaymentRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrievePaymentRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveSettlementRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveSettlementRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1RetrieveTimecardRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1RetrieveTimecardRequest.attributeTypeMap;
    }
}

/**
* V1Settlement
*/
export class V1Settlement {
    /**
    * The settlement's unique identifier.
    */
    'id'?: string;
    /**
    * The settlement's current status. See [V1SettlementStatus](#type-v1settlementstatus) for possible values
    */
    'status'?: string;
    /**
    * The amount of money involved in the settlement. A positive amount indicates a deposit, and a negative amount indicates a withdrawal. This amount is never zero.
    */
    'totalMoney'?: V1Money;
    /**
    * The time when the settlement was submitted for deposit or withdrawal, in ISO 8601 format.
    */
    'initiatedAt'?: string;
    /**
    * The Square-issued unique identifier for the bank account associated with the settlement.
    */
    'bankAccountId'?: string;
    /**
    * The entries included in this settlement.
    */
    'entries'?: Array<V1SettlementEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "V1Money"
        },
        {
            "name": "initiatedAt",
            "baseName": "initiated_at",
            "type": "string"
        },
        {
            "name": "bankAccountId",
            "baseName": "bank_account_id",
            "type": "string"
        },
        {
            "name": "entries",
            "baseName": "entries",
            "type": "Array<V1SettlementEntry>"
        }    ];

    static getAttributeTypeMap() {
        return V1Settlement.attributeTypeMap;
    }
}

/**
* V1SettlementEntry
*/
export class V1SettlementEntry {
    /**
    * The settlement's unique identifier.
    */
    'paymentId'?: string;
    /**
    * The settlement's current status. See [V1SettlementEntryType](#type-v1settlemententrytype) for possible values
    */
    'type'?: string;
    /**
    * The total amount of money this entry contributes to the total settlement amount.
    */
    'amountMoney'?: V1Money;
    /**
    * The amount of all Square fees associated with this settlement entry. This value is always negative or zero.
    */
    'feeMoney'?: V1Money;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentId",
            "baseName": "payment_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amountMoney",
            "baseName": "amount_money",
            "type": "V1Money"
        },
        {
            "name": "feeMoney",
            "baseName": "fee_money",
            "type": "V1Money"
        }    ];

    static getAttributeTypeMap() {
        return V1SettlementEntry.attributeTypeMap;
    }
}

/**
* 
*/
export class V1SettlementEntryType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1SettlementEntryType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1SettlementStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1SettlementStatus.attributeTypeMap;
    }
}

/**
* A tender represents a discrete monetary exchange. Square represents this exchange as a money object with a specific currency and amount, where the amount is given in the smallest denomination of the given currency.  Square POS can accept more than one form of tender for a single payment (such as by splitting a bill between a credit card and a gift card). The `tender` field of the Payment object lists all forms of tender used for the payment.  Split tender payments behave slightly differently from single tender payments:  The receipt_url for a split tender corresponds only to the first tender listed in the tender field. To get the receipt URLs for the remaining tenders, use the receipt_url fields of the corresponding Tender objects.  *A note on gift cards**: when a customer purchases a Square gift card from a merchant, the merchant receives the full amount of the gift card in the associated payment.  When that gift card is used as a tender, the balance of the gift card is reduced and the merchant receives no funds. A `Tender` object with a type of `SQUARE_GIFT_CARD` indicates a gift card was used for some or all of the associated payment.
*/
export class V1Tender {
    /**
    * The tender's unique ID.
    */
    'id'?: string;
    /**
    * The type of tender. See [V1TenderType](#type-v1tendertype) for possible values
    */
    'type'?: string;
    /**
    * A human-readable description of the tender.
    */
    'name'?: string;
    /**
    * The ID of the employee that processed the tender.
    */
    'employeeId'?: string;
    /**
    * The URL of the receipt for the tender.
    */
    'receiptUrl'?: string;
    /**
    * The brand of credit card provided. See [V1TenderCardBrand](#type-v1tendercardbrand) for possible values
    */
    'cardBrand'?: string;
    /**
    * The last four digits of the provided credit card's account number.
    */
    'panSuffix'?: string;
    /**
    * The tender's unique ID. See [V1TenderEntryMethod](#type-v1tenderentrymethod) for possible values
    */
    'entryMethod'?: string;
    /**
    * Notes entered by the merchant about the tender at the time of payment, if any. Typically only present for tender with the type: OTHER.
    */
    'paymentNote'?: string;
    /**
    * The total amount of money provided in this form of tender.
    */
    'totalMoney'?: V1Money;
    /**
    * The amount of total_money applied to the payment.
    */
    'tenderedMoney'?: V1Money;
    /**
    * The time when the tender was created, in ISO 8601 format.
    */
    'tenderedAt'?: string;
    /**
    * The time when the tender was settled, in ISO 8601 format.
    */
    'settledAt'?: string;
    /**
    * The amount of total_money returned to the buyer as change.
    */
    'changeBackMoney'?: V1Money;
    /**
    * The total of all refunds applied to this tender. This amount is always negative or zero.
    */
    'refundedMoney'?: V1Money;
    /**
    * Indicates whether or not the tender is associated with an exchange. If is_exchange is true, the tender represents the value of goods returned in an exchange not the actual money paid. The exchange value reduces the tender amounts needed to pay for items purchased in the exchange.
    */
    'isExchange'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "receiptUrl",
            "baseName": "receipt_url",
            "type": "string"
        },
        {
            "name": "cardBrand",
            "baseName": "card_brand",
            "type": "string"
        },
        {
            "name": "panSuffix",
            "baseName": "pan_suffix",
            "type": "string"
        },
        {
            "name": "entryMethod",
            "baseName": "entry_method",
            "type": "string"
        },
        {
            "name": "paymentNote",
            "baseName": "payment_note",
            "type": "string"
        },
        {
            "name": "totalMoney",
            "baseName": "total_money",
            "type": "V1Money"
        },
        {
            "name": "tenderedMoney",
            "baseName": "tendered_money",
            "type": "V1Money"
        },
        {
            "name": "tenderedAt",
            "baseName": "tendered_at",
            "type": "string"
        },
        {
            "name": "settledAt",
            "baseName": "settled_at",
            "type": "string"
        },
        {
            "name": "changeBackMoney",
            "baseName": "change_back_money",
            "type": "V1Money"
        },
        {
            "name": "refundedMoney",
            "baseName": "refunded_money",
            "type": "V1Money"
        },
        {
            "name": "isExchange",
            "baseName": "is_exchange",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V1Tender.attributeTypeMap;
    }
}

/**
* The brand of a credit card.
*/
export class V1TenderCardBrand {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1TenderCardBrand.attributeTypeMap;
    }
}

/**
* 
*/
export class V1TenderEntryMethod {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1TenderEntryMethod.attributeTypeMap;
    }
}

/**
* 
*/
export class V1TenderType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1TenderType.attributeTypeMap;
    }
}

/**
* Represents a timecard for an employee.
*/
export class V1Timecard {
    /**
    * The timecard's unique ID.
    */
    'id'?: string;
    /**
    * The ID of the employee the timecard is associated with.
    */
    'employeeId': string;
    /**
    * If true, the timecard was deleted by the merchant, and it is no longer valid.
    */
    'deleted'?: boolean;
    /**
    * The clock-in time for the timecard, in ISO 8601 format.
    */
    'clockinTime'?: string;
    /**
    * The clock-out time for the timecard, in ISO 8601 format. Provide this value only if importing timecard information from another system.
    */
    'clockoutTime'?: string;
    /**
    * The ID of the location the employee clocked in from. We strongly reccomend providing a clockin_location_id. Square uses the clockin_location_id to determine a timecardâ€™s timezone and overtime rules.
    */
    'clockinLocationId'?: string;
    /**
    * The ID of the location the employee clocked out from. Provide this value only if importing timecard information from another system.
    */
    'clockoutLocationId'?: string;
    /**
    * The time when the timecard was created, in ISO 8601 format.
    */
    'createdAt'?: string;
    /**
    * The time when the timecard was most recently updated, in ISO 8601 format.
    */
    'updatedAt'?: string;
    /**
    * The total number of regular (non-overtime) seconds worked in the timecard.
    */
    'regularSecondsWorked'?: number;
    /**
    * The total number of overtime seconds worked in the timecard.
    */
    'overtimeSecondsWorked'?: number;
    /**
    * The total number of doubletime seconds worked in the timecard.
    */
    'doubletimeSecondsWorked'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "employeeId",
            "baseName": "employee_id",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "clockinTime",
            "baseName": "clockin_time",
            "type": "string"
        },
        {
            "name": "clockoutTime",
            "baseName": "clockout_time",
            "type": "string"
        },
        {
            "name": "clockinLocationId",
            "baseName": "clockin_location_id",
            "type": "string"
        },
        {
            "name": "clockoutLocationId",
            "baseName": "clockout_location_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "regularSecondsWorked",
            "baseName": "regular_seconds_worked",
            "type": "number"
        },
        {
            "name": "overtimeSecondsWorked",
            "baseName": "overtime_seconds_worked",
            "type": "number"
        },
        {
            "name": "doubletimeSecondsWorked",
            "baseName": "doubletime_seconds_worked",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V1Timecard.attributeTypeMap;
    }
}

/**
* V1TimecardEvent
*/
export class V1TimecardEvent {
    /**
    * The event's unique ID.
    */
    'id'?: string;
    /**
    * The ID of the timecard to list events for. See [V1TimecardEventEventType](#type-v1timecardeventeventtype) for possible values
    */
    'eventType'?: string;
    /**
    * The time the employee clocked in, in ISO 8601 format.
    */
    'clockinTime'?: string;
    /**
    * The time the employee clocked out, in ISO 8601 format.
    */
    'clockoutTime'?: string;
    /**
    * The time when the event was created, in ISO 8601 format.
    */
    'createdAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "eventType",
            "baseName": "event_type",
            "type": "string"
        },
        {
            "name": "clockinTime",
            "baseName": "clockin_time",
            "type": "string"
        },
        {
            "name": "clockoutTime",
            "baseName": "clockout_time",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1TimecardEvent.attributeTypeMap;
    }
}

/**
* Actions that resulted in a change to a timecard. All timecard events created with the Connect API have an event type that begins with `API`.
*/
export class V1TimecardEventEventType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1TimecardEventEventType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateCategoryRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Category;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Category"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateCategoryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateDiscountRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Discount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Discount"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateDiscountRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateEmployeeRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Employee;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Employee"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateEmployeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateEmployeeRoleRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1EmployeeRole;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1EmployeeRole"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateEmployeeRoleRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateFeeRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Fee;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Fee"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateFeeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateItemRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Item;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Item"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateItemRequest.attributeTypeMap;
    }
}

/**
* V1UpdateModifierListRequest
*/
export class V1UpdateModifierListRequest {
    /**
    * The modifier list's name.
    */
    'name'?: string;
    /**
    * Indicates whether multiple options from the modifier list can be applied to a single item. See [V1UpdateModifierListRequestSelectionType](#type-v1updatemodifierlistrequestselectiontype) for possible values
    */
    'selectionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "selectionType",
            "baseName": "selection_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateModifierListRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateModifierListRequestSelectionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1UpdateModifierListRequestSelectionType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateModifierOptionRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1ModifierOption;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1ModifierOption"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateModifierOptionRequest.attributeTypeMap;
    }
}

/**
* V1UpdateOrderRequest
*/
export class V1UpdateOrderRequest {
    /**
    * The action to perform on the order (COMPLETE, CANCEL, or REFUND). See [V1UpdateOrderRequestAction](#type-v1updateorderrequestaction) for possible values
    */
    'action': string;
    /**
    * The tracking number of the shipment associated with the order. Only valid if action is COMPLETE.
    */
    'shippedTrackingNumber'?: string;
    /**
    * A merchant-specified note about the completion of the order. Only valid if action is COMPLETE.
    */
    'completedNote'?: string;
    /**
    * A merchant-specified note about the refunding of the order. Only valid if action is REFUND.
    */
    'refundedNote'?: string;
    /**
    * A merchant-specified note about the canceling of the order. Only valid if action is CANCEL.
    */
    'canceledNote'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "shippedTrackingNumber",
            "baseName": "shipped_tracking_number",
            "type": "string"
        },
        {
            "name": "completedNote",
            "baseName": "completed_note",
            "type": "string"
        },
        {
            "name": "refundedNote",
            "baseName": "refunded_note",
            "type": "string"
        },
        {
            "name": "canceledNote",
            "baseName": "canceled_note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateOrderRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateOrderRequestAction {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1UpdateOrderRequestAction.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdatePageCellRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1PageCell;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1PageCell"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdatePageCellRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdatePageRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Page;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Page"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdatePageRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateTimecardRequest {
    /**
    * An object containing the fields to POST for the request. See the corresponding object definition for field details.
    */
    'body': V1Timecard;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Timecard"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateTimecardRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class V1UpdateVariationRequest {
    /**
    * An object containing the fields to POST for the request.  See the corresponding object definition for field details.
    */
    'body': V1Variation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "V1Variation"
        }    ];

    static getAttributeTypeMap() {
        return V1UpdateVariationRequest.attributeTypeMap;
    }
}

/**
* V1Variation
*/
export class V1Variation {
    /**
    * The item variation's unique ID.
    */
    'id'?: string;
    /**
    * The item variation's name.
    */
    'name'?: string;
    /**
    * The ID of the variation's associated item.
    */
    'itemId'?: string;
    /**
    * Indicates the variation's list position when displayed in Square Point of Sale and the merchant dashboard. If more than one variation for the same item has the same ordinal value, those variations are displayed in alphabetical order
    */
    'ordinal'?: number;
    /**
    * Indicates whether the item variation's price is fixed or determined at the time of sale. See [V1VariationPricingType](#type-v1variationpricingtype) for possible values
    */
    'pricingType'?: string;
    /**
    * The item variation's price, if any.
    */
    'priceMoney'?: V1Money;
    /**
    * The item variation's SKU, if any.
    */
    'sku'?: string;
    /**
    * If true, inventory tracking is active for the variation.
    */
    'trackInventory'?: boolean;
    /**
    * Indicates whether the item variation displays an alert when its inventory quantity is less than or equal to its inventory_alert_threshold. See [V1VariationInventoryAlertType](#type-v1variationinventoryalerttype) for possible values
    */
    'inventoryAlertType'?: string;
    /**
    * If the inventory quantity for the variation is less than or equal to this value and inventory_alert_type is LOW_QUANTITY, the variation displays an alert in the merchant dashboard.
    */
    'inventoryAlertThreshold'?: number;
    /**
    * Arbitrary metadata associated with the variation. Cannot exceed 255 characters.
    */
    'userData'?: string;
    /**
    * The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
    */
    'v2Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "ordinal",
            "baseName": "ordinal",
            "type": "number"
        },
        {
            "name": "pricingType",
            "baseName": "pricing_type",
            "type": "string"
        },
        {
            "name": "priceMoney",
            "baseName": "price_money",
            "type": "V1Money"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "trackInventory",
            "baseName": "track_inventory",
            "type": "boolean"
        },
        {
            "name": "inventoryAlertType",
            "baseName": "inventory_alert_type",
            "type": "string"
        },
        {
            "name": "inventoryAlertThreshold",
            "baseName": "inventory_alert_threshold",
            "type": "number"
        },
        {
            "name": "userData",
            "baseName": "user_data",
            "type": "string"
        },
        {
            "name": "v2Id",
            "baseName": "v2_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1Variation.attributeTypeMap;
    }
}

/**
* 
*/
export class V1VariationInventoryAlertType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1VariationInventoryAlertType.attributeTypeMap;
    }
}

/**
* 
*/
export class V1VariationPricingType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V1VariationPricingType.attributeTypeMap;
    }
}

/**
* 
*/
export class VoidTransactionRequest {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return VoidTransactionRequest.attributeTypeMap;
    }
}

/**
* Defines the fields that are included in the response body of a request to the [VoidTransaction](#endpoint-voidtransaction) endpoint.
*/
export class VoidTransactionResponse {
    /**
    * Any errors that occurred during the request.
    */
    'errors'?: Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return VoidTransactionResponse.attributeTypeMap;
    }
}

/**
* An object representing a team member's wage information.
*/
export class WageSetting {
    /**
    * The unique ID of the `TeamMember` whom this wage setting describes.
    */
    'teamMemberId'?: string;
    /**
    * <b>Required</b> The ordered list of jobs that the team member is assigned to. The first job assignment is considered the team member's \"Primary Job\". <br> <b>Min Length 1    Max Length 12</b>
    */
    'jobAssignments'?: Array<JobAssignment>;
    /**
    * Whether the team member is exempt from the overtime rules of the seller country.
    */
    'isOvertimeExempt'?: boolean;
    /**
    * Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If not provided, Square executes a blind write, potentially overwriting data from another write. Read about [optimistic concurrency](https://developer.squareup.com/docs/docs/working-with-apis/optimistic-concurrency) in Square APIs for more information.
    */
    'version'?: number;
    /**
    * The timestamp in RFC 3339 format describing when the wage setting object was created. Ex: \"2018-10-04T04:00:00-07:00\" or \"2019-02-05T12:00:00Z\"
    */
    'createdAt'?: string;
    /**
    * The timestamp in RFC 3339 format describing when the wage setting object was last updated. Ex: \"2018-10-04T04:00:00-07:00\" or \"2019-02-05T12:00:00Z\"
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberId",
            "baseName": "team_member_id",
            "type": "string"
        },
        {
            "name": "jobAssignments",
            "baseName": "job_assignments",
            "type": "Array<JobAssignment>"
        },
        {
            "name": "isOvertimeExempt",
            "baseName": "is_overtime_exempt",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WageSetting.attributeTypeMap;
    }
}

/**
* The days of the week.
*/
export class Weekday {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Weekday.attributeTypeMap;
    }
}

/**
* Sets the Day of the week and hour of the day that a business starts a work week. Used for the calculation of overtime pay.
*/
export class WorkweekConfig {
    /**
    * UUID for this object
    */
    'id'?: string;
    /**
    * The day of the week on which a business week cuts over for compensation purposes. See [Weekday](#type-weekday) for possible values
    */
    'startOfWeek': string;
    /**
    * The local time at which a business week cuts over. Represented as a string in `HH:MM` format (`HH:MM:SS` is also accepted, but seconds are truncated).
    */
    'startOfDayLocalTime': string;
    /**
    * Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If not provided, Square executes a blind write; potentially overwriting data from another write.
    */
    'version'?: number;
    /**
    * A read-only timestamp in RFC 3339 format; presented in UTC
    */
    'createdAt'?: string;
    /**
    * A read-only timestamp in RFC 3339 format; presented in UTC
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "startOfWeek",
            "baseName": "start_of_week",
            "type": "string"
        },
        {
            "name": "startOfDayLocalTime",
            "baseName": "start_of_day_local_time",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WorkweekConfig.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "AcceptDisputeRequest": AcceptDisputeRequest,
    "AcceptDisputeResponse": AcceptDisputeResponse,
    "AccumulateLoyaltyPointsRequest": AccumulateLoyaltyPointsRequest,
    "AccumulateLoyaltyPointsResponse": AccumulateLoyaltyPointsResponse,
    "ActionCancelReason": ActionCancelReason,
    "AddGroupToCustomerRequest": AddGroupToCustomerRequest,
    "AddGroupToCustomerResponse": AddGroupToCustomerResponse,
    "AdditionalRecipient": AdditionalRecipient,
    "Address": Address,
    "AdjustLoyaltyPointsRequest": AdjustLoyaltyPointsRequest,
    "AdjustLoyaltyPointsResponse": AdjustLoyaltyPointsResponse,
    "BalancePaymentDetails": BalancePaymentDetails,
    "BankAccount": BankAccount,
    "BankAccountStatus": BankAccountStatus,
    "BankAccountType": BankAccountType,
    "BatchChangeInventoryRequest": BatchChangeInventoryRequest,
    "BatchChangeInventoryResponse": BatchChangeInventoryResponse,
    "BatchDeleteCatalogObjectsRequest": BatchDeleteCatalogObjectsRequest,
    "BatchDeleteCatalogObjectsResponse": BatchDeleteCatalogObjectsResponse,
    "BatchRetrieveCatalogObjectsRequest": BatchRetrieveCatalogObjectsRequest,
    "BatchRetrieveCatalogObjectsResponse": BatchRetrieveCatalogObjectsResponse,
    "BatchRetrieveInventoryChangesRequest": BatchRetrieveInventoryChangesRequest,
    "BatchRetrieveInventoryChangesResponse": BatchRetrieveInventoryChangesResponse,
    "BatchRetrieveInventoryCountsRequest": BatchRetrieveInventoryCountsRequest,
    "BatchRetrieveInventoryCountsResponse": BatchRetrieveInventoryCountsResponse,
    "BatchRetrieveOrdersRequest": BatchRetrieveOrdersRequest,
    "BatchRetrieveOrdersResponse": BatchRetrieveOrdersResponse,
    "BatchUpsertCatalogObjectsRequest": BatchUpsertCatalogObjectsRequest,
    "BatchUpsertCatalogObjectsResponse": BatchUpsertCatalogObjectsResponse,
    "BreakType": BreakType,
    "BulkCreateTeamMembersRequest": BulkCreateTeamMembersRequest,
    "BulkCreateTeamMembersResponse": BulkCreateTeamMembersResponse,
    "BulkUpdateTeamMembersRequest": BulkUpdateTeamMembersRequest,
    "BulkUpdateTeamMembersResponse": BulkUpdateTeamMembersResponse,
    "BusinessHours": BusinessHours,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "CalculateLoyaltyPointsRequest": CalculateLoyaltyPointsRequest,
    "CalculateLoyaltyPointsResponse": CalculateLoyaltyPointsResponse,
    "CalculateOrderRequest": CalculateOrderRequest,
    "CalculateOrderResponse": CalculateOrderResponse,
    "CancelInvoiceRequest": CancelInvoiceRequest,
    "CancelInvoiceResponse": CancelInvoiceResponse,
    "CancelPaymentByIdempotencyKeyRequest": CancelPaymentByIdempotencyKeyRequest,
    "CancelPaymentByIdempotencyKeyResponse": CancelPaymentByIdempotencyKeyResponse,
    "CancelPaymentRequest": CancelPaymentRequest,
    "CancelPaymentResponse": CancelPaymentResponse,
    "CancelSubscriptionRequest": CancelSubscriptionRequest,
    "CancelSubscriptionResponse": CancelSubscriptionResponse,
    "CancelTerminalCheckoutRequest": CancelTerminalCheckoutRequest,
    "CancelTerminalCheckoutResponse": CancelTerminalCheckoutResponse,
    "CaptureTransactionRequest": CaptureTransactionRequest,
    "CaptureTransactionResponse": CaptureTransactionResponse,
    "Card": Card,
    "CardBrand": CardBrand,
    "CardPaymentDetails": CardPaymentDetails,
    "CardPrepaidType": CardPrepaidType,
    "CardSquareProduct": CardSquareProduct,
    "CardType": CardType,
    "CashDrawerDevice": CashDrawerDevice,
    "CashDrawerEventType": CashDrawerEventType,
    "CashDrawerShift": CashDrawerShift,
    "CashDrawerShiftEvent": CashDrawerShiftEvent,
    "CashDrawerShiftState": CashDrawerShiftState,
    "CashDrawerShiftSummary": CashDrawerShiftSummary,
    "CatalogCategory": CatalogCategory,
    "CatalogCustomAttributeDefinition": CatalogCustomAttributeDefinition,
    "CatalogCustomAttributeDefinitionAppVisibility": CatalogCustomAttributeDefinitionAppVisibility,
    "CatalogCustomAttributeDefinitionNumberConfig": CatalogCustomAttributeDefinitionNumberConfig,
    "CatalogCustomAttributeDefinitionSelectionConfig": CatalogCustomAttributeDefinitionSelectionConfig,
    "CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection": CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection,
    "CatalogCustomAttributeDefinitionSellerVisibility": CatalogCustomAttributeDefinitionSellerVisibility,
    "CatalogCustomAttributeDefinitionStringConfig": CatalogCustomAttributeDefinitionStringConfig,
    "CatalogCustomAttributeDefinitionType": CatalogCustomAttributeDefinitionType,
    "CatalogCustomAttributeValue": CatalogCustomAttributeValue,
    "CatalogDiscount": CatalogDiscount,
    "CatalogDiscountModifyTaxBasis": CatalogDiscountModifyTaxBasis,
    "CatalogDiscountType": CatalogDiscountType,
    "CatalogIdMapping": CatalogIdMapping,
    "CatalogImage": CatalogImage,
    "CatalogInfoRequest": CatalogInfoRequest,
    "CatalogInfoResponse": CatalogInfoResponse,
    "CatalogInfoResponseLimits": CatalogInfoResponseLimits,
    "CatalogItem": CatalogItem,
    "CatalogItemModifierListInfo": CatalogItemModifierListInfo,
    "CatalogItemOption": CatalogItemOption,
    "CatalogItemOptionForItem": CatalogItemOptionForItem,
    "CatalogItemOptionValue": CatalogItemOptionValue,
    "CatalogItemOptionValueForItemVariation": CatalogItemOptionValueForItemVariation,
    "CatalogItemProductType": CatalogItemProductType,
    "CatalogItemVariation": CatalogItemVariation,
    "CatalogMeasurementUnit": CatalogMeasurementUnit,
    "CatalogModifier": CatalogModifier,
    "CatalogModifierList": CatalogModifierList,
    "CatalogModifierListSelectionType": CatalogModifierListSelectionType,
    "CatalogModifierOverride": CatalogModifierOverride,
    "CatalogObject": CatalogObject,
    "CatalogObjectBatch": CatalogObjectBatch,
    "CatalogObjectType": CatalogObjectType,
    "CatalogPricingRule": CatalogPricingRule,
    "CatalogPricingType": CatalogPricingType,
    "CatalogProductSet": CatalogProductSet,
    "CatalogQuery": CatalogQuery,
    "CatalogQueryExact": CatalogQueryExact,
    "CatalogQueryItemVariationsForItemOptionValues": CatalogQueryItemVariationsForItemOptionValues,
    "CatalogQueryItemsForItemOptions": CatalogQueryItemsForItemOptions,
    "CatalogQueryItemsForModifierList": CatalogQueryItemsForModifierList,
    "CatalogQueryItemsForTax": CatalogQueryItemsForTax,
    "CatalogQueryPrefix": CatalogQueryPrefix,
    "CatalogQueryRange": CatalogQueryRange,
    "CatalogQuerySortedAttribute": CatalogQuerySortedAttribute,
    "CatalogQueryText": CatalogQueryText,
    "CatalogQuickAmount": CatalogQuickAmount,
    "CatalogQuickAmountType": CatalogQuickAmountType,
    "CatalogQuickAmountsSettings": CatalogQuickAmountsSettings,
    "CatalogQuickAmountsSettingsOption": CatalogQuickAmountsSettingsOption,
    "CatalogSubscriptionPlan": CatalogSubscriptionPlan,
    "CatalogTax": CatalogTax,
    "CatalogTimePeriod": CatalogTimePeriod,
    "CatalogV1Id": CatalogV1Id,
    "ChargeRequest": ChargeRequest,
    "ChargeRequestAdditionalRecipient": ChargeRequestAdditionalRecipient,
    "ChargeResponse": ChargeResponse,
    "Checkout": Checkout,
    "CompletePaymentRequest": CompletePaymentRequest,
    "CompletePaymentResponse": CompletePaymentResponse,
    "Coordinates": Coordinates,
    "Country": Country,
    "CreateBreakTypeRequest": CreateBreakTypeRequest,
    "CreateBreakTypeResponse": CreateBreakTypeResponse,
    "CreateCatalogImageRequest": CreateCatalogImageRequest,
    "CreateCatalogImageResponse": CreateCatalogImageResponse,
    "CreateCheckoutRequest": CreateCheckoutRequest,
    "CreateCheckoutResponse": CreateCheckoutResponse,
    "CreateCustomerCardRequest": CreateCustomerCardRequest,
    "CreateCustomerCardResponse": CreateCustomerCardResponse,
    "CreateCustomerGroupRequest": CreateCustomerGroupRequest,
    "CreateCustomerGroupResponse": CreateCustomerGroupResponse,
    "CreateCustomerRequest": CreateCustomerRequest,
    "CreateCustomerResponse": CreateCustomerResponse,
    "CreateDeviceCodeRequest": CreateDeviceCodeRequest,
    "CreateDeviceCodeResponse": CreateDeviceCodeResponse,
    "CreateDisputeEvidenceFileRequest": CreateDisputeEvidenceFileRequest,
    "CreateDisputeEvidenceFileResponse": CreateDisputeEvidenceFileResponse,
    "CreateDisputeEvidenceTextRequest": CreateDisputeEvidenceTextRequest,
    "CreateDisputeEvidenceTextResponse": CreateDisputeEvidenceTextResponse,
    "CreateInvoiceRequest": CreateInvoiceRequest,
    "CreateInvoiceResponse": CreateInvoiceResponse,
    "CreateLocationRequest": CreateLocationRequest,
    "CreateLocationResponse": CreateLocationResponse,
    "CreateLoyaltyAccountRequest": CreateLoyaltyAccountRequest,
    "CreateLoyaltyAccountResponse": CreateLoyaltyAccountResponse,
    "CreateLoyaltyRewardRequest": CreateLoyaltyRewardRequest,
    "CreateLoyaltyRewardResponse": CreateLoyaltyRewardResponse,
    "CreateMobileAuthorizationCodeRequest": CreateMobileAuthorizationCodeRequest,
    "CreateMobileAuthorizationCodeResponse": CreateMobileAuthorizationCodeResponse,
    "CreateOrderRequest": CreateOrderRequest,
    "CreateOrderResponse": CreateOrderResponse,
    "CreatePaymentRequest": CreatePaymentRequest,
    "CreatePaymentResponse": CreatePaymentResponse,
    "CreateRefundRequest": CreateRefundRequest,
    "CreateRefundResponse": CreateRefundResponse,
    "CreateShiftRequest": CreateShiftRequest,
    "CreateShiftResponse": CreateShiftResponse,
    "CreateSubscriptionRequest": CreateSubscriptionRequest,
    "CreateSubscriptionResponse": CreateSubscriptionResponse,
    "CreateTeamMemberRequest": CreateTeamMemberRequest,
    "CreateTeamMemberResponse": CreateTeamMemberResponse,
    "CreateTerminalCheckoutRequest": CreateTerminalCheckoutRequest,
    "CreateTerminalCheckoutResponse": CreateTerminalCheckoutResponse,
    "Currency": Currency,
    "CustomAttributeFilter": CustomAttributeFilter,
    "Customer": Customer,
    "CustomerCreationSource": CustomerCreationSource,
    "CustomerCreationSourceFilter": CustomerCreationSourceFilter,
    "CustomerFilter": CustomerFilter,
    "CustomerGroup": CustomerGroup,
    "CustomerGroupInfo": CustomerGroupInfo,
    "CustomerInclusionExclusion": CustomerInclusionExclusion,
    "CustomerPreferences": CustomerPreferences,
    "CustomerQuery": CustomerQuery,
    "CustomerSegment": CustomerSegment,
    "CustomerSort": CustomerSort,
    "CustomerSortField": CustomerSortField,
    "CustomerTextFilter": CustomerTextFilter,
    "DateRange": DateRange,
    "DayOfWeek": DayOfWeek,
    "DeleteBreakTypeRequest": DeleteBreakTypeRequest,
    "DeleteBreakTypeResponse": DeleteBreakTypeResponse,
    "DeleteCatalogObjectRequest": DeleteCatalogObjectRequest,
    "DeleteCatalogObjectResponse": DeleteCatalogObjectResponse,
    "DeleteCustomerCardRequest": DeleteCustomerCardRequest,
    "DeleteCustomerCardResponse": DeleteCustomerCardResponse,
    "DeleteCustomerGroupRequest": DeleteCustomerGroupRequest,
    "DeleteCustomerGroupResponse": DeleteCustomerGroupResponse,
    "DeleteCustomerRequest": DeleteCustomerRequest,
    "DeleteCustomerResponse": DeleteCustomerResponse,
    "DeleteInvoiceRequest": DeleteInvoiceRequest,
    "DeleteInvoiceResponse": DeleteInvoiceResponse,
    "DeleteLoyaltyRewardRequest": DeleteLoyaltyRewardRequest,
    "DeleteLoyaltyRewardResponse": DeleteLoyaltyRewardResponse,
    "DeleteShiftRequest": DeleteShiftRequest,
    "DeleteShiftResponse": DeleteShiftResponse,
    "Device": Device,
    "DeviceCheckoutOptions": DeviceCheckoutOptions,
    "DeviceCode": DeviceCode,
    "DeviceCodeStatus": DeviceCodeStatus,
    "DeviceDetails": DeviceDetails,
    "Dispute": Dispute,
    "DisputeEvidence": DisputeEvidence,
    "DisputeEvidenceFile": DisputeEvidenceFile,
    "DisputeEvidenceType": DisputeEvidenceType,
    "DisputeReason": DisputeReason,
    "DisputeState": DisputeState,
    "DisputedPayment": DisputedPayment,
    "EcomVisibility": EcomVisibility,
    "Employee": Employee,
    "EmployeeStatus": EmployeeStatus,
    "EmployeeWage": EmployeeWage,
    "ErrorCategory": ErrorCategory,
    "ErrorCode": ErrorCode,
    "ExcludeStrategy": ExcludeStrategy,
    "FilterValue": FilterValue,
    "GetBankAccountByV1IdRequest": GetBankAccountByV1IdRequest,
    "GetBankAccountByV1IdResponse": GetBankAccountByV1IdResponse,
    "GetBankAccountRequest": GetBankAccountRequest,
    "GetBankAccountResponse": GetBankAccountResponse,
    "GetBreakTypeRequest": GetBreakTypeRequest,
    "GetBreakTypeResponse": GetBreakTypeResponse,
    "GetDeviceCodeRequest": GetDeviceCodeRequest,
    "GetDeviceCodeResponse": GetDeviceCodeResponse,
    "GetEmployeeWageRequest": GetEmployeeWageRequest,
    "GetEmployeeWageResponse": GetEmployeeWageResponse,
    "GetInvoiceRequest": GetInvoiceRequest,
    "GetInvoiceResponse": GetInvoiceResponse,
    "GetPaymentRefundRequest": GetPaymentRefundRequest,
    "GetPaymentRefundResponse": GetPaymentRefundResponse,
    "GetPaymentRequest": GetPaymentRequest,
    "GetPaymentResponse": GetPaymentResponse,
    "GetShiftRequest": GetShiftRequest,
    "GetShiftResponse": GetShiftResponse,
    "GetTeamMemberWageRequest": GetTeamMemberWageRequest,
    "GetTeamMemberWageResponse": GetTeamMemberWageResponse,
    "GetTerminalCheckoutRequest": GetTerminalCheckoutRequest,
    "GetTerminalCheckoutResponse": GetTerminalCheckoutResponse,
    "InventoryAdjustment": InventoryAdjustment,
    "InventoryAlertType": InventoryAlertType,
    "InventoryChange": InventoryChange,
    "InventoryChangeType": InventoryChangeType,
    "InventoryCount": InventoryCount,
    "InventoryPhysicalCount": InventoryPhysicalCount,
    "InventoryState": InventoryState,
    "InventoryTransfer": InventoryTransfer,
    "Invoice": Invoice,
    "InvoiceFilter": InvoiceFilter,
    "InvoicePaymentReminder": InvoicePaymentReminder,
    "InvoicePaymentReminderStatus": InvoicePaymentReminderStatus,
    "InvoicePaymentRequest": InvoicePaymentRequest,
    "InvoiceQuery": InvoiceQuery,
    "InvoiceRecipient": InvoiceRecipient,
    "InvoiceRequestMethod": InvoiceRequestMethod,
    "InvoiceRequestType": InvoiceRequestType,
    "InvoiceSort": InvoiceSort,
    "InvoiceSortField": InvoiceSortField,
    "InvoiceStatus": InvoiceStatus,
    "ItemVariationLocationOverrides": ItemVariationLocationOverrides,
    "JobAssignment": JobAssignment,
    "JobAssignmentPayType": JobAssignmentPayType,
    "ListBankAccountsRequest": ListBankAccountsRequest,
    "ListBankAccountsResponse": ListBankAccountsResponse,
    "ListBreakTypesRequest": ListBreakTypesRequest,
    "ListBreakTypesResponse": ListBreakTypesResponse,
    "ListCashDrawerShiftEventsRequest": ListCashDrawerShiftEventsRequest,
    "ListCashDrawerShiftEventsResponse": ListCashDrawerShiftEventsResponse,
    "ListCashDrawerShiftsRequest": ListCashDrawerShiftsRequest,
    "ListCashDrawerShiftsResponse": ListCashDrawerShiftsResponse,
    "ListCatalogRequest": ListCatalogRequest,
    "ListCatalogResponse": ListCatalogResponse,
    "ListCustomerGroupsRequest": ListCustomerGroupsRequest,
    "ListCustomerGroupsResponse": ListCustomerGroupsResponse,
    "ListCustomerSegmentsRequest": ListCustomerSegmentsRequest,
    "ListCustomerSegmentsResponse": ListCustomerSegmentsResponse,
    "ListCustomersRequest": ListCustomersRequest,
    "ListCustomersResponse": ListCustomersResponse,
    "ListDeviceCodesRequest": ListDeviceCodesRequest,
    "ListDeviceCodesResponse": ListDeviceCodesResponse,
    "ListDisputeEvidenceRequest": ListDisputeEvidenceRequest,
    "ListDisputeEvidenceResponse": ListDisputeEvidenceResponse,
    "ListDisputesRequest": ListDisputesRequest,
    "ListDisputesResponse": ListDisputesResponse,
    "ListEmployeeWagesRequest": ListEmployeeWagesRequest,
    "ListEmployeeWagesResponse": ListEmployeeWagesResponse,
    "ListEmployeesRequest": ListEmployeesRequest,
    "ListEmployeesResponse": ListEmployeesResponse,
    "ListInvoicesRequest": ListInvoicesRequest,
    "ListInvoicesResponse": ListInvoicesResponse,
    "ListLocationsRequest": ListLocationsRequest,
    "ListLocationsResponse": ListLocationsResponse,
    "ListLoyaltyProgramsRequest": ListLoyaltyProgramsRequest,
    "ListLoyaltyProgramsResponse": ListLoyaltyProgramsResponse,
    "ListMerchantsRequest": ListMerchantsRequest,
    "ListMerchantsResponse": ListMerchantsResponse,
    "ListPaymentRefundsRequest": ListPaymentRefundsRequest,
    "ListPaymentRefundsResponse": ListPaymentRefundsResponse,
    "ListPaymentsRequest": ListPaymentsRequest,
    "ListPaymentsResponse": ListPaymentsResponse,
    "ListRefundsRequest": ListRefundsRequest,
    "ListRefundsResponse": ListRefundsResponse,
    "ListSubscriptionEventsRequest": ListSubscriptionEventsRequest,
    "ListSubscriptionEventsResponse": ListSubscriptionEventsResponse,
    "ListTeamMemberWagesRequest": ListTeamMemberWagesRequest,
    "ListTeamMemberWagesResponse": ListTeamMemberWagesResponse,
    "ListTransactionsRequest": ListTransactionsRequest,
    "ListTransactionsResponse": ListTransactionsResponse,
    "ListWorkweekConfigsRequest": ListWorkweekConfigsRequest,
    "ListWorkweekConfigsResponse": ListWorkweekConfigsResponse,
    "Location": Location,
    "LocationCapability": LocationCapability,
    "LocationStatus": LocationStatus,
    "LocationType": LocationType,
    "LoyaltyAccount": LoyaltyAccount,
    "LoyaltyAccountMapping": LoyaltyAccountMapping,
    "LoyaltyAccountMappingType": LoyaltyAccountMappingType,
    "LoyaltyEvent": LoyaltyEvent,
    "LoyaltyEventAccumulatePoints": LoyaltyEventAccumulatePoints,
    "LoyaltyEventAdjustPoints": LoyaltyEventAdjustPoints,
    "LoyaltyEventCreateReward": LoyaltyEventCreateReward,
    "LoyaltyEventDateTimeFilter": LoyaltyEventDateTimeFilter,
    "LoyaltyEventDeleteReward": LoyaltyEventDeleteReward,
    "LoyaltyEventExpirePoints": LoyaltyEventExpirePoints,
    "LoyaltyEventFilter": LoyaltyEventFilter,
    "LoyaltyEventLocationFilter": LoyaltyEventLocationFilter,
    "LoyaltyEventLoyaltyAccountFilter": LoyaltyEventLoyaltyAccountFilter,
    "LoyaltyEventOrderFilter": LoyaltyEventOrderFilter,
    "LoyaltyEventOther": LoyaltyEventOther,
    "LoyaltyEventQuery": LoyaltyEventQuery,
    "LoyaltyEventRedeemReward": LoyaltyEventRedeemReward,
    "LoyaltyEventSource": LoyaltyEventSource,
    "LoyaltyEventType": LoyaltyEventType,
    "LoyaltyEventTypeFilter": LoyaltyEventTypeFilter,
    "LoyaltyProgram": LoyaltyProgram,
    "LoyaltyProgramAccrualRule": LoyaltyProgramAccrualRule,
    "LoyaltyProgramAccrualRuleType": LoyaltyProgramAccrualRuleType,
    "LoyaltyProgramExpirationPolicy": LoyaltyProgramExpirationPolicy,
    "LoyaltyProgramRewardDefinition": LoyaltyProgramRewardDefinition,
    "LoyaltyProgramRewardDefinitionScope": LoyaltyProgramRewardDefinitionScope,
    "LoyaltyProgramRewardDefinitionType": LoyaltyProgramRewardDefinitionType,
    "LoyaltyProgramRewardTier": LoyaltyProgramRewardTier,
    "LoyaltyProgramStatus": LoyaltyProgramStatus,
    "LoyaltyProgramTerminology": LoyaltyProgramTerminology,
    "LoyaltyReward": LoyaltyReward,
    "LoyaltyRewardStatus": LoyaltyRewardStatus,
    "MeasurementUnit": MeasurementUnit,
    "MeasurementUnitArea": MeasurementUnitArea,
    "MeasurementUnitCustom": MeasurementUnitCustom,
    "MeasurementUnitGeneric": MeasurementUnitGeneric,
    "MeasurementUnitLength": MeasurementUnitLength,
    "MeasurementUnitTime": MeasurementUnitTime,
    "MeasurementUnitUnitType": MeasurementUnitUnitType,
    "MeasurementUnitVolume": MeasurementUnitVolume,
    "MeasurementUnitWeight": MeasurementUnitWeight,
    "Merchant": Merchant,
    "MerchantStatus": MerchantStatus,
    "ModelBreak": ModelBreak,
    "ModelError": ModelError,
    "Money": Money,
    "ObtainTokenRequest": ObtainTokenRequest,
    "ObtainTokenResponse": ObtainTokenResponse,
    "Order": Order,
    "OrderCreated": OrderCreated,
    "OrderCreatedObject": OrderCreatedObject,
    "OrderEntry": OrderEntry,
    "OrderFulfillment": OrderFulfillment,
    "OrderFulfillmentPickupDetails": OrderFulfillmentPickupDetails,
    "OrderFulfillmentPickupDetailsCurbsidePickupDetails": OrderFulfillmentPickupDetailsCurbsidePickupDetails,
    "OrderFulfillmentPickupDetailsScheduleType": OrderFulfillmentPickupDetailsScheduleType,
    "OrderFulfillmentRecipient": OrderFulfillmentRecipient,
    "OrderFulfillmentShipmentDetails": OrderFulfillmentShipmentDetails,
    "OrderFulfillmentState": OrderFulfillmentState,
    "OrderFulfillmentType": OrderFulfillmentType,
    "OrderFulfillmentUpdated": OrderFulfillmentUpdated,
    "OrderFulfillmentUpdatedObject": OrderFulfillmentUpdatedObject,
    "OrderFulfillmentUpdatedUpdate": OrderFulfillmentUpdatedUpdate,
    "OrderLineItem": OrderLineItem,
    "OrderLineItemAppliedDiscount": OrderLineItemAppliedDiscount,
    "OrderLineItemAppliedTax": OrderLineItemAppliedTax,
    "OrderLineItemDiscount": OrderLineItemDiscount,
    "OrderLineItemDiscountScope": OrderLineItemDiscountScope,
    "OrderLineItemDiscountType": OrderLineItemDiscountType,
    "OrderLineItemModifier": OrderLineItemModifier,
    "OrderLineItemTax": OrderLineItemTax,
    "OrderLineItemTaxScope": OrderLineItemTaxScope,
    "OrderLineItemTaxType": OrderLineItemTaxType,
    "OrderMoneyAmounts": OrderMoneyAmounts,
    "OrderPricingOptions": OrderPricingOptions,
    "OrderQuantityUnit": OrderQuantityUnit,
    "OrderReturn": OrderReturn,
    "OrderReturnDiscount": OrderReturnDiscount,
    "OrderReturnLineItem": OrderReturnLineItem,
    "OrderReturnLineItemModifier": OrderReturnLineItemModifier,
    "OrderReturnServiceCharge": OrderReturnServiceCharge,
    "OrderReturnTax": OrderReturnTax,
    "OrderReward": OrderReward,
    "OrderRoundingAdjustment": OrderRoundingAdjustment,
    "OrderServiceCharge": OrderServiceCharge,
    "OrderServiceChargeCalculationPhase": OrderServiceChargeCalculationPhase,
    "OrderSource": OrderSource,
    "OrderState": OrderState,
    "OrderUpdated": OrderUpdated,
    "OrderUpdatedObject": OrderUpdatedObject,
    "PayOrderRequest": PayOrderRequest,
    "PayOrderResponse": PayOrderResponse,
    "Payment": Payment,
    "PaymentOptions": PaymentOptions,
    "PaymentRefund": PaymentRefund,
    "ProcessingFee": ProcessingFee,
    "Product": Product,
    "ProductType": ProductType,
    "PublishInvoiceRequest": PublishInvoiceRequest,
    "PublishInvoiceResponse": PublishInvoiceResponse,
    "Range": Range,
    "RedeemLoyaltyRewardRequest": RedeemLoyaltyRewardRequest,
    "RedeemLoyaltyRewardResponse": RedeemLoyaltyRewardResponse,
    "Refund": Refund,
    "RefundPaymentRequest": RefundPaymentRequest,
    "RefundPaymentResponse": RefundPaymentResponse,
    "RefundStatus": RefundStatus,
    "RegisterDomainRequest": RegisterDomainRequest,
    "RegisterDomainResponse": RegisterDomainResponse,
    "RegisterDomainResponseStatus": RegisterDomainResponseStatus,
    "RemoveDisputeEvidenceRequest": RemoveDisputeEvidenceRequest,
    "RemoveDisputeEvidenceResponse": RemoveDisputeEvidenceResponse,
    "RemoveGroupFromCustomerRequest": RemoveGroupFromCustomerRequest,
    "RemoveGroupFromCustomerResponse": RemoveGroupFromCustomerResponse,
    "RenewTokenRequest": RenewTokenRequest,
    "RenewTokenResponse": RenewTokenResponse,
    "RetrieveCashDrawerShiftRequest": RetrieveCashDrawerShiftRequest,
    "RetrieveCashDrawerShiftResponse": RetrieveCashDrawerShiftResponse,
    "RetrieveCatalogObjectRequest": RetrieveCatalogObjectRequest,
    "RetrieveCatalogObjectResponse": RetrieveCatalogObjectResponse,
    "RetrieveCustomerGroupRequest": RetrieveCustomerGroupRequest,
    "RetrieveCustomerGroupResponse": RetrieveCustomerGroupResponse,
    "RetrieveCustomerRequest": RetrieveCustomerRequest,
    "RetrieveCustomerResponse": RetrieveCustomerResponse,
    "RetrieveCustomerSegmentRequest": RetrieveCustomerSegmentRequest,
    "RetrieveCustomerSegmentResponse": RetrieveCustomerSegmentResponse,
    "RetrieveDisputeEvidenceRequest": RetrieveDisputeEvidenceRequest,
    "RetrieveDisputeEvidenceResponse": RetrieveDisputeEvidenceResponse,
    "RetrieveDisputeRequest": RetrieveDisputeRequest,
    "RetrieveDisputeResponse": RetrieveDisputeResponse,
    "RetrieveEmployeeRequest": RetrieveEmployeeRequest,
    "RetrieveEmployeeResponse": RetrieveEmployeeResponse,
    "RetrieveInventoryAdjustmentRequest": RetrieveInventoryAdjustmentRequest,
    "RetrieveInventoryAdjustmentResponse": RetrieveInventoryAdjustmentResponse,
    "RetrieveInventoryChangesRequest": RetrieveInventoryChangesRequest,
    "RetrieveInventoryChangesResponse": RetrieveInventoryChangesResponse,
    "RetrieveInventoryCountRequest": RetrieveInventoryCountRequest,
    "RetrieveInventoryCountResponse": RetrieveInventoryCountResponse,
    "RetrieveInventoryPhysicalCountRequest": RetrieveInventoryPhysicalCountRequest,
    "RetrieveInventoryPhysicalCountResponse": RetrieveInventoryPhysicalCountResponse,
    "RetrieveLocationRequest": RetrieveLocationRequest,
    "RetrieveLocationResponse": RetrieveLocationResponse,
    "RetrieveLoyaltyAccountRequest": RetrieveLoyaltyAccountRequest,
    "RetrieveLoyaltyAccountResponse": RetrieveLoyaltyAccountResponse,
    "RetrieveLoyaltyRewardRequest": RetrieveLoyaltyRewardRequest,
    "RetrieveLoyaltyRewardResponse": RetrieveLoyaltyRewardResponse,
    "RetrieveMerchantRequest": RetrieveMerchantRequest,
    "RetrieveMerchantResponse": RetrieveMerchantResponse,
    "RetrieveSubscriptionRequest": RetrieveSubscriptionRequest,
    "RetrieveSubscriptionResponse": RetrieveSubscriptionResponse,
    "RetrieveTeamMemberRequest": RetrieveTeamMemberRequest,
    "RetrieveTeamMemberResponse": RetrieveTeamMemberResponse,
    "RetrieveTransactionRequest": RetrieveTransactionRequest,
    "RetrieveTransactionResponse": RetrieveTransactionResponse,
    "RetrieveWageSettingRequest": RetrieveWageSettingRequest,
    "RetrieveWageSettingResponse": RetrieveWageSettingResponse,
    "RevokeTokenRequest": RevokeTokenRequest,
    "RevokeTokenResponse": RevokeTokenResponse,
    "SearchCatalogItemsRequest": SearchCatalogItemsRequest,
    "SearchCatalogItemsRequestStockLevel": SearchCatalogItemsRequestStockLevel,
    "SearchCatalogItemsResponse": SearchCatalogItemsResponse,
    "SearchCatalogObjectsRequest": SearchCatalogObjectsRequest,
    "SearchCatalogObjectsResponse": SearchCatalogObjectsResponse,
    "SearchCustomersRequest": SearchCustomersRequest,
    "SearchCustomersResponse": SearchCustomersResponse,
    "SearchInvoicesRequest": SearchInvoicesRequest,
    "SearchInvoicesResponse": SearchInvoicesResponse,
    "SearchLoyaltyAccountsRequest": SearchLoyaltyAccountsRequest,
    "SearchLoyaltyAccountsRequestLoyaltyAccountQuery": SearchLoyaltyAccountsRequestLoyaltyAccountQuery,
    "SearchLoyaltyAccountsResponse": SearchLoyaltyAccountsResponse,
    "SearchLoyaltyEventsRequest": SearchLoyaltyEventsRequest,
    "SearchLoyaltyEventsResponse": SearchLoyaltyEventsResponse,
    "SearchLoyaltyRewardsRequest": SearchLoyaltyRewardsRequest,
    "SearchLoyaltyRewardsRequestLoyaltyRewardQuery": SearchLoyaltyRewardsRequestLoyaltyRewardQuery,
    "SearchLoyaltyRewardsResponse": SearchLoyaltyRewardsResponse,
    "SearchOrdersCustomerFilter": SearchOrdersCustomerFilter,
    "SearchOrdersDateTimeFilter": SearchOrdersDateTimeFilter,
    "SearchOrdersFilter": SearchOrdersFilter,
    "SearchOrdersFulfillmentFilter": SearchOrdersFulfillmentFilter,
    "SearchOrdersQuery": SearchOrdersQuery,
    "SearchOrdersRequest": SearchOrdersRequest,
    "SearchOrdersResponse": SearchOrdersResponse,
    "SearchOrdersSort": SearchOrdersSort,
    "SearchOrdersSortField": SearchOrdersSortField,
    "SearchOrdersSourceFilter": SearchOrdersSourceFilter,
    "SearchOrdersStateFilter": SearchOrdersStateFilter,
    "SearchShiftsRequest": SearchShiftsRequest,
    "SearchShiftsResponse": SearchShiftsResponse,
    "SearchSubscriptionsFilter": SearchSubscriptionsFilter,
    "SearchSubscriptionsQuery": SearchSubscriptionsQuery,
    "SearchSubscriptionsRequest": SearchSubscriptionsRequest,
    "SearchSubscriptionsResponse": SearchSubscriptionsResponse,
    "SearchTeamMembersFilter": SearchTeamMembersFilter,
    "SearchTeamMembersQuery": SearchTeamMembersQuery,
    "SearchTeamMembersRequest": SearchTeamMembersRequest,
    "SearchTeamMembersResponse": SearchTeamMembersResponse,
    "SearchTerminalCheckoutsRequest": SearchTerminalCheckoutsRequest,
    "SearchTerminalCheckoutsResponse": SearchTerminalCheckoutsResponse,
    "Shift": Shift,
    "ShiftFilter": ShiftFilter,
    "ShiftFilterStatus": ShiftFilterStatus,
    "ShiftQuery": ShiftQuery,
    "ShiftSort": ShiftSort,
    "ShiftSortField": ShiftSortField,
    "ShiftStatus": ShiftStatus,
    "ShiftWage": ShiftWage,
    "ShiftWorkday": ShiftWorkday,
    "ShiftWorkdayMatcher": ShiftWorkdayMatcher,
    "SortOrder": SortOrder,
    "SourceApplication": SourceApplication,
    "StandardUnitDescription": StandardUnitDescription,
    "StandardUnitDescriptionGroup": StandardUnitDescriptionGroup,
    "SubmitEvidenceRequest": SubmitEvidenceRequest,
    "SubmitEvidenceResponse": SubmitEvidenceResponse,
    "Subscription": Subscription,
    "SubscriptionCadence": SubscriptionCadence,
    "SubscriptionEvent": SubscriptionEvent,
    "SubscriptionEventSubscriptionEventType": SubscriptionEventSubscriptionEventType,
    "SubscriptionPhase": SubscriptionPhase,
    "SubscriptionStatus": SubscriptionStatus,
    "TaxCalculationPhase": TaxCalculationPhase,
    "TaxInclusionType": TaxInclusionType,
    "TeamMember": TeamMember,
    "TeamMemberAssignedLocations": TeamMemberAssignedLocations,
    "TeamMemberAssignedLocationsAssignmentType": TeamMemberAssignedLocationsAssignmentType,
    "TeamMemberStatus": TeamMemberStatus,
    "TeamMemberWage": TeamMemberWage,
    "Tender": Tender,
    "TenderBankTransferDetails": TenderBankTransferDetails,
    "TenderBankTransferDetailsStatus": TenderBankTransferDetailsStatus,
    "TenderCardDetails": TenderCardDetails,
    "TenderCardDetailsEntryMethod": TenderCardDetailsEntryMethod,
    "TenderCardDetailsStatus": TenderCardDetailsStatus,
    "TenderCashDetails": TenderCashDetails,
    "TenderType": TenderType,
    "TerminalCheckout": TerminalCheckout,
    "TerminalCheckoutQuery": TerminalCheckoutQuery,
    "TerminalCheckoutQueryFilter": TerminalCheckoutQueryFilter,
    "TerminalCheckoutQuerySort": TerminalCheckoutQuerySort,
    "TimeRange": TimeRange,
    "TipSettings": TipSettings,
    "Transaction": Transaction,
    "TransactionProduct": TransactionProduct,
    "TransactionType": TransactionType,
    "UpdateBreakTypeRequest": UpdateBreakTypeRequest,
    "UpdateBreakTypeResponse": UpdateBreakTypeResponse,
    "UpdateCustomerGroupRequest": UpdateCustomerGroupRequest,
    "UpdateCustomerGroupResponse": UpdateCustomerGroupResponse,
    "UpdateCustomerRequest": UpdateCustomerRequest,
    "UpdateCustomerResponse": UpdateCustomerResponse,
    "UpdateInvoiceRequest": UpdateInvoiceRequest,
    "UpdateInvoiceResponse": UpdateInvoiceResponse,
    "UpdateItemModifierListsRequest": UpdateItemModifierListsRequest,
    "UpdateItemModifierListsResponse": UpdateItemModifierListsResponse,
    "UpdateItemTaxesRequest": UpdateItemTaxesRequest,
    "UpdateItemTaxesResponse": UpdateItemTaxesResponse,
    "UpdateLocationRequest": UpdateLocationRequest,
    "UpdateLocationResponse": UpdateLocationResponse,
    "UpdateOrderRequest": UpdateOrderRequest,
    "UpdateOrderResponse": UpdateOrderResponse,
    "UpdateShiftRequest": UpdateShiftRequest,
    "UpdateShiftResponse": UpdateShiftResponse,
    "UpdateSubscriptionRequest": UpdateSubscriptionRequest,
    "UpdateSubscriptionResponse": UpdateSubscriptionResponse,
    "UpdateTeamMemberRequest": UpdateTeamMemberRequest,
    "UpdateTeamMemberResponse": UpdateTeamMemberResponse,
    "UpdateWageSettingRequest": UpdateWageSettingRequest,
    "UpdateWageSettingResponse": UpdateWageSettingResponse,
    "UpdateWorkweekConfigRequest": UpdateWorkweekConfigRequest,
    "UpdateWorkweekConfigResponse": UpdateWorkweekConfigResponse,
    "UpsertCatalogObjectRequest": UpsertCatalogObjectRequest,
    "UpsertCatalogObjectResponse": UpsertCatalogObjectResponse,
    "V1AdjustInventoryRequest": V1AdjustInventoryRequest,
    "V1AdjustInventoryRequestAdjustmentType": V1AdjustInventoryRequestAdjustmentType,
    "V1ApplyFeeRequest": V1ApplyFeeRequest,
    "V1ApplyModifierListRequest": V1ApplyModifierListRequest,
    "V1BankAccount": V1BankAccount,
    "V1BankAccountType": V1BankAccountType,
    "V1CashDrawerEvent": V1CashDrawerEvent,
    "V1CashDrawerEventEventType": V1CashDrawerEventEventType,
    "V1CashDrawerShift": V1CashDrawerShift,
    "V1CashDrawerShiftEventType": V1CashDrawerShiftEventType,
    "V1Category": V1Category,
    "V1CreateCategoryRequest": V1CreateCategoryRequest,
    "V1CreateDiscountRequest": V1CreateDiscountRequest,
    "V1CreateEmployeeRoleRequest": V1CreateEmployeeRoleRequest,
    "V1CreateFeeRequest": V1CreateFeeRequest,
    "V1CreateItemRequest": V1CreateItemRequest,
    "V1CreateModifierListRequest": V1CreateModifierListRequest,
    "V1CreateModifierOptionRequest": V1CreateModifierOptionRequest,
    "V1CreatePageRequest": V1CreatePageRequest,
    "V1CreateRefundRequest": V1CreateRefundRequest,
    "V1CreateRefundRequestType": V1CreateRefundRequestType,
    "V1CreateVariationRequest": V1CreateVariationRequest,
    "V1DeleteCategoryRequest": V1DeleteCategoryRequest,
    "V1DeleteDiscountRequest": V1DeleteDiscountRequest,
    "V1DeleteFeeRequest": V1DeleteFeeRequest,
    "V1DeleteItemRequest": V1DeleteItemRequest,
    "V1DeleteModifierListRequest": V1DeleteModifierListRequest,
    "V1DeleteModifierOptionRequest": V1DeleteModifierOptionRequest,
    "V1DeletePageCellRequest": V1DeletePageCellRequest,
    "V1DeletePageRequest": V1DeletePageRequest,
    "V1DeleteTimecardRequest": V1DeleteTimecardRequest,
    "V1DeleteTimecardResponse": V1DeleteTimecardResponse,
    "V1DeleteVariationRequest": V1DeleteVariationRequest,
    "V1Discount": V1Discount,
    "V1DiscountColor": V1DiscountColor,
    "V1DiscountDiscountType": V1DiscountDiscountType,
    "V1Employee": V1Employee,
    "V1EmployeeRole": V1EmployeeRole,
    "V1EmployeeRolePermissions": V1EmployeeRolePermissions,
    "V1EmployeeStatus": V1EmployeeStatus,
    "V1Fee": V1Fee,
    "V1FeeAdjustmentType": V1FeeAdjustmentType,
    "V1FeeCalculationPhase": V1FeeCalculationPhase,
    "V1FeeInclusionType": V1FeeInclusionType,
    "V1FeeType": V1FeeType,
    "V1InventoryEntry": V1InventoryEntry,
    "V1Item": V1Item,
    "V1ItemColor": V1ItemColor,
    "V1ItemImage": V1ItemImage,
    "V1ItemType": V1ItemType,
    "V1ItemVisibility": V1ItemVisibility,
    "V1ListBankAccountsRequest": V1ListBankAccountsRequest,
    "V1ListBankAccountsResponse": V1ListBankAccountsResponse,
    "V1ListCashDrawerShiftsRequest": V1ListCashDrawerShiftsRequest,
    "V1ListCashDrawerShiftsResponse": V1ListCashDrawerShiftsResponse,
    "V1ListCategoriesRequest": V1ListCategoriesRequest,
    "V1ListCategoriesResponse": V1ListCategoriesResponse,
    "V1ListDiscountsRequest": V1ListDiscountsRequest,
    "V1ListDiscountsResponse": V1ListDiscountsResponse,
    "V1ListEmployeeRolesRequest": V1ListEmployeeRolesRequest,
    "V1ListEmployeeRolesResponse": V1ListEmployeeRolesResponse,
    "V1ListEmployeesRequest": V1ListEmployeesRequest,
    "V1ListEmployeesRequestStatus": V1ListEmployeesRequestStatus,
    "V1ListEmployeesResponse": V1ListEmployeesResponse,
    "V1ListFeesRequest": V1ListFeesRequest,
    "V1ListFeesResponse": V1ListFeesResponse,
    "V1ListInventoryRequest": V1ListInventoryRequest,
    "V1ListInventoryResponse": V1ListInventoryResponse,
    "V1ListItemsRequest": V1ListItemsRequest,
    "V1ListItemsResponse": V1ListItemsResponse,
    "V1ListLocationsRequest": V1ListLocationsRequest,
    "V1ListLocationsResponse": V1ListLocationsResponse,
    "V1ListModifierListsRequest": V1ListModifierListsRequest,
    "V1ListModifierListsResponse": V1ListModifierListsResponse,
    "V1ListOrdersRequest": V1ListOrdersRequest,
    "V1ListOrdersResponse": V1ListOrdersResponse,
    "V1ListPagesRequest": V1ListPagesRequest,
    "V1ListPagesResponse": V1ListPagesResponse,
    "V1ListPaymentsRequest": V1ListPaymentsRequest,
    "V1ListPaymentsResponse": V1ListPaymentsResponse,
    "V1ListRefundsRequest": V1ListRefundsRequest,
    "V1ListRefundsResponse": V1ListRefundsResponse,
    "V1ListSettlementsRequest": V1ListSettlementsRequest,
    "V1ListSettlementsRequestStatus": V1ListSettlementsRequestStatus,
    "V1ListSettlementsResponse": V1ListSettlementsResponse,
    "V1ListTimecardEventsRequest": V1ListTimecardEventsRequest,
    "V1ListTimecardEventsResponse": V1ListTimecardEventsResponse,
    "V1ListTimecardsRequest": V1ListTimecardsRequest,
    "V1ListTimecardsResponse": V1ListTimecardsResponse,
    "V1Merchant": V1Merchant,
    "V1MerchantAccountType": V1MerchantAccountType,
    "V1MerchantBusinessType": V1MerchantBusinessType,
    "V1MerchantLocationDetails": V1MerchantLocationDetails,
    "V1ModifierList": V1ModifierList,
    "V1ModifierListSelectionType": V1ModifierListSelectionType,
    "V1ModifierOption": V1ModifierOption,
    "V1Money": V1Money,
    "V1Order": V1Order,
    "V1OrderHistoryEntry": V1OrderHistoryEntry,
    "V1OrderHistoryEntryAction": V1OrderHistoryEntryAction,
    "V1OrderState": V1OrderState,
    "V1Page": V1Page,
    "V1PageCell": V1PageCell,
    "V1PageCellObjectType": V1PageCellObjectType,
    "V1PageCellPlaceholderType": V1PageCellPlaceholderType,
    "V1Payment": V1Payment,
    "V1PaymentDiscount": V1PaymentDiscount,
    "V1PaymentItemDetail": V1PaymentItemDetail,
    "V1PaymentItemization": V1PaymentItemization,
    "V1PaymentItemizationItemizationType": V1PaymentItemizationItemizationType,
    "V1PaymentModifier": V1PaymentModifier,
    "V1PaymentSurcharge": V1PaymentSurcharge,
    "V1PaymentSurchargeType": V1PaymentSurchargeType,
    "V1PaymentTax": V1PaymentTax,
    "V1PaymentTaxInclusionType": V1PaymentTaxInclusionType,
    "V1PhoneNumber": V1PhoneNumber,
    "V1Refund": V1Refund,
    "V1RefundType": V1RefundType,
    "V1RemoveFeeRequest": V1RemoveFeeRequest,
    "V1RemoveModifierListRequest": V1RemoveModifierListRequest,
    "V1RetrieveBankAccountRequest": V1RetrieveBankAccountRequest,
    "V1RetrieveBusinessRequest": V1RetrieveBusinessRequest,
    "V1RetrieveCashDrawerShiftRequest": V1RetrieveCashDrawerShiftRequest,
    "V1RetrieveEmployeeRequest": V1RetrieveEmployeeRequest,
    "V1RetrieveEmployeeRoleRequest": V1RetrieveEmployeeRoleRequest,
    "V1RetrieveItemRequest": V1RetrieveItemRequest,
    "V1RetrieveModifierListRequest": V1RetrieveModifierListRequest,
    "V1RetrieveOrderRequest": V1RetrieveOrderRequest,
    "V1RetrievePaymentRequest": V1RetrievePaymentRequest,
    "V1RetrieveSettlementRequest": V1RetrieveSettlementRequest,
    "V1RetrieveTimecardRequest": V1RetrieveTimecardRequest,
    "V1Settlement": V1Settlement,
    "V1SettlementEntry": V1SettlementEntry,
    "V1SettlementEntryType": V1SettlementEntryType,
    "V1SettlementStatus": V1SettlementStatus,
    "V1Tender": V1Tender,
    "V1TenderCardBrand": V1TenderCardBrand,
    "V1TenderEntryMethod": V1TenderEntryMethod,
    "V1TenderType": V1TenderType,
    "V1Timecard": V1Timecard,
    "V1TimecardEvent": V1TimecardEvent,
    "V1TimecardEventEventType": V1TimecardEventEventType,
    "V1UpdateCategoryRequest": V1UpdateCategoryRequest,
    "V1UpdateDiscountRequest": V1UpdateDiscountRequest,
    "V1UpdateEmployeeRequest": V1UpdateEmployeeRequest,
    "V1UpdateEmployeeRoleRequest": V1UpdateEmployeeRoleRequest,
    "V1UpdateFeeRequest": V1UpdateFeeRequest,
    "V1UpdateItemRequest": V1UpdateItemRequest,
    "V1UpdateModifierListRequest": V1UpdateModifierListRequest,
    "V1UpdateModifierListRequestSelectionType": V1UpdateModifierListRequestSelectionType,
    "V1UpdateModifierOptionRequest": V1UpdateModifierOptionRequest,
    "V1UpdateOrderRequest": V1UpdateOrderRequest,
    "V1UpdateOrderRequestAction": V1UpdateOrderRequestAction,
    "V1UpdatePageCellRequest": V1UpdatePageCellRequest,
    "V1UpdatePageRequest": V1UpdatePageRequest,
    "V1UpdateTimecardRequest": V1UpdateTimecardRequest,
    "V1UpdateVariationRequest": V1UpdateVariationRequest,
    "V1Variation": V1Variation,
    "V1VariationInventoryAlertType": V1VariationInventoryAlertType,
    "V1VariationPricingType": V1VariationPricingType,
    "VoidTransactionRequest": VoidTransactionRequest,
    "VoidTransactionResponse": VoidTransactionResponse,
    "WageSetting": WageSetting,
    "Weekday": Weekday,
    "WorkweekConfig": WorkweekConfig,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ApplePayApiApiKeys {
    oauth2ClientSecret,
}

export class ApplePayApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplePayApiApiKeys, value: string) {
        (this.authentications as any)[ApplePayApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Activates a domain for use with Web Apple Pay and Square. A validation will be performed on this domain by Apple to ensure is it properly set up as an Apple Pay enabled domain.  This endpoint provides an easy way for platform developers to bulk activate Web Apple Pay with Square for merchants using their platform.  To learn more about Apple Pay on Web see the Apple Pay section in the [Square Payment Form Walkthrough](/docs/payment-form/payment-form-walkthrough).
     * @summary RegisterDomain
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public registerDomain (body: RegisterDomainRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RegisterDomainResponse;  }> {
        const localVarPath = this.basePath + '/v2/apple-pay/domains';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RegisterDomainRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RegisterDomainResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RegisterDomainResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountsApiApiKeys {
    oauth2ClientSecret,
}

export class BankAccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountsApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Returns details of a [BankAccount](#type-bankaccount)  linked to a Square account. For more information, see  [Bank Accounts API](/docs/bank-accounts-api).
     * @summary GetBankAccount
     * @param bankAccountId Square-issued ID of the desired &#x60;BankAccount&#x60;.
     * @param {*} [options] Override http request options.
     */
    public getBankAccount (bankAccountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetBankAccountResponse;  }> {
        const localVarPath = this.basePath + '/v2/bank-accounts/{bank_account_id}'
            .replace('{' + 'bank_account_id' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetBankAccountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetBankAccountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns details of a [BankAccount](#type-bankaccount) identified by V1 bank account ID.  For more information, see  [Retrieve a bank account by using an ID issued by V1 Bank Accounts API](/docs/bank-accounts-api#retrieve-a-bank-account-by-using-an-id-issued-by-the-v1-bank-accounts-api).
     * @summary GetBankAccountByV1Id
     * @param v1BankAccountId Connect V1 ID of the desired &#x60;BankAccount&#x60;. For more information, see  [Retrieve a bank account by using an ID issued by V1 Bank Accounts API](https://developer.squareup.com/docs/docs/bank-accounts-api#retrieve-a-bank-account-by-using-an-id-issued-by-v1-bank-accounts-api).
     * @param {*} [options] Override http request options.
     */
    public getBankAccountByV1Id (v1BankAccountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetBankAccountByV1IdResponse;  }> {
        const localVarPath = this.basePath + '/v2/bank-accounts/by-v1-id/{v1_bank_account_id}'
            .replace('{' + 'v1_bank_account_id' + '}', encodeURIComponent(String(v1BankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'v1BankAccountId' is not null or undefined
        if (v1BankAccountId === null || v1BankAccountId === undefined) {
            throw new Error('Required parameter v1BankAccountId was null or undefined when calling getBankAccountByV1Id.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetBankAccountByV1IdResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetBankAccountByV1IdResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of [BankAccount](#type-bankaccount) objects linked to a Square account.  For more information, see  [Bank Accounts API](/docs/bank-accounts-api).
     * @summary ListBankAccounts
     * @param cursor The pagination cursor returned by a previous call to this endpoint. Use it in the next &#x60;ListBankAccounts&#x60; request to retrieve the next set  of results.  See the [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) guide for more information.
     * @param limit Upper limit on the number of bank accounts to return in the response.  Currently, 1000 is the largest supported limit. You can specify a limit  of up to 1000 bank accounts. This is also the default limit.
     * @param locationId Location ID. You can specify this optional filter  to retrieve only the linked bank accounts belonging to a specific location.
     * @param {*} [options] Override http request options.
     */
    public listBankAccounts (cursor?: string, limit?: number, locationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListBankAccountsResponse;  }> {
        const localVarPath = this.basePath + '/v2/bank-accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListBankAccountsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListBankAccountsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CashDrawersApiApiKeys {
    oauth2ClientSecret,
}

export class CashDrawersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CashDrawersApiApiKeys, value: string) {
        (this.authentications as any)[CashDrawersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Provides a paginated list of events for a single cash drawer shift.
     * @summary ListCashDrawerShiftEvents
     * @param locationId The ID of the location to list cash drawer shifts for.
     * @param shiftId The shift ID.
     * @param limit Number of resources to be returned in a page of results (200 by default, 1000 max).
     * @param cursor Opaque cursor for fetching the next page of results.
     * @param {*} [options] Override http request options.
     */
    public listCashDrawerShiftEvents (locationId: string, shiftId: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCashDrawerShiftEventsResponse;  }> {
        const localVarPath = this.basePath + '/v2/cash-drawers/shifts/{shift_id}/events'
            .replace('{' + 'shift_id' + '}', encodeURIComponent(String(shiftId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listCashDrawerShiftEvents.');
        }

        // verify required parameter 'shiftId' is not null or undefined
        if (shiftId === null || shiftId === undefined) {
            throw new Error('Required parameter shiftId was null or undefined when calling listCashDrawerShiftEvents.');
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCashDrawerShiftEventsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCashDrawerShiftEventsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for all of the cash drawer shifts for a location in a date range.
     * @summary ListCashDrawerShifts
     * @param locationId The ID of the location to query for a list of cash drawer shifts.
     * @param sortOrder The order in which cash drawer shifts are listed in the response, based on their opened_at field. Default value: ASC
     * @param beginTime The inclusive start time of the query on opened_at, in ISO 8601 format.
     * @param endTime The exclusive end date of the query on opened_at, in ISO 8601 format.
     * @param limit Number of cash drawer shift events in a page of results (200 by default, 1000 max).
     * @param cursor Opaque cursor for fetching the next page of results.
     * @param {*} [options] Override http request options.
     */
    public listCashDrawerShifts (locationId: string, sortOrder?: string, beginTime?: string, endTime?: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCashDrawerShiftsResponse;  }> {
        const localVarPath = this.basePath + '/v2/cash-drawers/shifts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listCashDrawerShifts.');
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCashDrawerShiftsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCashDrawerShiftsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the summary details for a single cash drawer shift. See RetrieveCashDrawerShiftEvents for a list of cash drawer shift events.
     * @summary RetrieveCashDrawerShift
     * @param locationId The ID of the location to retrieve cash drawer shifts from.
     * @param shiftId The shift ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveCashDrawerShift (locationId: string, shiftId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveCashDrawerShiftResponse;  }> {
        const localVarPath = this.basePath + '/v2/cash-drawers/shifts/{shift_id}'
            .replace('{' + 'shift_id' + '}', encodeURIComponent(String(shiftId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveCashDrawerShift.');
        }

        // verify required parameter 'shiftId' is not null or undefined
        if (shiftId === null || shiftId === undefined) {
            throw new Error('Required parameter shiftId was null or undefined when calling retrieveCashDrawerShift.');
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveCashDrawerShiftResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveCashDrawerShiftResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogApiApiKeys {
    oauth2ClientSecret,
}

export class CatalogApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogApiApiKeys, value: string) {
        (this.authentications as any)[CatalogApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Deletes a set of [CatalogItem](#type-catalogitem)s based on the provided list of target IDs and returns a set of successfully deleted IDs in the response. Deletion is a cascading event such that all children of the targeted object are also deleted. For example, deleting a CatalogItem will also delete all of its [CatalogItemVariation](#type-catalogitemvariation) children.  `BatchDeleteCatalogObjects` succeeds even if only a portion of the targeted IDs can be deleted. The response will only include IDs that were actually deleted.
     * @summary BatchDeleteCatalogObjects
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchDeleteCatalogObjects (body: BatchDeleteCatalogObjectsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchDeleteCatalogObjectsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/batch-delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchDeleteCatalogObjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchDeleteCatalogObjectsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchDeleteCatalogObjectsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchDeleteCatalogObjectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a set of objects based on the provided ID. Each [CatalogItem](#type-catalogitem) returned in the set includes all of its child information including: all of its [CatalogItemVariation](#type-catalogitemvariation) objects, references to its [CatalogModifierList](#type-catalogmodifierlist) objects, and the ids of any [CatalogTax](#type-catalogtax) objects that apply to it.
     * @summary BatchRetrieveCatalogObjects
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchRetrieveCatalogObjects (body: BatchRetrieveCatalogObjectsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchRetrieveCatalogObjectsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/batch-retrieve';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchRetrieveCatalogObjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchRetrieveCatalogObjectsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchRetrieveCatalogObjectsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchRetrieveCatalogObjectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates or updates up to 10,000 target objects based on the provided list of objects. The target objects are grouped into batches and each batch is inserted/updated in an all-or-nothing manner. If an object within a batch is malformed in some way, or violates a database constraint, the entire batch containing that item will be disregarded. However, other batches in the same request may still succeed. Each batch may contain up to 1,000 objects, and batches will be processed in order as long as the total object count for the request (items, variations, modifier lists, discounts, and taxes) is no more than 10,000.
     * @summary BatchUpsertCatalogObjects
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchUpsertCatalogObjects (body: BatchUpsertCatalogObjectsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchUpsertCatalogObjectsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/batch-upsert';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchUpsertCatalogObjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchUpsertCatalogObjectsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchUpsertCatalogObjectsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchUpsertCatalogObjectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves information about the Square Catalog API, such as batch size limits that can be used by the `BatchUpsertCatalogObjects` endpoint.
     * @summary CatalogInfo
     * @param {*} [options] Override http request options.
     */
    public catalogInfo (options: any = {}) : Promise<{ response: http.ClientResponse; body: CatalogInfoResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/info';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogInfoResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogInfoResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a single [CatalogObject](#type-catalogobject) based on the provided ID and returns the set of successfully deleted IDs in the response. Deletion is a cascading event such that all children of the targeted object are also deleted. For example, deleting a [CatalogItem](#type-catalogitem) will also delete all of its [CatalogItemVariation](#type-catalogitemvariation) children.
     * @summary DeleteCatalogObject
     * @param objectId The ID of the catalog object to be deleted. When an object is deleted, other objects in the graph that depend on that object will be deleted as well (for example, deleting a catalog item will delete its catalog item variations).
     * @param {*} [options] Override http request options.
     */
    public deleteCatalogObject (objectId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteCatalogObjectResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/object/{object_id}'
            .replace('{' + 'object_id' + '}', encodeURIComponent(String(objectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling deleteCatalogObject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteCatalogObjectResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteCatalogObjectResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of [CatalogObject](#type-catalogobject)s that includes all objects of a set of desired types (for example, all [CatalogItem](#type-catalogitem) and [CatalogTax](#type-catalogtax) objects) in the catalog. The `types` parameter is specified as a comma-separated list of valid [CatalogObject](#type-catalogobject) types: `ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, `CATEGORY`, `DISCOUNT`, `TAX`, `IMAGE`.  __Important:__ ListCatalog does not return deleted catalog items. To retrieve deleted catalog items, use SearchCatalogObjects and set `include_deleted_objects` to `true`.
     * @summary ListCatalog
     * @param cursor The pagination cursor returned in the previous response. Leave unset for an initial request. See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
     * @param types An optional case-insensitive, comma-separated list of object types to retrieve, for example &#x60;ITEM,ITEM_VARIATION,CATEGORY,IMAGE&#x60;.  The legal values are taken from the CatalogObjectType enum: &#x60;ITEM&#x60;, &#x60;ITEM_VARIATION&#x60;, &#x60;CATEGORY&#x60;, &#x60;DISCOUNT&#x60;, &#x60;TAX&#x60;, &#x60;MODIFIER&#x60;, &#x60;MODIFIER_LIST&#x60;, or &#x60;IMAGE&#x60;.
     * @param {*} [options] Override http request options.
     */
    public listCatalog (cursor?: string, types?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCatalogResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCatalogResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCatalogResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single [CatalogItem](#type-catalogitem) as a [CatalogObject](#type-catalogobject) based on the provided ID. The returned object includes all of the relevant [CatalogItem](#type-catalogitem) information including: [CatalogItemVariation](#type-catalogitemvariation) children, references to its [CatalogModifierList](#type-catalogmodifierlist) objects, and the ids of any [CatalogTax](#type-catalogtax) objects that apply to it.
     * @summary RetrieveCatalogObject
     * @param objectId The object ID of any type of catalog objects to be retrieved.
     * @param includeRelatedObjects If &#x60;true&#x60;, the response will include additional objects that are related to the requested object, as follows:  If the &#x60;object&#x60; field of the response contains a CatalogItem, its associated CatalogCategory, CatalogTax objects, CatalogImages and CatalogModifierLists will be returned in the &#x60;related_objects&#x60; field of the response. If the &#x60;object&#x60; field of the response contains a CatalogItemVariation, its parent CatalogItem will be returned in the &#x60;related_objects&#x60; field of the response.  Default value: &#x60;false&#x60;
     * @param {*} [options] Override http request options.
     */
    public retrieveCatalogObject (objectId: string, includeRelatedObjects?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveCatalogObjectResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/object/{object_id}'
            .replace('{' + 'object_id' + '}', encodeURIComponent(String(objectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling retrieveCatalogObject.');
        }

        if (includeRelatedObjects !== undefined) {
            localVarQueryParameters['include_related_objects'] = ObjectSerializer.serialize(includeRelatedObjects, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveCatalogObjectResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveCatalogObjectResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for catalog items or item variations by matching supported search attribute values, including custom attribute values, against one or more of the specified query expressions,   This (`SearchCatalogItems`) endpoint differs from the [SearchCatalogObjects](#endpoint-Catalog-SearchCatalogObjects) endpoint in the following aspects:  - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects. - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not. - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does. - The both endpoints use different call conventions, including the query filter formats.
     * @summary SearchCatalogItems
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchCatalogItems (body: SearchCatalogItemsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchCatalogItemsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/search-catalog-items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchCatalogItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchCatalogItemsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchCatalogItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchCatalogItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for [CatalogObject](#type-CatalogObject) of any types against supported search attribute values,  excluding custom attribute values on items or item variations, against one or more of the specified query expressions,   This (`SearchCatalogObjects`) endpoint differs from the [SearchCatalogItems](#endpoint-Catalog-SearchCatalogItems) endpoint in the following aspects:  - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects. - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not. - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does. - The both endpoints have different call conventions, including the query filter formats.
     * @summary SearchCatalogObjects
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchCatalogObjects (body: SearchCatalogObjectsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchCatalogObjectsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchCatalogObjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchCatalogObjectsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchCatalogObjectsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchCatalogObjectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the [CatalogModifierList](#type-catalogmodifierlist) objects that apply to the targeted [CatalogItem](#type-catalogitem) without having to perform an upsert on the entire item.
     * @summary UpdateItemModifierLists
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateItemModifierLists (body: UpdateItemModifierListsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateItemModifierListsResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/update-item-modifier-lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemModifierLists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateItemModifierListsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateItemModifierListsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateItemModifierListsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the [CatalogTax](#type-catalogtax) objects that apply to the targeted [CatalogItem](#type-catalogitem) without having to perform an upsert on the entire item.
     * @summary UpdateItemTaxes
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateItemTaxes (body: UpdateItemTaxesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateItemTaxesResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/update-item-taxes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemTaxes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateItemTaxesRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateItemTaxesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateItemTaxesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates or updates the target [CatalogObject](#type-catalogobject).
     * @summary UpsertCatalogObject
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public upsertCatalogObject (body: UpsertCatalogObjectRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpsertCatalogObjectResponse;  }> {
        const localVarPath = this.basePath + '/v2/catalog/object';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling upsertCatalogObject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpsertCatalogObjectRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpsertCatalogObjectResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpsertCatalogObjectResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CheckoutApiApiKeys {
    oauth2ClientSecret,
}

export class CheckoutApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CheckoutApiApiKeys, value: string) {
        (this.authentications as any)[CheckoutApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Links a `checkoutId` to a `checkout_page_url` that customers will be directed to in order to provide their payment information using a payment processing workflow hosted on connect.squareup.com.
     * @summary CreateCheckout
     * @param locationId The ID of the business location to associate the checkout with.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createCheckout (locationId: string, body: CreateCheckoutRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/checkouts'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createCheckout.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCheckout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateCheckoutRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateCheckoutResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateCheckoutResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerGroupsApiApiKeys {
    oauth2ClientSecret,
}

export class CustomerGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerGroupsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Creates a new customer group for a business.   The request must include the `name` value of the group.
     * @summary CreateCustomerGroup
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createCustomerGroup (body: CreateCustomerGroupRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateCustomerGroupResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomerGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateCustomerGroupRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateCustomerGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateCustomerGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a customer group as identified by the `group_id` value.
     * @summary DeleteCustomerGroup
     * @param groupId The ID of the customer group to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomerGroup (groupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteCustomerGroupResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/groups/{group_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteCustomerGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteCustomerGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteCustomerGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the list of customer groups of a business.
     * @summary ListCustomerGroups
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
     * @param {*} [options] Override http request options.
     */
    public listCustomerGroups (cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCustomerGroupsResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCustomerGroupsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCustomerGroupsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific customer group as identified by the `group_id` value.
     * @summary RetrieveCustomerGroup
     * @param groupId The ID of the customer group to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveCustomerGroup (groupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveCustomerGroupResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/groups/{group_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling retrieveCustomerGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveCustomerGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveCustomerGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a customer group as identified by the `group_id` value.
     * @summary UpdateCustomerGroup
     * @param groupId The ID of the customer group to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateCustomerGroup (groupId: string, body: UpdateCustomerGroupRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateCustomerGroupResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/groups/{group_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateCustomerGroup.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomerGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateCustomerGroupRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateCustomerGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateCustomerGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerSegmentsApiApiKeys {
    oauth2ClientSecret,
}

export class CustomerSegmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerSegmentsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerSegmentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Retrieves the list of customer segments of a business.
     * @summary ListCustomerSegments
     * @param cursor A pagination cursor returned by previous calls to __ListCustomerSegments__. Used to retrieve the next set of query results.  See the [Pagination guide](https://developer.squareup.com/docs/docs/working-with-apis/pagination) for more information.
     * @param {*} [options] Override http request options.
     */
    public listCustomerSegments (cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCustomerSegmentsResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/segments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCustomerSegmentsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCustomerSegmentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific customer segment as identified by the `segment_id` value.
     * @summary RetrieveCustomerSegment
     * @param segmentId The Square-issued ID of the customer segment.
     * @param {*} [options] Override http request options.
     */
    public retrieveCustomerSegment (segmentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveCustomerSegmentResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/segments/{segment_id}'
            .replace('{' + 'segment_id' + '}', encodeURIComponent(String(segmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'segmentId' is not null or undefined
        if (segmentId === null || segmentId === undefined) {
            throw new Error('Required parameter segmentId was null or undefined when calling retrieveCustomerSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveCustomerSegmentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveCustomerSegmentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomersApiApiKeys {
    oauth2ClientSecret,
}

export class CustomersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomersApiApiKeys, value: string) {
        (this.authentications as any)[CustomersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Adds a group membership to a customer.   The customer is identified by the `customer_id` value  and the customer group is identified by the `group_id` value.
     * @summary AddGroupToCustomer
     * @param customerId The ID of the customer to add to a group.
     * @param groupId The ID of the customer group to add the customer to.
     * @param {*} [options] Override http request options.
     */
    public addGroupToCustomer (customerId: string, groupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AddGroupToCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}/groups/{group_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling addGroupToCustomer.');
        }

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling addGroupToCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AddGroupToCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddGroupToCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new customer for a business, which can have associated cards on file.  You must provide __at least one__ of the following values in your request to this endpoint:  - `given_name` - `family_name` - `company_name` - `email_address` - `phone_number`
     * @summary CreateCustomer
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createCustomer (body: CreateCustomerRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateCustomerRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds a card on file to an existing customer.  As with charges, calls to `CreateCustomerCard` are idempotent. Multiple calls with the same card nonce return the same card record that was created with the provided nonce during the _first_ call.
     * @summary CreateCustomerCard
     * @param customerId The Square ID of the customer profile the card is linked to.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createCustomerCard (customerId: string, body: CreateCustomerCardRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateCustomerCardResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}/cards'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling createCustomerCard.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomerCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateCustomerCardRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateCustomerCardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateCustomerCardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a customer from a business, along with any linked cards on file. When two profiles are merged into a single profile, that profile is assigned a new `customer_id`. You must use the new `customer_id` to delete merged profiles.
     * @summary DeleteCustomer
     * @param customerId The ID of the customer to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomer (customerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a card on file from a customer.
     * @summary DeleteCustomerCard
     * @param customerId The ID of the customer that the card on file belongs to.
     * @param cardId The ID of the card on file to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomerCard (customerId: string, cardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteCustomerCardResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}/cards/{card_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'card_id' + '}', encodeURIComponent(String(cardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomerCard.');
        }

        // verify required parameter 'cardId' is not null or undefined
        if (cardId === null || cardId === undefined) {
            throw new Error('Required parameter cardId was null or undefined when calling deleteCustomerCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteCustomerCardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteCustomerCardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists customer profiles associated with a Square account.  Under normal operating conditions, newly created or updated customer profiles become available  for the listing operation in well under 30 seconds. Occasionally, propagation of the new or updated  profiles can take closer to one minute or longer, espeically during network incidents and outages.
     * @summary ListCustomers
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See the [Pagination guide](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
     * @param sortField Indicates how Customers should be sorted.  Default: &#x60;DEFAULT&#x60;.
     * @param sortOrder Indicates whether Customers should be sorted in ascending (&#x60;ASC&#x60;) or descending (&#x60;DESC&#x60;) order.  Default: &#x60;ASC&#x60;.
     * @param {*} [options] Override http request options.
     */
    public listCustomers (cursor?: string, sortField?: string, sortOrder?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListCustomersResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sort_field'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a group membership from a customer.   The customer is identified by the `customer_id` value  and the customer group is identified by the `group_id` value.
     * @summary RemoveGroupFromCustomer
     * @param customerId The ID of the customer to remove from the group.
     * @param groupId The ID of the customer group to remove the customer from.
     * @param {*} [options] Override http request options.
     */
    public removeGroupFromCustomer (customerId: string, groupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RemoveGroupFromCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}/groups/{group_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeGroupFromCustomer.');
        }

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling removeGroupFromCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RemoveGroupFromCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemoveGroupFromCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns details for a single customer.
     * @summary RetrieveCustomer
     * @param customerId The ID of the customer to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveCustomer (customerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling retrieveCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches the customer profiles associated with a Square account using  one or more supported query filters.   Calling `SearchCustomers` without any explicit query filter returns all customer profiles ordered alphabetically based on `given_name` and `family_name`.  Under normal operating conditions, newly created or updated customer profiles become available  for the search operation in well under 30 seconds. Occasionally, propagation of the new or updated  profiles can take closer to one minute or longer, espeically during network incidents and outages.
     * @summary SearchCustomers
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchCustomers (body: SearchCustomersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchCustomersResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchCustomers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchCustomersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the details of an existing customer. When two profiles are merged into a single profile, that profile is assigned a new `customer_id`. You must use the new `customer_id` to update merged profiles.  You cannot edit a customer's cards on file with this endpoint. To make changes to a card on file, you must delete the existing card on file with the [DeleteCustomerCard](#endpoint-deletecustomercard) endpoint, then create a new one with the [CreateCustomerCard](#endpoint-createcustomercard) endpoint.
     * @summary UpdateCustomer
     * @param customerId The ID of the customer to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateCustomer (customerId: string, body: UpdateCustomerRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateCustomerResponse;  }> {
        const localVarPath = this.basePath + '/v2/customers/{customer_id}'
            .replace('{' + 'customer_id' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomer.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateCustomerRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateCustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateCustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DevicesApiApiKeys {
    oauth2ClientSecret,
}

export class DevicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DevicesApiApiKeys, value: string) {
        (this.authentications as any)[DevicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Creates a DeviceCode that can be used to login to a Square Terminal device to enter the connected terminal mode.
     * @summary CreateDeviceCode
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createDeviceCode (body: CreateDeviceCodeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateDeviceCodeResponse;  }> {
        const localVarPath = this.basePath + '/v2/devices/codes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDeviceCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateDeviceCodeRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateDeviceCodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateDeviceCodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves DeviceCode with the associated ID.
     * @summary GetDeviceCode
     * @param id The unique identifier for the device code.
     * @param {*} [options] Override http request options.
     */
    public getDeviceCode (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetDeviceCodeResponse;  }> {
        const localVarPath = this.basePath + '/v2/devices/codes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDeviceCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDeviceCodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDeviceCodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all DeviceCodes associated with the merchant.
     * @summary ListDeviceCodes
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
     * @param locationId If specified, only returns DeviceCodes of the specified location. Returns DeviceCodes of all locations if empty.
     * @param productType If specified, only returns DeviceCodes targeting the specified product type. Returns DeviceCodes of all product types if empty.
     * @param {*} [options] Override http request options.
     */
    public listDeviceCodes (cursor?: string, locationId?: string, productType?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListDeviceCodesResponse;  }> {
        const localVarPath = this.basePath + '/v2/devices/codes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (productType !== undefined) {
            localVarQueryParameters['product_type'] = ObjectSerializer.serialize(productType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListDeviceCodesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListDeviceCodesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DisputesApiApiKeys {
    oauth2ClientSecret,
}

export class DisputesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DisputesApiApiKeys, value: string) {
        (this.authentications as any)[DisputesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the sellerâ€™s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account. For an overview of the Disputes API, see [Overview](/docs/disputes-api/overview).
     * @summary AcceptDispute
     * @param disputeId ID of the dispute you want to accept.
     * @param {*} [options] Override http request options.
     */
    public acceptDispute (disputeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AcceptDisputeResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/accept'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling acceptDispute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AcceptDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AcceptDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Uploads text to use as evidence for a dispute challenge. For more information, see [Challenge a Dispute](/docs/disputes-api/process-disputes#challenge-a-dispute).
     * @summary CreateDisputeEvidenceText
     * @param disputeId The ID of the dispute you want to upload evidence for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createDisputeEvidenceText (disputeId: string, body: CreateDisputeEvidenceTextRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateDisputeEvidenceTextResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/evidence_text'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling createDisputeEvidenceText.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDisputeEvidenceText.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateDisputeEvidenceTextRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateDisputeEvidenceTextResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateDisputeEvidenceTextResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of evidence associated with a dispute.
     * @summary ListDisputeEvidence
     * @param disputeId The ID of the dispute.
     * @param {*} [options] Override http request options.
     */
    public listDisputeEvidence (disputeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListDisputeEvidenceResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/evidence'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling listDisputeEvidence.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListDisputeEvidenceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListDisputeEvidenceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of disputes associated with a particular account.
     * @summary ListDisputes
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
     * @param states The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
     * @param locationId The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
     * @param {*} [options] Override http request options.
     */
    public listDisputes (cursor?: string, states?: string, locationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListDisputesResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (states !== undefined) {
            localVarQueryParameters['states'] = ObjectSerializer.serialize(states, "string");
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListDisputesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListDisputesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
     * @summary RemoveDisputeEvidence
     * @param disputeId The ID of the dispute you want to remove evidence from.
     * @param evidenceId The ID of the evidence you want to remove.
     * @param {*} [options] Override http request options.
     */
    public removeDisputeEvidence (disputeId: string, evidenceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RemoveDisputeEvidenceResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/evidence/{evidence_id}'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)))
            .replace('{' + 'evidence_id' + '}', encodeURIComponent(String(evidenceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling removeDisputeEvidence.');
        }

        // verify required parameter 'evidenceId' is not null or undefined
        if (evidenceId === null || evidenceId === undefined) {
            throw new Error('Required parameter evidenceId was null or undefined when calling removeDisputeEvidence.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RemoveDisputeEvidenceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemoveDisputeEvidenceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns details of a specific dispute.
     * @summary RetrieveDispute
     * @param disputeId The ID of the dispute you want more details about.
     * @param {*} [options] Override http request options.
     */
    public retrieveDispute (disputeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveDisputeResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling retrieveDispute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
     * @summary RetrieveDisputeEvidence
     * @param disputeId The ID of the dispute that you want to retrieve evidence from.
     * @param evidenceId The ID of the evidence to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveDisputeEvidence (disputeId: string, evidenceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveDisputeEvidenceResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/evidence/{evidence_id}'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)))
            .replace('{' + 'evidence_id' + '}', encodeURIComponent(String(evidenceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling retrieveDisputeEvidence.');
        }

        // verify required parameter 'evidenceId' is not null or undefined
        if (evidenceId === null || evidenceId === undefined) {
            throw new Error('Required parameter evidenceId was null or undefined when calling retrieveDisputeEvidence.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveDisputeEvidenceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveDisputeEvidenceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Submits evidence to the cardholder's bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available. For more information, see [Challenge a Dispute](/docs/disputes-api/process-disputes#challenge-a-dispute).
     * @summary SubmitEvidence
     * @param disputeId The ID of the dispute you want to submit evidence for.
     * @param {*} [options] Override http request options.
     */
    public submitEvidence (disputeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubmitEvidenceResponse;  }> {
        const localVarPath = this.basePath + '/v2/disputes/{dispute_id}/submit-evidence'
            .replace('{' + 'dispute_id' + '}', encodeURIComponent(String(disputeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'disputeId' is not null or undefined
        if (disputeId === null || disputeId === undefined) {
            throw new Error('Required parameter disputeId was null or undefined when calling submitEvidence.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubmitEvidenceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubmitEvidenceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EmployeesApiApiKeys {
    oauth2ClientSecret,
}

export class EmployeesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EmployeesApiApiKeys, value: string) {
        (this.authentications as any)[EmployeesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary ListEmployees
     * @param locationId 
     * @param status Specifies the EmployeeStatus to filter the employee by.
     * @param limit The number of employees to be returned on each page.
     * @param cursor The token required to retrieve the specified page of results.
     * @param {*} [options] Override http request options.
     */
    public listEmployees (locationId?: string, status?: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListEmployeesResponse;  }> {
        const localVarPath = this.basePath + '/v2/employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListEmployeesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListEmployeesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary RetrieveEmployee
     * @param id UUID for the employee that was requested.
     * @param {*} [options] Override http request options.
     */
    public retrieveEmployee (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveEmployeeResponse;  }> {
        const localVarPath = this.basePath + '/v2/employees/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling retrieveEmployee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveEmployeeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveEmployeeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InventoryApiApiKeys {
    oauth2ClientSecret,
}

export class InventoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InventoryApiApiKeys, value: string) {
        (this.authentications as any)[InventoryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Applies adjustments and counts to the provided item quantities.  On success: returns the current calculated counts for all objects referenced in the request. On failure: returns a list of related errors.
     * @summary BatchChangeInventory
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchChangeInventory (body: BatchChangeInventoryRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchChangeInventoryResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/batch-change';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchChangeInventory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchChangeInventoryRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchChangeInventoryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchChangeInventoryResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns historical physical counts and adjustments based on the provided filter criteria.  Results are paginated and sorted in ascending order according their `occurred_at` timestamp (oldest first).  BatchRetrieveInventoryChanges is a catch-all query endpoint for queries that cannot be handled by other, simpler endpoints.
     * @summary BatchRetrieveInventoryChanges
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchRetrieveInventoryChanges (body: BatchRetrieveInventoryChangesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchRetrieveInventoryChangesResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/batch-retrieve-changes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchRetrieveInventoryChanges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchRetrieveInventoryChangesRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchRetrieveInventoryChangesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchRetrieveInventoryChangesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns current counts for the provided [CatalogObject](#type-catalogobject)s at the requested [Location](#type-location)s.  Results are paginated and sorted in descending order according to their `calculated_at` timestamp (newest first).  When `updated_after` is specified, only counts that have changed since that time (based on the server timestamp for the most recent change) are returned. This allows clients to perform a \"sync\" operation, for example in response to receiving a Webhook notification.
     * @summary BatchRetrieveInventoryCounts
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchRetrieveInventoryCounts (body: BatchRetrieveInventoryCountsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchRetrieveInventoryCountsResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/batch-retrieve-counts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchRetrieveInventoryCounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchRetrieveInventoryCountsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchRetrieveInventoryCountsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchRetrieveInventoryCountsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the [InventoryAdjustment](#type-inventoryadjustment) object with the provided `adjustment_id`.
     * @summary RetrieveInventoryAdjustment
     * @param adjustmentId ID of the &#x60;InventoryAdjustment&#x60; to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveInventoryAdjustment (adjustmentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveInventoryAdjustmentResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/adjustment/{adjustment_id}'
            .replace('{' + 'adjustment_id' + '}', encodeURIComponent(String(adjustmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'adjustmentId' is not null or undefined
        if (adjustmentId === null || adjustmentId === undefined) {
            throw new Error('Required parameter adjustmentId was null or undefined when calling retrieveInventoryAdjustment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveInventoryAdjustmentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveInventoryAdjustmentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a set of physical counts and inventory adjustments for the provided [CatalogObject](#type-catalogobject) at the requested [Location](#type-location)s.  Results are paginated and sorted in descending order according to their `occurred_at` timestamp (newest first).  There are no limits on how far back the caller can page. This endpoint can be  used to display recent changes for a specific item. For more sophisticated queries, use a batch endpoint.
     * @summary RetrieveInventoryChanges
     * @param catalogObjectId ID of the &#x60;CatalogObject&#x60; to retrieve.
     * @param locationIds The &#x60;Location&#x60; IDs to look up as a comma-separated list. An empty list queries all locations.
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
     * @param {*} [options] Override http request options.
     */
    public retrieveInventoryChanges (catalogObjectId: string, locationIds?: string, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveInventoryChangesResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/{catalog_object_id}/changes'
            .replace('{' + 'catalog_object_id' + '}', encodeURIComponent(String(catalogObjectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'catalogObjectId' is not null or undefined
        if (catalogObjectId === null || catalogObjectId === undefined) {
            throw new Error('Required parameter catalogObjectId was null or undefined when calling retrieveInventoryChanges.');
        }

        if (locationIds !== undefined) {
            localVarQueryParameters['location_ids'] = ObjectSerializer.serialize(locationIds, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveInventoryChangesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveInventoryChangesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the current calculated stock count for a given [CatalogObject](#type-catalogobject) at a given set of [Location](#type-location)s. Responses are paginated and unsorted. For more sophisticated queries, use a batch endpoint.
     * @summary RetrieveInventoryCount
     * @param catalogObjectId ID of the &#x60;CatalogObject&#x60; to retrieve.
     * @param locationIds The &#x60;Location&#x60; IDs to look up as a comma-separated list. An empty list queries all locations.
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See the [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination) guide for more information.
     * @param {*} [options] Override http request options.
     */
    public retrieveInventoryCount (catalogObjectId: string, locationIds?: string, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveInventoryCountResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/{catalog_object_id}'
            .replace('{' + 'catalog_object_id' + '}', encodeURIComponent(String(catalogObjectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'catalogObjectId' is not null or undefined
        if (catalogObjectId === null || catalogObjectId === undefined) {
            throw new Error('Required parameter catalogObjectId was null or undefined when calling retrieveInventoryCount.');
        }

        if (locationIds !== undefined) {
            localVarQueryParameters['location_ids'] = ObjectSerializer.serialize(locationIds, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveInventoryCountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveInventoryCountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the [InventoryPhysicalCount](#type-inventoryphysicalcount) object with the provided `physical_count_id`.
     * @summary RetrieveInventoryPhysicalCount
     * @param physicalCountId ID of the &#x60;InventoryPhysicalCount&#x60; to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveInventoryPhysicalCount (physicalCountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveInventoryPhysicalCountResponse;  }> {
        const localVarPath = this.basePath + '/v2/inventory/physical-count/{physical_count_id}'
            .replace('{' + 'physical_count_id' + '}', encodeURIComponent(String(physicalCountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'physicalCountId' is not null or undefined
        if (physicalCountId === null || physicalCountId === undefined) {
            throw new Error('Required parameter physicalCountId was null or undefined when calling retrieveInventoryPhysicalCount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveInventoryPhysicalCountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveInventoryPhysicalCountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
    oauth2ClientSecret,
}

export class InvoicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        (this.authentications as any)[InvoicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Cancels an invoice. The seller cannot collect payments for  the canceled invoice.  You cannot cancel an invoice in a terminal state: `PAID`, `REFUNDED`, `CANCELED`, or `FAILED`.
     * @summary CancelInvoice
     * @param invoiceId The ID of the &#x60;invoice&#x60; to cancel.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public cancelInvoice (invoiceId: string, body: CancelInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/{invoice_id}/cancel'
            .replace('{' + 'invoice_id' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling cancelInvoice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cancelInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CancelInvoiceRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a draft [invoice](#type-invoice)  for an order created using the Orders API.  A draft invoice remains in your account and no action is taken.  You must publish the invoice before Square can process it (send it to the customer's email address or charge the customerâ€™s card on file).  For more information, see [Manage Invoices Using the Invoices API](/docs/invoices-api/overview).
     * @summary CreateInvoice
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createInvoice (body: CreateInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateInvoiceRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the specified invoice. When an invoice is deleted, the  associated Order status changes to CANCELED. You can only delete a draft  invoice (you cannot delete an invoice scheduled for publication, or a  published invoice).
     * @summary DeleteInvoice
     * @param invoiceId The ID of the invoice to delete.
     * @param version The version of the &#x60;invoice&#x60; to delete. If you do not know the version, you can call &#x60;GetInvoice&#x60; or  &#x60;ListInvoices&#x60;.
     * @param {*} [options] Override http request options.
     */
    public deleteInvoice (invoiceId: string, version?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/{invoice_id}'
            .replace('{' + 'invoice_id' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling deleteInvoice.');
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves an invoice by invoice ID.
     * @summary GetInvoice
     * @param invoiceId The id of the invoice to retrieve.
     * @param {*} [options] Override http request options.
     */
    public getInvoice (invoiceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/{invoice_id}'
            .replace('{' + 'invoice_id' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling getInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of invoices for a given location. The response  is paginated. If truncated, the response includes a `cursor` that you     use in a subsequent request to fetch the next set of invoices. For more information about retrieving invoices, see [Retrieve invoices](/docs/invoices-api/overview#retrieve-invoices).
     * @summary ListInvoices
     * @param locationId The ID of the location for which to list invoices.
     * @param cursor A pagination cursor returned by a previous call to this endpoint.  Provide this cursor to retrieve the next set of results for your original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
     * @param limit The maximum number of invoices to return (200 is the maximum &#x60;limit&#x60;).  If not provided, the server  uses a default limit of 100 invoices.
     * @param {*} [options] Override http request options.
     */
    public listInvoices (locationId: string, cursor?: string, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListInvoicesResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listInvoices.');
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListInvoicesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListInvoicesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the specified draft invoice.   After an invoice is published, Square  follows up based on the invoice configuration. For example, Square  sends the invoice to the customer's email address, charges the customer's card on file, or does  nothing. Square also makes the invoice available on a Square-hosted invoice page.   The invoice `status` also changes from `DRAFT` to a status  based on the invoice configuration. For example, the status changes to `UNPAID` if  Square emails the invoice or `PARTIALLY_PAID` if Square charge a card on file for a portion of the  invoice amount).  For more information, see  [Create and publish an invoice](/docs/invoices-api/overview#create-and-publish-an-invoice).
     * @summary PublishInvoice
     * @param invoiceId The id of the invoice to publish.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public publishInvoice (invoiceId: string, body: PublishInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PublishInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/{invoice_id}/publish'
            .replace('{' + 'invoice_id' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling publishInvoice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling publishInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PublishInvoiceRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PublishInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PublishInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for invoices from a location specified in  the filter. You can optionally specify customers in the filter for whom to  retrieve invoices. In the current implementation, you can only specify one location and  optionally one customer.  The response is paginated. If truncated, the response includes a `cursor`  that you use in a subsequent request to fetch the next set of invoices.  For more information about retrieving invoices, see [Retrieve invoices](/docs/invoices-api/overview#retrieve-invoices).
     * @summary SearchInvoices
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchInvoices (body: SearchInvoicesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchInvoicesResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchInvoices.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchInvoicesRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchInvoicesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchInvoicesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an invoice by modifying field values, clearing field values, or both  as specified in the request.  There are no restrictions to updating an invoice in a draft state.  However, there are guidelines for updating a published invoice.  For more information, see [Update an invoice](/docs/invoices-api/overview#update-an-invoice).
     * @summary UpdateInvoice
     * @param invoiceId The id of the invoice to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateInvoice (invoiceId: string, body: UpdateInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateInvoiceResponse;  }> {
        const localVarPath = this.basePath + '/v2/invoices/{invoice_id}'
            .replace('{' + 'invoice_id' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling updateInvoice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateInvoiceRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateInvoiceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateInvoiceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LaborApiApiKeys {
    oauth2ClientSecret,
}

export class LaborApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LaborApiApiKeys, value: string) {
        (this.authentications as any)[LaborApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Creates a new `BreakType`.  A `BreakType` is a template for creating `Break` objects. You must provide the following values in your request to this endpoint:  - `location_id` - `break_name` - `expected_duration` - `is_paid`  You can only have 3 `BreakType` instances per location. If you attempt to add a 4th `BreakType` for a location, an `INVALID_REQUEST_ERROR` \"Exceeded limit of 3 breaks per location.\" is returned.
     * @summary CreateBreakType
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createBreakType (body: CreateBreakTypeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateBreakTypeResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/break-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createBreakType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateBreakTypeRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateBreakTypeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateBreakTypeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new `Shift`.  A `Shift` represents a complete work day for a single employee. You must provide the following values in your request to this endpoint:  - `location_id` - `employee_id` - `start_at`  An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when: - The `status` of the new `Shift` is `OPEN` and the employee has another shift with an `OPEN` status. - The `start_at` date is in the future - the `start_at` or `end_at` overlaps another shift for the same employee - If `Break`s are set in the request, a break `start_at` must not be before the `Shift.start_at`. A break `end_at` must not be after the `Shift.end_at`
     * @summary CreateShift
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createShift (body: CreateShiftRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateShiftResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/shifts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createShift.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateShiftRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateShiftResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateShiftResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing `BreakType`.  A `BreakType` can be deleted even if it is referenced from a `Shift`.
     * @summary DeleteBreakType
     * @param id UUID for the &#x60;BreakType&#x60; being deleted.
     * @param {*} [options] Override http request options.
     */
    public deleteBreakType (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteBreakTypeResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/break-types/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBreakType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteBreakTypeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteBreakTypeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a `Shift`.
     * @summary DeleteShift
     * @param id UUID for the &#x60;Shift&#x60; being deleted.
     * @param {*} [options] Override http request options.
     */
    public deleteShift (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteShiftResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/shifts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteShift.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteShiftResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteShiftResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single `BreakType` specified by id.
     * @summary GetBreakType
     * @param id UUID for the &#x60;BreakType&#x60; being retrieved.
     * @param {*} [options] Override http request options.
     */
    public getBreakType (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetBreakTypeResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/break-types/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBreakType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetBreakTypeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetBreakTypeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single `EmployeeWage` specified by id.
     * @summary GetEmployeeWage
     * @param id UUID for the &#x60;EmployeeWage&#x60; being retrieved.
     * @param {*} [options] Override http request options.
     */
    public getEmployeeWage (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetEmployeeWageResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/employee-wages/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEmployeeWage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetEmployeeWageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmployeeWageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single `Shift` specified by id.
     * @summary GetShift
     * @param id UUID for the &#x60;Shift&#x60; being retrieved.
     * @param {*} [options] Override http request options.
     */
    public getShift (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetShiftResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/shifts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShift.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetShiftResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetShiftResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single `TeamMemberWage` specified by id.
     * @summary GetTeamMemberWage
     * @param id UUID for the &#x60;TeamMemberWage&#x60; being retrieved.
     * @param {*} [options] Override http request options.
     */
    public getTeamMemberWage (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetTeamMemberWageResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/team-member-wages/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeamMemberWage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTeamMemberWageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTeamMemberWageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of `BreakType` instances for a business.
     * @summary ListBreakTypes
     * @param locationId Filter Break Types returned to only those that are associated with the specified location.
     * @param limit Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param cursor Pointer to the next page of Break Type results to fetch.
     * @param {*} [options] Override http request options.
     */
    public listBreakTypes (locationId?: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListBreakTypesResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/break-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListBreakTypesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListBreakTypesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of `EmployeeWage` instances for a business.
     * @summary ListEmployeeWages
     * @param employeeId Filter wages returned to only those that are associated with the specified employee.
     * @param limit Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param cursor Pointer to the next page of Employee Wage results to fetch.
     * @param {*} [options] Override http request options.
     */
    public listEmployeeWages (employeeId?: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListEmployeeWagesResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/employee-wages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (employeeId !== undefined) {
            localVarQueryParameters['employee_id'] = ObjectSerializer.serialize(employeeId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListEmployeeWagesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListEmployeeWagesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of `TeamMemberWage` instances for a business.
     * @summary ListTeamMemberWages
     * @param teamMemberId Filter wages returned to only those that are associated with the specified team member.
     * @param limit Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param cursor Pointer to the next page of Employee Wage results to fetch.
     * @param {*} [options] Override http request options.
     */
    public listTeamMemberWages (teamMemberId?: string, limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListTeamMemberWagesResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/team-member-wages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (teamMemberId !== undefined) {
            localVarQueryParameters['team_member_id'] = ObjectSerializer.serialize(teamMemberId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListTeamMemberWagesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListTeamMemberWagesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of `WorkweekConfig` instances for a business.
     * @summary ListWorkweekConfigs
     * @param limit Maximum number of Workweek Configs to return per page.
     * @param cursor Pointer to the next page of Workweek Config results to fetch.
     * @param {*} [options] Override http request options.
     */
    public listWorkweekConfigs (limit?: number, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListWorkweekConfigsResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/workweek-configs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListWorkweekConfigsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListWorkweekConfigsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of `Shift` records for a business. The list to be returned can be filtered by: - Location IDs **and** - employee IDs **and** - shift status (`OPEN`, `CLOSED`) **and** - shift start **and** - shift end **and** - work day details  The list can be sorted by: - `start_at` - `end_at` - `created_at` - `updated_at`
     * @summary SearchShifts
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchShifts (body: SearchShiftsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchShiftsResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/shifts/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchShifts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchShiftsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchShiftsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchShiftsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an existing `BreakType`.
     * @summary UpdateBreakType
     * @param id UUID for the &#x60;BreakType&#x60; being updated.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateBreakType (id: string, body: UpdateBreakTypeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateBreakTypeResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/break-types/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBreakType.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateBreakType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateBreakTypeRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateBreakTypeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateBreakTypeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an existing `Shift`.  When adding a `Break` to a `Shift`, any earlier `Breaks` in the `Shift` have the `end_at` property set to a valid RFC-3339 datetime string.  When closing a `Shift`, all `Break` instances in the shift must be complete with `end_at` set on each `Break`.
     * @summary UpdateShift
     * @param id ID of the object being updated.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateShift (id: string, body: UpdateShiftRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateShiftResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/shifts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShift.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateShift.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateShiftRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateShiftResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateShiftResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a `WorkweekConfig`.
     * @summary UpdateWorkweekConfig
     * @param id UUID for the &#x60;WorkweekConfig&#x60; object being updated.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateWorkweekConfig (id: string, body: UpdateWorkweekConfigRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateWorkweekConfigResponse;  }> {
        const localVarPath = this.basePath + '/v2/labor/workweek-configs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateWorkweekConfig.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateWorkweekConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateWorkweekConfigRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateWorkweekConfigResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateWorkweekConfigResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationsApiApiKeys {
    oauth2ClientSecret,
}

export class LocationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationsApiApiKeys, value: string) {
        (this.authentications as any)[LocationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Creates a location. For more information about locations, see [Locations API Overview](/locations-api).
     * @summary CreateLocation
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createLocation (body: CreateLocationRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateLocationResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateLocationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateLocationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateLocationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides information of all locations of a business.  Most other Connect API endpoints have a required `location_id` path parameter. The `id` field of the [`Location`](#type-location) objects returned by this endpoint correspond to that `location_id` parameter.
     * @summary ListLocations
     * @param {*} [options] Override http request options.
     */
    public listLocations (options: any = {}) : Promise<{ response: http.ClientResponse; body: ListLocationsResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListLocationsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListLocationsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves details of a location. You can specify \"main\"  as the location ID to retrieve details of the  main location. For more information,  see [Locations API Overview](/docs/locations-api).
     * @summary RetrieveLocation
     * @param locationId The ID of the location to retrieve. If you specify the string \&quot;main\&quot;, then the endpoint returns the main location.
     * @param {*} [options] Override http request options.
     */
    public retrieveLocation (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveLocationResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveLocationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveLocationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a location.
     * @summary UpdateLocation
     * @param locationId The ID of the location to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateLocation (locationId: string, body: UpdateLocationRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateLocationResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateLocationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateLocationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateLocationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoyaltyApiApiKeys {
    oauth2ClientSecret,
}

export class LoyaltyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoyaltyApiApiKeys, value: string) {
        (this.authentications as any)[LoyaltyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Adds points to a loyalty account.  - If you are using the Orders API to manage orders, you only provide the `order_id`.  The endpoint reads the order to compute points to add to the buyer's account. - If you are not using the Orders API to manage orders,  you first perform a client-side computation to compute the points.   For spend-based and visit-based programs, you can call  `CalculateLoyaltyPoints` to compute the points. For more information,  see [Loyalty Program Overview](/docs/loyalty/overview).  You then provide the points in a request to this endpoint.   For more information, see [Accumulate points](/docs/loyalty-api/overview/#accumulate-points).
     * @summary AccumulateLoyaltyPoints
     * @param accountId The &#x60;loyalty account&#x60; ID to which to add the points.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public accumulateLoyaltyPoints (accountId: string, body: AccumulateLoyaltyPointsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AccumulateLoyaltyPointsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/accounts/{account_id}/accumulate'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accumulateLoyaltyPoints.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accumulateLoyaltyPoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AccumulateLoyaltyPointsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccumulateLoyaltyPointsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccumulateLoyaltyPointsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds points to or subtracts points from a buyer's account.   Use this endpoint only when you need to manually adjust points. Otherwise, in your application flow, you call  [AccumulateLoyaltyPoints](/reference/square/loyalty-api/accumulate-loyalty-points)  to add points when a buyer pays for the purchase.
     * @summary AdjustLoyaltyPoints
     * @param accountId The ID of the &#x60;loyalty account&#x60; in which to adjust the points.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public adjustLoyaltyPoints (accountId: string, body: AdjustLoyaltyPointsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdjustLoyaltyPointsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/accounts/{account_id}/adjust'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling adjustLoyaltyPoints.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling adjustLoyaltyPoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdjustLoyaltyPointsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdjustLoyaltyPointsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdjustLoyaltyPointsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculates the points a purchase earns.  - If you are using the Orders API to manage orders, you provide `order_id` in the request. The  endpoint calculates the points by reading the order. - If you are not using the Orders API to manage orders, you provide the purchase amount in  the request for the endpoint to calculate the points.  An application might call this endpoint to show the points that a buyer can earn with the  specific purchase.
     * @summary CalculateLoyaltyPoints
     * @param programId The &#x60;loyalty program&#x60; ID, which defines the rules for accruing points.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public calculateLoyaltyPoints (programId: string, body: CalculateLoyaltyPointsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CalculateLoyaltyPointsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/programs/{program_id}/calculate'
            .replace('{' + 'program_id' + '}', encodeURIComponent(String(programId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'programId' is not null or undefined
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling calculateLoyaltyPoints.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculateLoyaltyPoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CalculateLoyaltyPointsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CalculateLoyaltyPointsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CalculateLoyaltyPointsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a loyalty account. For more information, see  [Create a loyalty account](/docs/loyalty-api/overview/#loyalty-overview-create-account).
     * @summary CreateLoyaltyAccount
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createLoyaltyAccount (body: CreateLoyaltyAccountRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateLoyaltyAccountResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLoyaltyAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateLoyaltyAccountRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateLoyaltyAccountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateLoyaltyAccountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a loyalty reward. In the process, the endpoint does following:  - Uses the `reward_tier_id` in the request to determine the number of points  to lock for this reward.  - If the request includes `order_id`, it adds the reward and related discount to the order.   After a reward is created, the points are locked and  not available for the buyer to redeem another reward.  For more information, see  [Loyalty rewards](/docs/loyalty-api/overview/#loyalty-overview-loyalty-rewards).
     * @summary CreateLoyaltyReward
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createLoyaltyReward (body: CreateLoyaltyRewardRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateLoyaltyRewardResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/rewards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLoyaltyReward.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateLoyaltyRewardRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateLoyaltyRewardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateLoyaltyRewardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a loyalty reward by doing the following:  - Returns the loyalty points back to the loyalty account. - If an order ID was specified when the reward was created  (see [CreateLoyaltyReward](/reference/square/loyalty-api/create-loyalty-reward)),  it updates the order by removing the reward and related  discounts.  You cannot delete a reward that has reached the terminal state (REDEEMED).  For more information, see  [Loyalty rewards](/docs/loyalty-api/overview/#loyalty-overview-loyalty-rewards).
     * @summary DeleteLoyaltyReward
     * @param rewardId The ID of the &#x60;loyalty reward&#x60; to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteLoyaltyReward (rewardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteLoyaltyRewardResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/rewards/{reward_id}'
            .replace('{' + 'reward_id' + '}', encodeURIComponent(String(rewardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rewardId' is not null or undefined
        if (rewardId === null || rewardId === undefined) {
            throw new Error('Required parameter rewardId was null or undefined when calling deleteLoyaltyReward.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteLoyaltyRewardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteLoyaltyRewardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of loyalty programs in the seller's account. Currently, a seller can only have one loyalty program. For more information, see  [Loyalty Overview](/docs/loyalty/overview). .
     * @summary ListLoyaltyPrograms
     * @param {*} [options] Override http request options.
     */
    public listLoyaltyPrograms (options: any = {}) : Promise<{ response: http.ClientResponse; body: ListLoyaltyProgramsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/programs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListLoyaltyProgramsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListLoyaltyProgramsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Redeems a loyalty reward.  The endpoint sets the reward to the terminal state (`REDEEMED`).   If you are using your own order processing system (not using the  Orders API), you call this endpoint after the buyer paid for the  purchase.  After the reward reaches the terminal state, it cannot be deleted.  In other words, points used for the reward cannot be returned  to the account.  For more information, see  [Loyalty rewards](/docs/loyalty-api/overview/#loyalty-overview-loyalty-rewards).
     * @summary RedeemLoyaltyReward
     * @param rewardId The ID of the &#x60;loyalty reward&#x60; to redeem.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public redeemLoyaltyReward (rewardId: string, body: RedeemLoyaltyRewardRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RedeemLoyaltyRewardResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/rewards/{reward_id}/redeem'
            .replace('{' + 'reward_id' + '}', encodeURIComponent(String(rewardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rewardId' is not null or undefined
        if (rewardId === null || rewardId === undefined) {
            throw new Error('Required parameter rewardId was null or undefined when calling redeemLoyaltyReward.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling redeemLoyaltyReward.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RedeemLoyaltyRewardRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RedeemLoyaltyRewardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RedeemLoyaltyRewardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a loyalty account.
     * @summary RetrieveLoyaltyAccount
     * @param accountId The ID of the &#x60;loyalty account&#x60; to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveLoyaltyAccount (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveLoyaltyAccountResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/accounts/{account_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling retrieveLoyaltyAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveLoyaltyAccountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveLoyaltyAccountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a loyalty reward.
     * @summary RetrieveLoyaltyReward
     * @param rewardId The ID of the &#x60;loyalty reward&#x60; to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveLoyaltyReward (rewardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveLoyaltyRewardResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/rewards/{reward_id}'
            .replace('{' + 'reward_id' + '}', encodeURIComponent(String(rewardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'rewardId' is not null or undefined
        if (rewardId === null || rewardId === undefined) {
            throw new Error('Required parameter rewardId was null or undefined when calling retrieveLoyaltyReward.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveLoyaltyRewardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveLoyaltyRewardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for loyalty accounts.  In the current implementation, you can search for a loyalty account using the phone number associated with the account.  If no phone number is provided, all loyalty accounts are returned.
     * @summary SearchLoyaltyAccounts
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchLoyaltyAccounts (body: SearchLoyaltyAccountsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchLoyaltyAccountsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/accounts/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchLoyaltyAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchLoyaltyAccountsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchLoyaltyAccountsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchLoyaltyAccountsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for loyalty events.  A Square loyalty program maintains a ledger of events that occur during the lifetime of a  buyer's loyalty account. Each change in the point balance  (for example, points earned, points redeemed, and points expired) is  recorded in the ledger. Using this endpoint, you can search the ledger for events.  For more information, see  [Loyalty events](/docs/loyalty-api/overview/#loyalty-events).
     * @summary SearchLoyaltyEvents
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchLoyaltyEvents (body: SearchLoyaltyEventsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchLoyaltyEventsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/events/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchLoyaltyEvents.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchLoyaltyEventsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchLoyaltyEventsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchLoyaltyEventsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for loyalty rewards in a loyalty account.   In the current implementation, the endpoint supports search by the reward `status`.  If you know a reward ID, use the  [RetrieveLoyaltyReward](/reference/square/loyalty-api/retrieve-loyalty-reward) endpoint.  For more information about loyalty rewards, see  [Loyalty Rewards](/docs/loyalty-api/overview/#loyalty-rewards).
     * @summary SearchLoyaltyRewards
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchLoyaltyRewards (body: SearchLoyaltyRewardsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchLoyaltyRewardsResponse;  }> {
        const localVarPath = this.basePath + '/v2/loyalty/rewards/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchLoyaltyRewards.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchLoyaltyRewardsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchLoyaltyRewardsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchLoyaltyRewardsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantsApiApiKeys {
    oauth2ClientSecret,
}

export class MerchantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantsApiApiKeys, value: string) {
        (this.authentications as any)[MerchantsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Returns `Merchant` information for a given access token.  If you don't know a `Merchant` ID, you can use this endpoint to retrieve the merchant ID for an access token. You can specify your personal access token to get your own merchant information or specify an OAuth token to get the information for the  merchant that granted you access.  If you know the merchant ID, you can also use the [RetrieveMerchant](#endpoint-merchants-retrievemerchant) endpoint to get the merchant information.
     * @summary ListMerchants
     * @param cursor The cursor generated by the previous response.
     * @param {*} [options] Override http request options.
     */
    public listMerchants (cursor?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListMerchantsResponse;  }> {
        const localVarPath = this.basePath + '/v2/merchants';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListMerchantsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListMerchantsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a `Merchant` object for the given `merchant_id`.
     * @summary RetrieveMerchant
     * @param merchantId The ID of the merchant to retrieve. If the string \&quot;me\&quot; is supplied as the ID, then retrieve the merchant that is currently accessible to this call.
     * @param {*} [options] Override http request options.
     */
    public retrieveMerchant (merchantId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveMerchantResponse;  }> {
        const localVarPath = this.basePath + '/v2/merchants/{merchant_id}'
            .replace('{' + 'merchant_id' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling retrieveMerchant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveMerchantResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveMerchantResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MobileAuthorizationApiApiKeys {
    oauth2ClientSecret,
}

export class MobileAuthorizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MobileAuthorizationApiApiKeys, value: string) {
        (this.authentications as any)[MobileAuthorizationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Generates code to authorize a mobile application to connect to a Square card reader  Authorization codes are one-time-use and expire __60 minutes__ after being issued.  __Important:__ The `Authorization` header you provide to this endpoint must have the following format:  ``` Authorization: Bearer ACCESS_TOKEN ```  Replace `ACCESS_TOKEN` with a [valid production authorization credential](/docs/build-basics/access-tokens).
     * @summary CreateMobileAuthorizationCode
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createMobileAuthorizationCode (body: CreateMobileAuthorizationCodeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateMobileAuthorizationCodeResponse;  }> {
        const localVarPath = this.basePath + '/mobile/authorization-code';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createMobileAuthorizationCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateMobileAuthorizationCodeRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateMobileAuthorizationCodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateMobileAuthorizationCodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthApiApiKeys {
    oauth2ClientSecret,
}

export class OAuthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthApiApiKeys, value: string) {
        (this.authentications as any)[OAuthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Returns an OAuth access token.  The endpoint supports distinct methods of obtaining OAuth access tokens. Applications specify a method by adding the `grant_type` parameter in the request and also provide relevant information. For more information, see [OAuth access token management](/authz/oauth/how-it-works#oauth-access-token-management).  __Note:__ Regardless of the method application specified, the endpoint always returns two items; an OAuth access token and a refresh token in the response.  __OAuth tokens should only live on secure servers. Application clients should never interact directly with OAuth tokens__.
     * @summary ObtainToken
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public obtainToken (body: ObtainTokenRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ObtainTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth2/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling obtainToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObtainTokenRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ObtainTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObtainTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * `RenewToken` is deprecated. For information about refreshing OAuth access tokens, see [Renew OAuth Token](https://developer.squareup.com/docs/oauth-api/cookbook/renew-oauth-tokens).   Renews an OAuth access token before it expires.  OAuth access tokens besides your application's personal access token expire after __30 days__. You can also renew expired tokens within __15 days__ of their expiration. You cannot renew an access token that has been expired for more than 15 days. Instead, the associated user must re-complete the OAuth flow from the beginning.  __Important:__ The `Authorization` header for this endpoint must have the following format:  ``` Authorization: Client APPLICATION_SECRET ```  Replace `APPLICATION_SECRET` with the application secret on the Credentials page in the [application dashboard](https://connect.squareup.com/apps).
     * @summary RenewToken
     * @param clientId Your application ID, available from the [application dashboard](https://connect.squareup.com/apps).
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public renewToken (clientId: string, body: RenewTokenRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RenewTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth2/clients/{client_id}/access-token/renew'
            .replace('{' + 'client_id' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling renewToken.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling renewToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RenewTokenRequest")
        };

        this.authentications.oauth2ClientSecret.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RenewTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RenewTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes an access token generated with the OAuth flow.  If an account has more than one OAuth access token for your application, this endpoint revokes all of them, regardless of which token you specify. When an OAuth access token is revoked, all of the active subscriptions associated with that OAuth token are canceled immediately.  __Important:__ The `Authorization` header for this endpoint must have the following format:  ``` Authorization: Client APPLICATION_SECRET ```  Replace `APPLICATION_SECRET` with the application secret on the Credentials page in the [application dashboard](https://connect.squareup.com/apps).
     * @summary RevokeToken
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public revokeToken (body: RevokeTokenRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RevokeTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth2/revoke';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RevokeTokenRequest")
        };

        this.authentications.oauth2ClientSecret.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevokeTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevokeTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
    oauth2ClientSecret,
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Retrieves a set of [Order](#type-order)s by their IDs.  If a given Order ID does not exist, the ID is ignored instead of generating an error.
     * @summary BatchRetrieveOrders
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public batchRetrieveOrders (body: BatchRetrieveOrdersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BatchRetrieveOrdersResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders/batch-retrieve';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling batchRetrieveOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BatchRetrieveOrdersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BatchRetrieveOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BatchRetrieveOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculates an [Order](#type-order).
     * @summary CalculateOrder
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public calculateOrder (body: CalculateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CalculateOrderResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders/calculate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculateOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CalculateOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CalculateOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CalculateOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new [Order](#type-order) which can include information on products for purchase and settings to apply to the purchase.  To pay for a created order, please refer to the [Pay for Orders](/orders-api/pay-for-orders) guide.  You can modify open orders using the [UpdateOrder](#endpoint-orders-updateorder) endpoint.  To learn more about the Orders API, see the [Orders API Overview](/orders-api/what-it-does).
     * @summary CreateOrder
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createOrder (body: CreateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateOrderResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Pay for an [order](#type-order) using one or more approved [payments](#type-payment), or settle an order with a total of `0`.  The total of the `payment_ids` listed in the request must be equal to the order total. Orders with a total amount of `0` can be marked as paid by specifying an empty array of `payment_ids` in the request.  To be used with PayOrder, a payment must:  - Reference the order by specifying the `order_id` when [creating the payment](#endpoint-payments-createpayment). Any approved payments that reference the same `order_id` not specified in the `payment_ids` will be canceled. - Be approved with [delayed capture](/payments-api/take-payments#delayed-capture). Using a delayed capture payment with PayOrder will complete the approved payment.  Learn how to [pay for orders with a single payment using the Payments API](/orders-api/pay-for-orders).
     * @summary PayOrder
     * @param orderId The ID of the order being paid.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public payOrder (orderId: string, body: PayOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PayOrderResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders/{order_id}/pay'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling payOrder.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling payOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PayOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PayOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PayOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search all orders for one or more locations. Orders include all sales, returns, and exchanges regardless of how or when they entered the Square Ecosystem (e.g. Point of Sale, Invoices, Connect APIs, etc).  SearchOrders requests need to specify which locations to search and define a [`SearchOrdersQuery`](#type-searchordersquery) object which controls how to sort or filter the results. Your SearchOrdersQuery can:    Set filter criteria.   Set sort order.   Determine whether to return results as complete Order objects, or as [OrderEntry](#type-orderentry) objects.  Note that details for orders processed with Square Point of Sale while in offline mode may not be transmitted to Square for up to 72 hours. Offline orders have a `created_at` value that reflects the time the order was created, not the time it was subsequently transmitted to Square.
     * @summary SearchOrders
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchOrders (body: SearchOrdersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchOrdersResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchOrdersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an open [Order](#type-order) by adding, replacing, or deleting fields. Orders with a `COMPLETED` or `CANCELED` state cannot be updated.  An UpdateOrder request requires the following:  - The `order_id` in the endpoint path, identifying the order to update. - The latest `version` of the order to update. - The [sparse order](/orders-api/manage-orders#sparse-order-objects) containing only the fields to update and the version the update is being applied to. - If deleting fields, the [dot notation paths](/orders-api/manage-orders#on-dot-notation) identifying fields to clear.  To pay for an order, please refer to the [Pay for Orders](/orders-api/pay-for-orders) guide.  To learn more about the Orders API, see the [Orders API Overview](/orders-api/what-it-does).
     * @summary UpdateOrder
     * @param orderId The ID of the order to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateOrder (orderId: string, body: UpdateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateOrderResponse;  }> {
        const localVarPath = this.basePath + '/v2/orders/{order_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
    oauth2ClientSecret,
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Cancels (voids) a payment. If you set `autocomplete` to false when creating a payment,  you can cancel the payment using this endpoint. For more information, see  [Delayed Payments](/payments-api/take-payments#delayed-payments).
     * @summary CancelPayment
     * @param paymentId &#x60;payment_id&#x60; identifying the payment to be canceled.
     * @param {*} [options] Override http request options.
     */
    public cancelPayment (paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelPaymentResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments/{payment_id}/cancel'
            .replace('{' + 'payment_id' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling cancelPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelPaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelPaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancels (voids) a payment identified by the idempotency key that is specified in the request.  Use this method when status of a CreatePayment request is unknown. For example, after you send a CreatePayment request a network error occurs and you don't get a response. In this case, you can direct Square to cancel the payment using this endpoint. In the request, you provide the same idempotency key that you provided in your CreatePayment request you want  to cancel. After cancelling the payment, you can submit your CreatePayment request again.  Note that if no payment with the specified idempotency key is found, no action is taken, the end point returns successfully.
     * @summary CancelPaymentByIdempotencyKey
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public cancelPaymentByIdempotencyKey (body: CancelPaymentByIdempotencyKeyRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelPaymentByIdempotencyKeyResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments/cancel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cancelPaymentByIdempotencyKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CancelPaymentByIdempotencyKeyRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelPaymentByIdempotencyKeyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelPaymentByIdempotencyKeyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Completes (captures) a payment.  By default, payments are set to complete immediately after they are created.  If you set autocomplete to false when creating a payment, you can complete (capture)  the payment using this endpoint. For more information, see [Delayed Payments](/payments-api/take-payments#delayed-payments).
     * @summary CompletePayment
     * @param paymentId Unique ID identifying the payment to be completed.
     * @param {*} [options] Override http request options.
     */
    public completePayment (paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CompletePaymentResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments/{payment_id}/complete'
            .replace('{' + 'payment_id' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling completePayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CompletePaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CompletePaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Charges a payment source, for example, a card  represented by customer's card on file or a card nonce. In addition  to the payment source, the request must also include the  amount to accept for the payment.  There are several optional parameters that you can include in the request.  For example, tip money, whether to autocomplete the payment, or a reference ID to correlate this payment with another system.  For more information about these  payment options, see [Take Payments](/payments-api/take-payments).  The `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required to enable application fees.
     * @summary CreatePayment
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createPayment (body: CreatePaymentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreatePaymentResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreatePaymentRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatePaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatePaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves details for a specific Payment.
     * @summary GetPayment
     * @param paymentId Unique ID for the desired &#x60;Payment&#x60;.
     * @param {*} [options] Override http request options.
     */
    public getPayment (paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetPaymentResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments/{payment_id}'
            .replace('{' + 'payment_id' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling getPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetPaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetPaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of payments taken by the account making the request.  Max results per page: 100
     * @summary ListPayments
     * @param beginTime Timestamp for the beginning of the reporting period, in RFC 3339 format. Inclusive. Default: The current time minus one year.
     * @param endTime Timestamp for the end of the requested reporting period, in RFC 3339 format.  Default: The current time.
     * @param sortOrder The order in which results are listed. - &#x60;ASC&#x60; - oldest to newest - &#x60;DESC&#x60; - newest to oldest (default).
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
     * @param locationId Limit results to the location supplied. By default, results are returned for all locations associated with the merchant.
     * @param total The exact amount in the total_money for a &#x60;Payment&#x60;.
     * @param last4 The last 4 digits of &#x60;Payment&#x60; card.
     * @param cardBrand The brand of &#x60;Payment&#x60; card. For example, &#x60;VISA&#x60;
     * @param {*} [options] Override http request options.
     */
    public listPayments (beginTime?: string, endTime?: string, sortOrder?: string, cursor?: string, locationId?: string, total?: number, last4?: string, cardBrand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListPaymentsResponse;  }> {
        const localVarPath = this.basePath + '/v2/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (total !== undefined) {
            localVarQueryParameters['total'] = ObjectSerializer.serialize(total, "number");
        }

        if (last4 !== undefined) {
            localVarQueryParameters['last_4'] = ObjectSerializer.serialize(last4, "string");
        }

        if (cardBrand !== undefined) {
            localVarQueryParameters['card_brand'] = ObjectSerializer.serialize(cardBrand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPaymentsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListPaymentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RefundsApiApiKeys {
    oauth2ClientSecret,
}

export class RefundsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RefundsApiApiKeys, value: string) {
        (this.authentications as any)[RefundsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Retrieves a specific `Refund` using the `refund_id`.
     * @summary GetPaymentRefund
     * @param refundId Unique ID for the desired &#x60;PaymentRefund&#x60;.
     * @param {*} [options] Override http request options.
     */
    public getPaymentRefund (refundId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetPaymentRefundResponse;  }> {
        const localVarPath = this.basePath + '/v2/refunds/{refund_id}'
            .replace('{' + 'refund_id' + '}', encodeURIComponent(String(refundId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'refundId' is not null or undefined
        if (refundId === null || refundId === undefined) {
            throw new Error('Required parameter refundId was null or undefined when calling getPaymentRefund.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetPaymentRefundResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetPaymentRefundResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of refunds for the account making the request.  Max results per page: 100
     * @summary ListPaymentRefunds
     * @param beginTime Timestamp for the beginning of the requested reporting period, in RFC 3339 format.  Default: The current time minus one year.
     * @param endTime Timestamp for the end of the requested reporting period, in RFC 3339 format.  Default: The current time.
     * @param sortOrder The order in which results are listed. - &#x60;ASC&#x60; - oldest to newest - &#x60;DESC&#x60; - newest to oldest (default).
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
     * @param locationId Limit results to the location supplied. By default, results are returned for all locations associated with the merchant.
     * @param status If provided, only refunds with the given status are returned. For a list of refund status values, see &#x60;PaymentRefund&#x60;.  Default: If omitted refunds are returned regardless of status.
     * @param sourceType If provided, only refunds with the given source type are returned. - &#x60;CARD&#x60; - List refunds only for payments where card was specified as payment source.  Default: If omitted refunds are returned regardless of source type.
     * @param {*} [options] Override http request options.
     */
    public listPaymentRefunds (beginTime?: string, endTime?: string, sortOrder?: string, cursor?: string, locationId?: string, status?: string, sourceType?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListPaymentRefundsResponse;  }> {
        const localVarPath = this.basePath + '/v2/refunds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (locationId !== undefined) {
            localVarQueryParameters['location_id'] = ObjectSerializer.serialize(locationId, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (sourceType !== undefined) {
            localVarQueryParameters['source_type'] = ObjectSerializer.serialize(sourceType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPaymentRefundsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListPaymentRefundsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refunds a payment. You can refund the entire payment amount or a  portion of it. For more information, see  [Payments and Refunds Overview](/payments-api/overview).
     * @summary RefundPayment
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public refundPayment (body: RefundPaymentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RefundPaymentResponse;  }> {
        const localVarPath = this.basePath + '/v2/refunds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling refundPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RefundPaymentRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefundPaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefundPaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsApiApiKeys {
    oauth2ClientSecret,
}

export class SubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Sets the `canceled_date` field to the end of the active billing period. After this date, the status changes from ACTIVE to CANCELED.
     * @summary CancelSubscription
     * @param subscriptionId The ID of the subscription to cancel.
     * @param {*} [options] Override http request options.
     */
    public cancelSubscription (subscriptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions/{subscription_id}/cancel'
            .replace('{' + 'subscription_id' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling cancelSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a subscription for a customer to a subscription plan.  If you provide a card on file in the request, Square charges the card for  the subscription. Otherwise, Square bills an invoice to the customer's email  address. The subscription starts immediately, unless the request includes  the optional `start_date`. Each individual subscription is associated with a particular location.
     * @summary CreateSubscription
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createSubscription (body: CreateSubscriptionRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateSubscriptionRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all events for a specific subscription. In the current implementation, only `START_SUBSCRIPTION` and `STOP_SUBSCRIPTION` (when the subscription was canceled) events are returned.
     * @summary ListSubscriptionEvents
     * @param subscriptionId The ID of the subscription to retrieve the events for.
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query.  For more information, see [Pagination](https://developer.squareup.com/docs/docs/working-with-apis/pagination).
     * @param limit The upper limit on the number of subscription events to return  in the response.   Default: &#x60;200&#x60;
     * @param {*} [options] Override http request options.
     */
    public listSubscriptionEvents (subscriptionId: string, cursor?: string, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListSubscriptionEventsResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions/{subscription_id}/events'
            .replace('{' + 'subscription_id' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling listSubscriptionEvents.');
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListSubscriptionEventsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListSubscriptionEventsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a subscription.
     * @summary RetrieveSubscription
     * @param subscriptionId The ID of the subscription to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveSubscription (subscriptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions/{subscription_id}'
            .replace('{' + 'subscription_id' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling retrieveSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for subscriptions.  Results are ordered chronologically by subscription creation date. If the request specifies more than one location ID,  the endpoint orders the result  by location ID, and then by creation date within each location. If no locations are given in the query, all locations are searched.  You can also optionally specify `customer_ids` to search by customer.  If left unset, all customers  associated with the specified locations are returned.  If the request specifies customer IDs, the endpoint orders results  first by location, within location by customer ID, and within  customer by subscription creation date.  For more information, see  [Retrieve subscriptions](/docs/subscriptions-api/overview#retrieve-subscriptions).
     * @summary SearchSubscriptions
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchSubscriptions (body: SearchSubscriptionsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchSubscriptionsResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchSubscriptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchSubscriptionsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchSubscriptionsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchSubscriptionsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a subscription. You can set, modify, and clear the  `subscription` field values.
     * @summary UpdateSubscription
     * @param subscriptionId The ID for the subscription to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateSubscription (subscriptionId: string, body: UpdateSubscriptionRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/v2/subscriptions/{subscription_id}'
            .replace('{' + 'subscription_id' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling updateSubscription.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateSubscriptionRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamApiApiKeys {
    oauth2ClientSecret,
}

export class TeamApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamApiApiKeys, value: string) {
        (this.authentications as any)[TeamApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Creates multiple `TeamMember` objects. The created `TeamMember` objects will be returned on successful creates. This process is non-transactional and will process as much of the request as is possible. If one of the creates in the request cannot be successfully processed, the request will NOT be marked as failed, but the body of the response will contain explicit error information for this particular create.  Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#bulkcreateteammembers).
     * @summary BulkCreateTeamMembers
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public bulkCreateTeamMembers (body: BulkCreateTeamMembersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BulkCreateTeamMembersResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/bulk-create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling bulkCreateTeamMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BulkCreateTeamMembersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BulkCreateTeamMembersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BulkCreateTeamMembersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates multiple `TeamMember` objects. The updated `TeamMember` objects will be returned on successful updates. This process is non-transactional and will process as much of the request as is possible. If one of the updates in the request cannot be successfully processed, the request will NOT be marked as failed, but the body of the response will contain explicit error information for this particular update. Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#bulkupdateteammembers).
     * @summary BulkUpdateTeamMembers
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateTeamMembers (body: BulkUpdateTeamMembersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: BulkUpdateTeamMembersResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/bulk-update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling bulkUpdateTeamMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BulkUpdateTeamMembersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BulkUpdateTeamMembersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BulkUpdateTeamMembersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a single `TeamMember` object. The `TeamMember` will be returned on successful creates. You must provide the following values in your request to this endpoint: - `first_name` - `last_name` Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#createteammember).
     * @summary CreateTeamMember
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createTeamMember (body: CreateTeamMemberRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateTeamMemberResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateTeamMemberRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateTeamMemberResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateTeamMemberResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a `TeamMember` object for the given `TeamMember.id` Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#retrieveteammember).
     * @summary RetrieveTeamMember
     * @param teamMemberId The ID of the team member to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveTeamMember (teamMemberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveTeamMemberResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/{team_member_id}'
            .replace('{' + 'team_member_id' + '}', encodeURIComponent(String(teamMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamMemberId' is not null or undefined
        if (teamMemberId === null || teamMemberId === undefined) {
            throw new Error('Required parameter teamMemberId was null or undefined when calling retrieveTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveTeamMemberResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveTeamMemberResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a `WageSetting` object for a team member specified by `TeamMember.id`. Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#retrievewagesetting).
     * @summary RetrieveWageSetting
     * @param teamMemberId The ID of the team member to retrieve wage setting for
     * @param {*} [options] Override http request options.
     */
    public retrieveWageSetting (teamMemberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveWageSettingResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/{team_member_id}/wage-setting'
            .replace('{' + 'team_member_id' + '}', encodeURIComponent(String(teamMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamMemberId' is not null or undefined
        if (teamMemberId === null || teamMemberId === undefined) {
            throw new Error('Required parameter teamMemberId was null or undefined when calling retrieveWageSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveWageSettingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveWageSettingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of `TeamMember` objects for a business. The list to be returned can be filtered by: - location IDs **and** - `is_active`
     * @summary SearchTeamMembers
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchTeamMembers (body: SearchTeamMembersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchTeamMembersResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchTeamMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchTeamMembersRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchTeamMembersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchTeamMembersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a single `TeamMember` object. The `TeamMember` will be returned on successful updates. Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#updateteammember).
     * @summary UpdateTeamMember
     * @param teamMemberId The ID of the team member to update.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateTeamMember (teamMemberId: string, body: UpdateTeamMemberRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateTeamMemberResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/{team_member_id}'
            .replace('{' + 'team_member_id' + '}', encodeURIComponent(String(teamMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamMemberId' is not null or undefined
        if (teamMemberId === null || teamMemberId === undefined) {
            throw new Error('Required parameter teamMemberId was null or undefined when calling updateTeamMember.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateTeamMemberRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateTeamMemberResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateTeamMemberResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates or updates a `WageSetting` object. The object is created if a `WageSetting` with the specified `team_member_id` does not exist. Otherwise, it fully replaces the `WageSetting` object for the team member. The `WageSetting` will be returned upon successful update. Learn about [Troubleshooting the Teams API](/docs/team/troubleshooting#updatewagesetting).
     * @summary UpdateWageSetting
     * @param teamMemberId The ID of the team member to update the &#x60;WageSetting&#x60; object for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateWageSetting (teamMemberId: string, body: UpdateWageSettingRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateWageSettingResponse;  }> {
        const localVarPath = this.basePath + '/v2/team-members/{team_member_id}/wage-setting'
            .replace('{' + 'team_member_id' + '}', encodeURIComponent(String(teamMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamMemberId' is not null or undefined
        if (teamMemberId === null || teamMemberId === undefined) {
            throw new Error('Required parameter teamMemberId was null or undefined when calling updateWageSetting.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateWageSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateWageSettingRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateWageSettingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateWageSettingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TerminalApiApiKeys {
    oauth2ClientSecret,
}

export class TerminalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TerminalApiApiKeys, value: string) {
        (this.authentications as any)[TerminalApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Cancels a Terminal checkout request, if the status of the request permits it.
     * @summary CancelTerminalCheckout
     * @param checkoutId Unique ID for the desired &#x60;TerminalCheckout&#x60;
     * @param {*} [options] Override http request options.
     */
    public cancelTerminalCheckout (checkoutId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelTerminalCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/v2/terminals/checkouts/{checkout_id}/cancel'
            .replace('{' + 'checkout_id' + '}', encodeURIComponent(String(checkoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'checkoutId' is not null or undefined
        if (checkoutId === null || checkoutId === undefined) {
            throw new Error('Required parameter checkoutId was null or undefined when calling cancelTerminalCheckout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelTerminalCheckoutResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelTerminalCheckoutResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new Terminal checkout request and sends it to the specified device to take a payment for the requested amount.
     * @summary CreateTerminalCheckout
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createTerminalCheckout (body: CreateTerminalCheckoutRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateTerminalCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/v2/terminals/checkouts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTerminalCheckout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateTerminalCheckoutRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateTerminalCheckoutResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateTerminalCheckoutResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a Terminal checkout request by checkout_id.
     * @summary GetTerminalCheckout
     * @param checkoutId Unique ID for the desired &#x60;TerminalCheckout&#x60;
     * @param {*} [options] Override http request options.
     */
    public getTerminalCheckout (checkoutId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetTerminalCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/v2/terminals/checkouts/{checkout_id}'
            .replace('{' + 'checkout_id' + '}', encodeURIComponent(String(checkoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'checkoutId' is not null or undefined
        if (checkoutId === null || checkoutId === undefined) {
            throw new Error('Required parameter checkoutId was null or undefined when calling getTerminalCheckout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTerminalCheckoutResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTerminalCheckoutResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a filtered list of Terminal checkout requests created by the account making the request.
     * @summary SearchTerminalCheckouts
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public searchTerminalCheckouts (body: SearchTerminalCheckoutsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: SearchTerminalCheckoutsResponse;  }> {
        const localVarPath = this.basePath + '/v2/terminals/checkouts/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchTerminalCheckouts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchTerminalCheckoutsRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SearchTerminalCheckoutsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchTerminalCheckoutsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionsApiApiKeys {
    oauth2ClientSecret,
}

export class TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Captures a transaction that was created with the [Charge](#endpoint-charge) endpoint with a `delay_capture` value of `true`.   See [Delayed capture transactions](/payments/transactions/overview#delayed-capture) for more information.
     * @summary CaptureTransaction
     * @param locationId 
     * @param transactionId 
     * @param {*} [options] Override http request options.
     */
    public captureTransaction (locationId: string, transactionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CaptureTransactionResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions/{transaction_id}/capture'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'transaction_id' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling captureTransaction.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling captureTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CaptureTransactionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CaptureTransactionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Charges a card represented by a card nonce or a customer's card on file.  Your request to this endpoint must include _either_:  - A value for the `card_nonce` parameter (to charge a card nonce generated with the `SqPaymentForm`) - Values for the `customer_card_id` and `customer_id` parameters (to charge a customer's card on file)  In order for an eCommerce payment to potentially qualify for [Square chargeback protection](https://squareup.com/help/article/5394), you _must_ provide values for the following parameters in your request:  - `buyer_email_address` - At least one of `billing_address` or `shipping_address`  When this response is returned, the amount of Square's processing fee might not yet be calculated. To obtain the processing fee, wait about ten seconds and call [RetrieveTransaction](#endpoint-retrievetransaction). See the `processing_fee_money` field of each [Tender included](#type-tender) in the transaction.
     * @summary Charge
     * @param locationId The ID of the location to associate the created transaction with.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public charge (locationId: string, body: ChargeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargeResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling charge.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling charge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ChargeRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Initiates a refund for a previously charged tender.  You must issue a refund within 120 days of the associated payment. See [this article](https://squareup.com/help/us/en/article/5060) for more information on refund behavior.  NOTE: Card-present transactions with Interac credit cards **cannot be refunded using the Connect API**. Interac transactions must refunded in-person (e.g., dipping the card using POS app).
     * @summary CreateRefund
     * @param locationId The ID of the original transaction&#39;s associated location.
     * @param transactionId The ID of the original transaction that includes the tender to refund.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createRefund (locationId: string, transactionId: string, body: CreateRefundRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateRefundResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions/{transaction_id}/refund'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'transaction_id' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createRefund.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createRefund.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRefund.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRefundRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateRefundResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateRefundResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists refunds for one of a business's locations.  In addition to full or partial tender refunds processed through Square APIs, refunds may result from itemized returns or exchanges through Square's Point of Sale applications.  Refunds with a `status` of `PENDING` are not currently included in this endpoint's response.  Max results per [page](#paginatingresults): 50
     * @summary ListRefunds
     * @param locationId The ID of the location to list refunds for.
     * @param beginTime The beginning of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time minus one year.
     * @param endTime The end of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time.
     * @param sortOrder The order in which results are listed in the response (&#x60;ASC&#x60; for oldest first, &#x60;DESC&#x60; for newest first).  Default value: &#x60;DESC&#x60;
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
     * @param {*} [options] Override http request options.
     */
    public listRefunds (locationId: string, beginTime?: string, endTime?: string, sortOrder?: string, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListRefundsResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/refunds'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listRefunds.');
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListRefundsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListRefundsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists transactions for a particular location.  Transactions include payment information from sales and exchanges and refund information from returns and exchanges.  Max results per [page](#paginatingresults): 50
     * @summary ListTransactions
     * @param locationId The ID of the location to list transactions for.
     * @param beginTime The beginning of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time minus one year.
     * @param endTime The end of the requested reporting period, in RFC 3339 format.  See [Date ranges](#dateranges) for details on date inclusivity/exclusivity.  Default value: The current time.
     * @param sortOrder The order in which results are listed in the response (&#x60;ASC&#x60; for oldest first, &#x60;DESC&#x60; for newest first).  Default value: &#x60;DESC&#x60;
     * @param cursor A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for your original query.  See [Paginating results](#paginatingresults) for more information.
     * @param {*} [options] Override http request options.
     */
    public listTransactions (locationId: string, beginTime?: string, endTime?: string, sortOrder?: string, cursor?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListTransactionsResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listTransactions.');
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListTransactionsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListTransactionsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves details for a single transaction.
     * @summary RetrieveTransaction
     * @param locationId The ID of the transaction&#39;s associated location.
     * @param transactionId The ID of the transaction to retrieve.
     * @param {*} [options] Override http request options.
     */
    public retrieveTransaction (locationId: string, transactionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RetrieveTransactionResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions/{transaction_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'transaction_id' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveTransaction.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling retrieveTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RetrieveTransactionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RetrieveTransactionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancels a transaction that was created with the [Charge](#endpoint-charge) endpoint with a `delay_capture` value of `true`.   See [Delayed capture transactions](/payments/transactions/overview#delayed-capture) for more information.
     * @summary VoidTransaction
     * @param locationId 
     * @param transactionId 
     * @param {*} [options] Override http request options.
     */
    public voidTransaction (locationId: string, transactionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: VoidTransactionResponse;  }> {
        const localVarPath = this.basePath + '/v2/locations/{location_id}/transactions/{transaction_id}/void'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'transaction_id' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling voidTransaction.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling voidTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VoidTransactionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VoidTransactionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum V1EmployeesApiApiKeys {
    oauth2ClientSecret,
}

export class V1EmployeesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V1EmployeesApiApiKeys, value: string) {
        (this.authentications as any)[V1EmployeesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     *  Use the CreateEmployee endpoint to add an employee to a Square account. Employees created with the Connect API have an initial status of `INACTIVE`. Inactive employees cannot sign in to Square Point of Sale until they are activated from the Square Dashboard. Employee status cannot be changed with the Connect API.  <aside class=\"important\"> Employee entities cannot be deleted. To disable employee profiles, set the employee's status to <code>INACTIVE</code> </aside>
     * @summary CreateEmployee
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createEmployee (body: V1Employee, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Employee;  }> {
        const localVarPath = this.basePath + '/v1/me/employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createEmployee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Employee")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Employee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Employee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an employee role you can then assign to employees.  Square accounts can include any number of roles that can be assigned to employees. These roles define the actions and permissions granted to an employee with that role. For example, an employee with a \"Shift Manager\" role might be able to issue refunds in Square Point of Sale, whereas an employee with a \"Clerk\" role might not.  Roles are assigned with the [V1UpdateEmployee](#endpoint-v1updateemployee) endpoint. An employee can have only one role at a time.  If an employee has no role, they have none of the permissions associated with roles. All employees can accept payments with Square Point of Sale.
     * @summary CreateEmployeeRole
     * @param employeeRole An EmployeeRole object with a name and permissions, and an optional owner flag.
     * @param {*} [options] Override http request options.
     */
    public createEmployeeRole (employeeRole: V1EmployeeRole, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }> {
        const localVarPath = this.basePath + '/v1/me/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'employeeRole' is not null or undefined
        if (employeeRole === null || employeeRole === undefined) {
            throw new Error('Required parameter employeeRole was null or undefined when calling createEmployeeRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(employeeRole, "V1EmployeeRole")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1EmployeeRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a timecard for an employee and clocks them in with an `API_CREATE` event and a `clockin_time` set to the current time unless the request provides a different value.  To import timecards from another system (rather than clocking someone in). Specify the `clockin_time` and* `clockout_time` in the request.  Timecards correspond to exactly one shift for a given employee, bounded by the `clockin_time` and `clockout_time` fields. An employee is considered clocked in if they have a timecard that doesn't have a `clockout_time` set. An employee that is currently clocked in cannot be clocked in a second time.
     * @summary CreateTimecard
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createTimecard (body: V1Timecard, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Timecard;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTimecard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Timecard")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Timecard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Timecard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a timecard. Timecards can also be deleted through the Square Dashboard. Deleted timecards are still accessible through Connect API endpoints, but cannot be modified. The `deleted` field of the `Timecard` object indicates whether the timecard has been deleted.   __Note__: By default, deleted timecards appear alongside valid timecards in results returned by the [ListTimecards](#endpoint-v1employees-listtimecards) endpoint. To filter deleted timecards, include the `deleted` query parameter in the list request.  Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API.
     * @summary DeleteTimecard
     * @param timecardId The ID of the timecard to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteTimecard (timecardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards/{timecard_id}'
            .replace('{' + 'timecard_id' + '}', encodeURIComponent(String(timecardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'timecardId' is not null or undefined
        if (timecardId === null || timecardId === undefined) {
            throw new Error('Required parameter timecardId was null or undefined when calling deleteTimecard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for all of a location's cash drawer shifts during a date range. The date range you specify cannot exceed 90 days.
     * @summary ListCashDrawerShifts
     * @param locationId The ID of the location to list cash drawer shifts for.
     * @param order The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC
     * @param beginTime The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
     * @param endTime The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
     * @param {*} [options] Override http request options.
     */
    public listCashDrawerShifts (locationId: string, order?: string, beginTime?: string, endTime?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1CashDrawerShift>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/cash-drawer-shifts'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listCashDrawerShifts.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1CashDrawerShift>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1CashDrawerShift>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all of a business's employee roles.
     * @summary ListEmployeeRoles
     * @param order The order in which employees are listed in the response, based on their created_at field.Default value: ASC
     * @param limit The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listEmployeeRoles (order?: string, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1EmployeeRole>;  }> {
        const localVarPath = this.basePath + '/v1/me/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1EmployeeRole>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1EmployeeRole>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all of a business's employees.
     * @summary ListEmployees
     * @param order The order in which employees are listed in the response, based on their created_at field.      Default value: ASC
     * @param beginUpdatedAt If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
     * @param endUpdatedAt If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param beginCreatedAt If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param endCreatedAt If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param status If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE).
     * @param externalId If provided, the endpoint returns only employee entities with the specified external_id.
     * @param limit The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listEmployees (order?: string, beginUpdatedAt?: string, endUpdatedAt?: string, beginCreatedAt?: string, endCreatedAt?: string, status?: string, externalId?: string, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Employee>;  }> {
        const localVarPath = this.basePath + '/v1/me/employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (beginUpdatedAt !== undefined) {
            localVarQueryParameters['begin_updated_at'] = ObjectSerializer.serialize(beginUpdatedAt, "string");
        }

        if (endUpdatedAt !== undefined) {
            localVarQueryParameters['end_updated_at'] = ObjectSerializer.serialize(endUpdatedAt, "string");
        }

        if (beginCreatedAt !== undefined) {
            localVarQueryParameters['begin_created_at'] = ObjectSerializer.serialize(beginCreatedAt, "string");
        }

        if (endCreatedAt !== undefined) {
            localVarQueryParameters['end_created_at'] = ObjectSerializer.serialize(endCreatedAt, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (externalId !== undefined) {
            localVarQueryParameters['external_id'] = ObjectSerializer.serialize(externalId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Employee>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Employee>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all events associated with a particular timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
     * @summary ListTimecardEvents
     * @param timecardId The ID of the timecard to list events for.
     * @param {*} [options] Override http request options.
     */
    public listTimecardEvents (timecardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1TimecardEvent>;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards/{timecard_id}/events'
            .replace('{' + 'timecard_id' + '}', encodeURIComponent(String(timecardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'timecardId' is not null or undefined
        if (timecardId === null || timecardId === undefined) {
            throw new Error('Required parameter timecardId was null or undefined when calling listTimecardEvents.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1TimecardEvent>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1TimecardEvent>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all of a business's employee timecards.
     * @summary ListTimecards
     * @param order The order in which timecards are listed in the response, based on their created_at field.
     * @param employeeId If provided, the endpoint returns only timecards for the employee with the specified ID.
     * @param beginClockinTime If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param endClockinTime If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
     * @param beginClockoutTime If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param endClockoutTime If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
     * @param beginUpdatedAt If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param endUpdatedAt If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param deleted If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don&#39;t provide this parameter, both valid and deleted timecards are returned.
     * @param limit The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listTimecards (order?: string, employeeId?: string, beginClockinTime?: string, endClockinTime?: string, beginClockoutTime?: string, endClockoutTime?: string, beginUpdatedAt?: string, endUpdatedAt?: string, deleted?: boolean, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Timecard>;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (employeeId !== undefined) {
            localVarQueryParameters['employee_id'] = ObjectSerializer.serialize(employeeId, "string");
        }

        if (beginClockinTime !== undefined) {
            localVarQueryParameters['begin_clockin_time'] = ObjectSerializer.serialize(beginClockinTime, "string");
        }

        if (endClockinTime !== undefined) {
            localVarQueryParameters['end_clockin_time'] = ObjectSerializer.serialize(endClockinTime, "string");
        }

        if (beginClockoutTime !== undefined) {
            localVarQueryParameters['begin_clockout_time'] = ObjectSerializer.serialize(beginClockoutTime, "string");
        }

        if (endClockoutTime !== undefined) {
            localVarQueryParameters['end_clockout_time'] = ObjectSerializer.serialize(endClockoutTime, "string");
        }

        if (beginUpdatedAt !== undefined) {
            localVarQueryParameters['begin_updated_at'] = ObjectSerializer.serialize(beginUpdatedAt, "string");
        }

        if (endUpdatedAt !== undefined) {
            localVarQueryParameters['end_updated_at'] = ObjectSerializer.serialize(endUpdatedAt, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Timecard>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Timecard>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single cash drawer shift, including all events that occurred during the shift.
     * @summary RetrieveCashDrawerShift
     * @param locationId The ID of the location to list cash drawer shifts for.
     * @param shiftId The shift&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveCashDrawerShift (locationId: string, shiftId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1CashDrawerShift;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/cash-drawer-shifts/{shift_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'shift_id' + '}', encodeURIComponent(String(shiftId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveCashDrawerShift.');
        }

        // verify required parameter 'shiftId' is not null or undefined
        if (shiftId === null || shiftId === undefined) {
            throw new Error('Required parameter shiftId was null or undefined when calling retrieveCashDrawerShift.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1CashDrawerShift;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1CashDrawerShift");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single employee.
     * @summary RetrieveEmployee
     * @param employeeId The employee&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveEmployee (employeeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Employee;  }> {
        const localVarPath = this.basePath + '/v1/me/employees/{employee_id}'
            .replace('{' + 'employee_id' + '}', encodeURIComponent(String(employeeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'employeeId' is not null or undefined
        if (employeeId === null || employeeId === undefined) {
            throw new Error('Required parameter employeeId was null or undefined when calling retrieveEmployee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Employee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Employee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single employee role.
     * @summary RetrieveEmployeeRole
     * @param roleId The role&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveEmployeeRole (roleId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }> {
        const localVarPath = this.basePath + '/v1/me/roles/{role_id}'
            .replace('{' + 'role_id' + '}', encodeURIComponent(String(roleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling retrieveEmployeeRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1EmployeeRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
     * @summary RetrieveTimecard
     * @param timecardId The timecard&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveTimecard (timecardId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Timecard;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards/{timecard_id}'
            .replace('{' + 'timecard_id' + '}', encodeURIComponent(String(timecardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'timecardId' is not null or undefined
        if (timecardId === null || timecardId === undefined) {
            throw new Error('Required parameter timecardId was null or undefined when calling retrieveTimecard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Timecard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Timecard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UpdateEmployee
     * @param employeeId The ID of the role to modify.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateEmployee (employeeId: string, body: V1Employee, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Employee;  }> {
        const localVarPath = this.basePath + '/v1/me/employees/{employee_id}'
            .replace('{' + 'employee_id' + '}', encodeURIComponent(String(employeeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'employeeId' is not null or undefined
        if (employeeId === null || employeeId === undefined) {
            throw new Error('Required parameter employeeId was null or undefined when calling updateEmployee.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateEmployee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Employee")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Employee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Employee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an employee role.
     * @summary UpdateEmployeeRole
     * @param roleId The ID of the role to modify.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateEmployeeRole (roleId: string, body: V1EmployeeRole, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }> {
        const localVarPath = this.basePath + '/v1/me/roles/{role_id}'
            .replace('{' + 'role_id' + '}', encodeURIComponent(String(roleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling updateEmployeeRole.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateEmployeeRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1EmployeeRole")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1EmployeeRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1EmployeeRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of a timecard with an `API_EDIT` event for the timecard. Updating an active timecard with a `clockout_time` clocks the employee out.
     * @summary UpdateTimecard
     * @param timecardId TThe ID of the timecard to modify.
     * @param body An object containing the fields to POST for the request. See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateTimecard (timecardId: string, body: V1Timecard, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Timecard;  }> {
        const localVarPath = this.basePath + '/v1/me/timecards/{timecard_id}'
            .replace('{' + 'timecard_id' + '}', encodeURIComponent(String(timecardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'timecardId' is not null or undefined
        if (timecardId === null || timecardId === undefined) {
            throw new Error('Required parameter timecardId was null or undefined when calling updateTimecard.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTimecard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Timecard")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Timecard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Timecard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum V1ItemsApiApiKeys {
    oauth2ClientSecret,
}

export class V1ItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V1ItemsApiApiKeys, value: string) {
        (this.authentications as any)[V1ItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Adjusts the current available inventory of an item variation.
     * @summary AdjustInventory
     * @param locationId The ID of the item&#39;s associated location.
     * @param variationId The ID of the variation to adjust inventory information for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public adjustInventory (locationId: string, variationId: string, body: V1AdjustInventoryRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1InventoryEntry;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/inventory/{variation_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'variation_id' + '}', encodeURIComponent(String(variationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling adjustInventory.');
        }

        // verify required parameter 'variationId' is not null or undefined
        if (variationId === null || variationId === undefined) {
            throw new Error('Required parameter variationId was null or undefined when calling adjustInventory.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling adjustInventory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1AdjustInventoryRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1InventoryEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1InventoryEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Associates a fee with an item so the fee is automatically applied to the item in Square Point of Sale.
     * @summary ApplyFee
     * @param locationId The ID of the fee&#39;s associated location.
     * @param itemId The ID of the item to add the fee to.
     * @param feeId The ID of the fee to apply.
     * @param {*} [options] Override http request options.
     */
    public applyFee (locationId: string, itemId: string, feeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/fees/{fee_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)))
            .replace('{' + 'fee_id' + '}', encodeURIComponent(String(feeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling applyFee.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling applyFee.');
        }

        // verify required parameter 'feeId' is not null or undefined
        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling applyFee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Associates a modifier list with an item so the associated modifier options can be applied to the item.
     * @summary ApplyModifierList
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to apply.
     * @param itemId The ID of the item to add the modifier list to.
     * @param {*} [options] Override http request options.
     */
    public applyModifierList (locationId: string, modifierListId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/modifier-lists/{modifier_list_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling applyModifierList.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling applyModifierList.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling applyModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an item category.
     * @summary CreateCategory
     * @param locationId The ID of the location to create an item for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createCategory (locationId: string, body: V1Category, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Category;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/categories'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createCategory.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Category")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Category;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Category");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a discount.
     * @summary CreateDiscount
     * @param locationId The ID of the location to create an item for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createDiscount (locationId: string, body: V1Discount, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Discount;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/discounts'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createDiscount.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDiscount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Discount")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Discount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Discount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a fee (tax).
     * @summary CreateFee
     * @param locationId The ID of the location to create a fee for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createFee (locationId: string, body: V1Fee, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Fee;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/fees'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createFee.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createFee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Fee")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Fee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Fee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an item and at least one variation for it.    Item-related entities include fields you can use to associate them with entities in a non-Square system.  When you create an item-related entity, you can optionally specify `id`. This value must be unique among all IDs ever specified for the account, including those specified by other applications. You can never reuse an entity ID. If you do not specify an ID, Square generates one for the entity.  Item variations have a `user_data` string that lets you associate arbitrary metadata with the variation. The string cannot exceed 255 characters.
     * @summary CreateItem
     * @param locationId The ID of the location to create an item for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createItem (locationId: string, body: V1Item, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Item")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an item modifier list and at least 1 modifier option for it.
     * @summary CreateModifierList
     * @param locationId The ID of the location to create a modifier list for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createModifierList (locationId: string, body: V1ModifierList, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierList;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createModifierList.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1ModifierList")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an item modifier option and adds it to a modifier list.
     * @summary CreateModifierOption
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createModifierOption (locationId: string, modifierListId: string, body: V1ModifierOption, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createModifierOption.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling createModifierOption.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createModifierOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1ModifierOption")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a Favorites page in Square Point of Sale.
     * @summary CreatePage
     * @param locationId The ID of the location to create an item for.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createPage (locationId: string, body: V1Page, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Page;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createPage.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Page")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Page;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Page");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an item variation for an existing item.
     * @summary CreateVariation
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The item&#39;s ID.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createVariation (locationId: string, itemId: string, body: V1Variation, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Variation;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/variations'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createVariation.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling createVariation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createVariation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Variation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Variation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Variation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing item category.   __DeleteCategory__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteCategoryRequest` object as documented below.
     * @summary DeleteCategory
     * @param locationId The ID of the item&#39;s associated location.
     * @param categoryId The ID of the category to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCategory (locationId: string, categoryId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Category;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/categories/{category_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'category_id' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteCategory.');
        }

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling deleteCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Category;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Category");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing discount.   __DeleteDiscount__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteDiscountRequest` object as documented below.
     * @summary DeleteDiscount
     * @param locationId The ID of the item&#39;s associated location.
     * @param discountId The ID of the discount to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteDiscount (locationId: string, discountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Discount;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/discounts/{discount_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'discount_id' + '}', encodeURIComponent(String(discountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteDiscount.');
        }

        // verify required parameter 'discountId' is not null or undefined
        if (discountId === null || discountId === undefined) {
            throw new Error('Required parameter discountId was null or undefined when calling deleteDiscount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Discount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Discount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing fee (tax).   __DeleteFee__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteFeeRequest` object as documented below.
     * @summary DeleteFee
     * @param locationId The ID of the fee&#39;s associated location.
     * @param feeId The ID of the fee to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteFee (locationId: string, feeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Fee;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/fees/{fee_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'fee_id' + '}', encodeURIComponent(String(feeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteFee.');
        }

        // verify required parameter 'feeId' is not null or undefined
        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling deleteFee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Fee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Fee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing item and all item variations associated with it.   __DeleteItem__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteItemRequest` object as documented below.
     * @summary DeleteItem
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The ID of the item to modify.
     * @param {*} [options] Override http request options.
     */
    public deleteItem (locationId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling deleteItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing item modifier list and all modifier options associated with it.   __DeleteModifierList__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierListRequest` object as documented below.
     * @summary DeleteModifierList
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteModifierList (locationId: string, modifierListId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierList;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteModifierList.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling deleteModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing item modifier option from a modifier list.   __DeleteModifierOption__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierOptionRequest` object.
     * @summary DeleteModifierOption
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to delete.
     * @param modifierOptionId The ID of the modifier list to edit.
     * @param {*} [options] Override http request options.
     */
    public deleteModifierOption (locationId: string, modifierListId: string, modifierOptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options/{modifier_option_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)))
            .replace('{' + 'modifier_option_id' + '}', encodeURIComponent(String(modifierOptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteModifierOption.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling deleteModifierOption.');
        }

        // verify required parameter 'modifierOptionId' is not null or undefined
        if (modifierOptionId === null || modifierOptionId === undefined) {
            throw new Error('Required parameter modifierOptionId was null or undefined when calling deleteModifierOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing Favorites page and all of its cells.   __DeletePage__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageRequest` object.
     * @summary DeletePage
     * @param locationId The ID of the Favorites page&#39;s associated location.
     * @param pageId The ID of the page to delete.
     * @param {*} [options] Override http request options.
     */
    public deletePage (locationId: string, pageId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Page;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages/{page_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'page_id' + '}', encodeURIComponent(String(pageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deletePage.');
        }

        // verify required parameter 'pageId' is not null or undefined
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling deletePage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Page;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Page");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a cell from a Favorites page in Square Point of Sale.   __DeletePageCell__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageCellRequest` object as documented below.
     * @summary DeletePageCell
     * @param locationId The ID of the Favorites page&#39;s associated location.
     * @param pageId The ID of the page to delete.
     * @param row The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
     * @param column The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
     * @param {*} [options] Override http request options.
     */
    public deletePageCell (locationId: string, pageId: string, row?: string, column?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Page;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages/{page_id}/cells'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'page_id' + '}', encodeURIComponent(String(pageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deletePageCell.');
        }

        // verify required parameter 'pageId' is not null or undefined
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling deletePageCell.');
        }

        if (row !== undefined) {
            localVarQueryParameters['row'] = ObjectSerializer.serialize(row, "string");
        }

        if (column !== undefined) {
            localVarQueryParameters['column'] = ObjectSerializer.serialize(column, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Page;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Page");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an existing item variation from an item.   __DeleteVariation__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteVariationRequest` object as documented below.
     * @summary DeleteVariation
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The ID of the item to delete.
     * @param variationId The ID of the variation to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteVariation (locationId: string, itemId: string, variationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Variation;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/variations/{variation_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)))
            .replace('{' + 'variation_id' + '}', encodeURIComponent(String(variationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteVariation.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling deleteVariation.');
        }

        // verify required parameter 'variationId' is not null or undefined
        if (variationId === null || variationId === undefined) {
            throw new Error('Required parameter variationId was null or undefined when calling deleteVariation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Variation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Variation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all the item categories for a given location.
     * @summary ListCategories
     * @param locationId The ID of the location to list categories for.
     * @param {*} [options] Override http request options.
     */
    public listCategories (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Category>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/categories'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Category>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Category>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all the discounts for a given location.
     * @summary ListDiscounts
     * @param locationId The ID of the location to list categories for.
     * @param {*} [options] Override http request options.
     */
    public listDiscounts (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Discount>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/discounts'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listDiscounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Discount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Discount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all the fees (taxes) for a given location.
     * @summary ListFees
     * @param locationId The ID of the location to list fees for.
     * @param {*} [options] Override http request options.
     */
    public listFees (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Fee>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/fees'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listFees.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Fee>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Fee>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides inventory information for all inventory-enabled item variations.
     * @summary ListInventory
     * @param locationId The ID of the item&#39;s associated location.
     * @param limit The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listInventory (locationId: string, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1InventoryEntry>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/inventory'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listInventory.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1InventoryEntry>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1InventoryEntry>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information of all items for a given location.
     * @summary ListItems
     * @param locationId The ID of the location to list items for.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listItems (locationId: string, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Item>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listItems.');
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Item>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Item>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all the modifier lists for a given location.
     * @summary ListModifierLists
     * @param locationId The ID of the location to list modifier lists for.
     * @param {*} [options] Override http request options.
     */
    public listModifierLists (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1ModifierList>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listModifierLists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1ModifierList>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1ModifierList>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all Favorites pages (in Square Point of Sale) for a given location.
     * @summary ListPages
     * @param locationId The ID of the location to list Favorites pages for.
     * @param {*} [options] Override http request options.
     */
    public listPages (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Page>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listPages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Page>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Page>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a fee assocation from an item so the fee is no longer automatically applied to the item in Square Point of Sale.
     * @summary RemoveFee
     * @param locationId The ID of the fee&#39;s associated location.
     * @param itemId The ID of the item to add the fee to.
     * @param feeId The ID of the fee to apply.
     * @param {*} [options] Override http request options.
     */
    public removeFee (locationId: string, itemId: string, feeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/fees/{fee_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)))
            .replace('{' + 'fee_id' + '}', encodeURIComponent(String(feeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling removeFee.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling removeFee.');
        }

        // verify required parameter 'feeId' is not null or undefined
        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling removeFee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a modifier list association from an item so the modifier options from the list can no longer be applied to the item.
     * @summary RemoveModifierList
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to remove.
     * @param itemId The ID of the item to remove the modifier list from.
     * @param {*} [options] Override http request options.
     */
    public removeModifierList (locationId: string, modifierListId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/modifier-lists/{modifier_list_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling removeModifierList.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling removeModifierList.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling removeModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single item, including associated modifier lists and fees.
     * @summary RetrieveItem
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The item&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveItem (locationId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling retrieveItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for a single modifier list.
     * @summary RetrieveModifierList
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The modifier list&#39;s ID.
     * @param {*} [options] Override http request options.
     */
    public retrieveModifierList (locationId: string, modifierListId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierList;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveModifierList.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling retrieveModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing item category.
     * @summary UpdateCategory
     * @param locationId The ID of the category&#39;s associated location.
     * @param categoryId The ID of the category to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateCategory (locationId: string, categoryId: string, body: V1Category, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Category;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/categories/{category_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'category_id' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateCategory.');
        }

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling updateCategory.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Category")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Category;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Category");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing discount.
     * @summary UpdateDiscount
     * @param locationId The ID of the category&#39;s associated location.
     * @param discountId The ID of the discount to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateDiscount (locationId: string, discountId: string, body: V1Discount, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Discount;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/discounts/{discount_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'discount_id' + '}', encodeURIComponent(String(discountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateDiscount.');
        }

        // verify required parameter 'discountId' is not null or undefined
        if (discountId === null || discountId === undefined) {
            throw new Error('Required parameter discountId was null or undefined when calling updateDiscount.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateDiscount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Discount")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Discount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Discount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing fee (tax).
     * @summary UpdateFee
     * @param locationId The ID of the fee&#39;s associated location.
     * @param feeId The ID of the fee to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateFee (locationId: string, feeId: string, body: V1Fee, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Fee;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/fees/{fee_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'fee_id' + '}', encodeURIComponent(String(feeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateFee.');
        }

        // verify required parameter 'feeId' is not null or undefined
        if (feeId === null || feeId === undefined) {
            throw new Error('Required parameter feeId was null or undefined when calling updateFee.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateFee.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Fee")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Fee;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Fee");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the core details of an existing item.
     * @summary UpdateItem
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The ID of the item to modify.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateItem (locationId: string, itemId: string, body: V1Item, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Item;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling updateItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Item")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Item;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Item");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing item modifier list.
     * @summary UpdateModifierList
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateModifierList (locationId: string, modifierListId: string, body: V1UpdateModifierListRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierList;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateModifierList.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling updateModifierList.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateModifierList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1UpdateModifierListRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing item modifier option.
     * @summary UpdateModifierOption
     * @param locationId The ID of the item&#39;s associated location.
     * @param modifierListId The ID of the modifier list to edit.
     * @param modifierOptionId The ID of the modifier list to edit.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateModifierOption (locationId: string, modifierListId: string, modifierOptionId: string, body: V1ModifierOption, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options/{modifier_option_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'modifier_list_id' + '}', encodeURIComponent(String(modifierListId)))
            .replace('{' + 'modifier_option_id' + '}', encodeURIComponent(String(modifierOptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateModifierOption.');
        }

        // verify required parameter 'modifierListId' is not null or undefined
        if (modifierListId === null || modifierListId === undefined) {
            throw new Error('Required parameter modifierListId was null or undefined when calling updateModifierOption.');
        }

        // verify required parameter 'modifierOptionId' is not null or undefined
        if (modifierOptionId === null || modifierOptionId === undefined) {
            throw new Error('Required parameter modifierOptionId was null or undefined when calling updateModifierOption.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateModifierOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1ModifierOption")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1ModifierOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1ModifierOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of a Favorites page in Square Point of Sale.
     * @summary UpdatePage
     * @param locationId The ID of the Favorites page&#39;s associated location
     * @param pageId The ID of the page to modify.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updatePage (locationId: string, pageId: string, body: V1Page, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Page;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages/{page_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'page_id' + '}', encodeURIComponent(String(pageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updatePage.');
        }

        // verify required parameter 'pageId' is not null or undefined
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling updatePage.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Page")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Page;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Page");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies a cell of a Favorites page in Square Point of Sale.
     * @summary UpdatePageCell
     * @param locationId The ID of the Favorites page&#39;s associated location.
     * @param pageId The ID of the page the cell belongs to.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updatePageCell (locationId: string, pageId: string, body: V1PageCell, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Page;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/pages/{page_id}/cells'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'page_id' + '}', encodeURIComponent(String(pageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updatePageCell.');
        }

        // verify required parameter 'pageId' is not null or undefined
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling updatePageCell.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePageCell.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1PageCell")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Page;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Page");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the details of an existing item variation.
     * @summary UpdateVariation
     * @param locationId The ID of the item&#39;s associated location.
     * @param itemId The ID of the item to modify.
     * @param variationId The ID of the variation to modify.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateVariation (locationId: string, itemId: string, variationId: string, body: V1Variation, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Variation;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/items/{item_id}/variations/{variation_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)))
            .replace('{' + 'variation_id' + '}', encodeURIComponent(String(variationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateVariation.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling updateVariation.');
        }

        // verify required parameter 'variationId' is not null or undefined
        if (variationId === null || variationId === undefined) {
            throw new Error('Required parameter variationId was null or undefined when calling updateVariation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateVariation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1Variation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Variation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Variation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum V1LocationsApiApiKeys {
    oauth2ClientSecret,
}

export class V1LocationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V1LocationsApiApiKeys, value: string) {
        (this.authentications as any)[V1LocationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Provides details for all business locations associated with a Square account, including the Square-assigned object ID for the location.
     * @summary ListLocations
     * @param {*} [options] Override http request options.
     */
    public listLocations (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Merchant>;  }> {
        const localVarPath = this.basePath + '/v1/me/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Merchant>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Merchant>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the general information for a business.
     * @summary RetrieveBusiness
     * @param {*} [options] Override http request options.
     */
    public retrieveBusiness (options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Merchant;  }> {
        const localVarPath = this.basePath + '/v1/me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Merchant;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Merchant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum V1TransactionsApiApiKeys {
    oauth2ClientSecret,
}

export class V1TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
        'oauth2ClientSecret': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V1TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[V1TransactionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Issues a refund for a previously processed payment. You must issue a refund within 60 days of the associated payment.  You cannot issue a partial refund for a split tender payment. You must instead issue a full or partial refund for a particular tender, by providing the applicable tender id to the V1CreateRefund endpoint. Issuing a full refund for a split tender payment refunds all tenders associated with the payment.  Issuing a refund for a card payment is not reversible. For development purposes, you can create fake cash payments in Square Point of Sale and refund them.
     * @summary CreateRefund
     * @param locationId The ID of the original payment&#39;s associated location.
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public createRefund (locationId: string, body: V1CreateRefundRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Refund;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/refunds'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling createRefund.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRefund.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1CreateRefundRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Refund;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Refund");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides non-confidential details for all of a location's associated bank accounts. This endpoint does not provide full bank account numbers, and there is no way to obtain a full bank account number with the Connect API.
     * @summary ListBankAccounts
     * @param locationId The ID of the location to list bank accounts for.
     * @param {*} [options] Override http request options.
     */
    public listBankAccounts (locationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1BankAccount>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/bank-accounts'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1BankAccount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1BankAccount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for a merchant's online store orders.
     * @summary ListOrders
     * @param locationId The ID of the location to list online store orders for.
     * @param order TThe order in which payments are listed in the response.
     * @param limit The maximum number of payments to return in a single response. This value cannot exceed 200.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listOrders (locationId: string, order?: string, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Order>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/orders'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listOrders.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Order>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Order>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all payments taken for a given Square account during a date range. Date ranges cannot exceed 1 year in length. See Date ranges for details of inclusive and exclusive dates.  *Note**: Details for payments processed with Square Point of Sale while in offline mode may not be transmitted to Square for up to 72 hours. Offline payments have a `created_at` value that reflects the time the payment was originally processed, not the time it was subsequently transmitted to Square. Consequently, the ListPayments endpoint might list an offline payment chronologically between online payments that were seen in a previous request.
     * @summary ListPayments
     * @param locationId The ID of the location to list payments for. If you specify me, this endpoint returns payments aggregated from all of the business&#39;s locations.
     * @param order The order in which payments are listed in the response.
     * @param beginTime The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
     * @param endTime The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
     * @param limit The maximum number of payments to return in a single response. This value cannot exceed 200.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param includePartial Indicates whether or not to include partial payments in the response. Partial payments will have the tenders collected so far, but the itemizations will be empty until the payment is completed.
     * @param {*} [options] Override http request options.
     */
    public listPayments (locationId: string, order?: string, beginTime?: string, endTime?: string, limit?: number, batchToken?: string, includePartial?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Payment>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/payments'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listPayments.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        if (includePartial !== undefined) {
            localVarQueryParameters['include_partial'] = ObjectSerializer.serialize(includePartial, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Payment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Payment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides the details for all refunds initiated by a merchant or any of the merchant's mobile staff during a date range. Date ranges cannot exceed one year in length.
     * @summary ListRefunds
     * @param locationId The ID of the location to list refunds for.
     * @param order TThe order in which payments are listed in the response.
     * @param beginTime The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
     * @param endTime The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
     * @param limit The approximate number of refunds to return in a single response. Default: 100. Max: 200. Response may contain more results than the prescribed limit when refunds are made simultaneously to multiple tenders in a payment or when refunds are generated in an exchange to account for the value of returned goods.
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listRefunds (locationId: string, order?: string, beginTime?: string, endTime?: string, limit?: number, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Refund>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/refunds'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listRefunds.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Refund>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Refund>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides summary information for all deposits and withdrawals initiated by Square to a linked bank account during a date range. Date ranges cannot exceed one year in length.  *Note**: the ListSettlements endpoint does not provide entry information.
     * @summary ListSettlements
     * @param locationId The ID of the location to list settlements for. If you specify me, this endpoint returns settlements aggregated from all of the business&#39;s locations.
     * @param order The order in which settlements are listed in the response.
     * @param beginTime The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
     * @param endTime The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
     * @param limit The maximum number of settlements to return in a single response. This value cannot exceed 200.
     * @param status Provide this parameter to retrieve only settlements with a particular status (SENT or FAILED).
     * @param batchToken A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request options.
     */
    public listSettlements (locationId: string, order?: string, beginTime?: string, endTime?: string, limit?: number, status?: string, batchToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V1Settlement>;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/settlements'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling listSettlements.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (beginTime !== undefined) {
            localVarQueryParameters['begin_time'] = ObjectSerializer.serialize(beginTime, "string");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (batchToken !== undefined) {
            localVarQueryParameters['batch_token'] = ObjectSerializer.serialize(batchToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V1Settlement>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V1Settlement>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides non-confidential details for a merchant's associated bank account. This endpoint does not provide full bank account numbers, and there is no way to obtain a full bank account number with the Connect API.
     * @summary RetrieveBankAccount
     * @param locationId The ID of the bank account&#39;s associated location.
     * @param bankAccountId The bank account&#39;s Square-issued ID. You obtain this value from Settlement objects returned.
     * @param {*} [options] Override http request options.
     */
    public retrieveBankAccount (locationId: string, bankAccountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1BankAccount;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/bank-accounts/{bank_account_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'bank_account_id' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling retrieveBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1BankAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1BankAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides comprehensive information for a single online store order, including the order's history.
     * @summary RetrieveOrder
     * @param locationId The ID of the order&#39;s associated location.
     * @param orderId The order&#39;s Square-issued ID. You obtain this value from Order objects returned by the List Orders endpoint
     * @param {*} [options] Override http request options.
     */
    public retrieveOrder (locationId: string, orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Order;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/orders/{order_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling retrieveOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Order;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Order");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides comprehensive information for a single payment.
     * @summary RetrievePayment
     * @param locationId The ID of the payment&#39;s associated location.
     * @param paymentId The Square-issued payment ID. payment_id comes from Payment objects returned by the List Payments endpoint, Settlement objects returned by the List Settlements endpoint, or Refund objects returned by the List Refunds endpoint.
     * @param {*} [options] Override http request options.
     */
    public retrievePayment (locationId: string, paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Payment;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/payments/{payment_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'payment_id' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrievePayment.');
        }

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling retrievePayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Payment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Payment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides comprehensive information for a single settlement.  The returned `Settlement` objects include an `entries` field that lists the transactions that contribute to the settlement total. Most settlement entries correspond to a payment payout, but settlement entries are also generated for less common events, like refunds, manual adjustments, or chargeback holds.  Square initiates its regular deposits as indicated in the [Deposit Options with Square](https://squareup.com/help/us/en/article/3807) help article. Details for a regular deposit are usually not available from Connect API endpoints before 10 p.m. PST the same day.  Square does not know when an initiated settlement **completes**, only whether it has failed. A completed settlement is typically reflected in a bank account within 3 business days, but in exceptional cases it may take longer.
     * @summary RetrieveSettlement
     * @param locationId The ID of the settlements&#39;s associated location.
     * @param settlementId The settlement&#39;s Square-issued ID. You obtain this value from Settlement objects returned by the List Settlements endpoint.
     * @param {*} [options] Override http request options.
     */
    public retrieveSettlement (locationId: string, settlementId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Settlement;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/settlements/{settlement_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'settlement_id' + '}', encodeURIComponent(String(settlementId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling retrieveSettlement.');
        }

        // verify required parameter 'settlementId' is not null or undefined
        if (settlementId === null || settlementId === undefined) {
            throw new Error('Required parameter settlementId was null or undefined when calling retrieveSettlement.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Settlement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Settlement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the details of an online store order. Every update you perform on an order corresponds to one of three actions:
     * @summary UpdateOrder
     * @param locationId The ID of the order&#39;s associated location.
     * @param orderId The order&#39;s Square-issued ID. You obtain this value from Order objects returned by the List Orders endpoint
     * @param body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request options.
     */
    public updateOrder (locationId: string, orderId: string, body: V1UpdateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1Order;  }> {
        const localVarPath = this.basePath + '/v1/{location_id}/orders/{order_id}'
            .replace('{' + 'location_id' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "V1UpdateOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1Order;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Order");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
